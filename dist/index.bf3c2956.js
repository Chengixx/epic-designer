import { i as rt, u as Nt, E as Ce, N as bt, b as he, a as un, c as pi, k as la, d as j, e as Cn, p as hi, w as xe, f as Pe, g as Qt, C as vt, h as se, j as cd, l as Za, m as It, t as wt, n as oa, _ as de, T as In, o as Se, q as sa, r as Pt, U as et, s as Ue, I as nn, v as Ct, x as vi, y as Pn, z as mi, A as dd, B as Wt, D as Zn, F as wl, G as Jn, H as Je, J as Yl, K as ft, L as gi, M as fd, O as Rt, P as ot, Q as pt, R as Ll, S as ms, V as pd, W as Mn, X as zo, Y as wn, Z as qn, $ as Xl, a0 as an, a1 as mt, a2 as Ja, a3 as hd, a4 as vd, a5 as kl, a6 as dn, a7 as gs, a8 as md, a9 as Ko, aa as Zl, ab as Mo, ac as Wo, ad as yi, ae as Bt, af as jo, ag as Sl, ah as gd, ai as bi, aj as yd, ak as bd, al as Ci, am as wi, an as Cd, ao as $t, ap as pl, aq as ys, ar as wd, as as aa, at as Qa, au as kd, av as Et, aw as Sd, ax as Ed, ay as Uo, az as $d, aA as ki, aB as Td, aC as Nd, aD as hl, aE as yn, aF as zt, aG as Kn, aH as Si, aI as Vl, aJ as Id, aK as Md, aL as Gn, aM as Ro, aN as Rd, aO as er, aP as Od, aQ as Pd, aR as Ad, aS as Ei, aT as $i, aU as no, aV as _d, aW as Ld, aX as ra, aY as Vd, aZ as Bd, a_ as Dd, a$ as xd, b0 as Qn, b1 as Fd, b2 as Hd, b3 as ia, b4 as ua, b5 as Ti, b6 as zd, b7 as Kd, b8 as Wd, b9 as Ni, ba as Sn, bb as tr, bc as jd, bd as Ud, be as qd, bf as Vn, bg as Gd, bh as Yd, bi as Xd, bj as Zd, bk as Jd, bl as Qd, bm as ef, bn as tf, bo as Ii, bp as nf, bq as lf, br as of, bs as sf, bt as af, bu as rf, bv as uf, bw as cf, bx as df, by as ff, bz as pf, bA as hf, bB as vf, bC as mf, bD as gf, bE as qo, bF as yf, bG as Mi, bH as bf, bI as Cf, bJ as wf, bK as kf } from "./useElementPlus.5a2e6faa.js";
import { b1 as aI, C as rI, ac as iI, E as uI, c4 as cI, bu as dI, bv as fI, bw as pI, bx as hI, by as vI, bz as mI, o as gI, G as yI, b9 as bI, aM as CI, bB as wI, al as kI, bA as SI, ck as EI, cm as $I, cl as TI, D as NI, aL as II, bD as MI, bC as RI, ab as OI, B as PI, d0 as AI, cn as _I, cW as LI, I as VI, ci as BI, cj as DI, d9 as xI, cH as FI, U as HI, cL as zI, cM as KI, bP as WI, bL as jI, bO as UI, bM as qI, cI as GI, J as YI, bQ as XI, cP as ZI, d6 as JI, d3 as QI, ak as eM, bS as tM, aj as nM, bN as lM, aW as oM, bT as sM, aX as aM, bV as rM, bW as iM, bU as uM, bZ as cM, b_ as dM, c0 as fM, c1 as pM, b$ as hM, cN as vM, d4 as mM, c2 as gM, c3 as yM, cg as bM, ca as CM, cb as wM, cc as kM, c5 as SM, c8 as EM, p as $M, co as TM, c6 as NM, cs as IM, cp as MM, cq as RM, ct as OM, bp as PM, cw as AM, cx as _M, cy as LM, cz as VM, cu as BM, cv as DM, cA as xM, cB as FM, a4 as HM, cr as zM, cC as KM, cO as WM, x as jM, d8 as UM, bd as qM, c$ as GM, R as YM, an as XM, bX as ZM, bH as JM, cY as QM, cK as eR, y as tR, a5 as nR, af as lR, a6 as oR, d1 as sR, d2 as aR, d5 as rR, bE as iR, bR as uR, da as cR, ap as dR, cX as fR, P as pR, bI as hR, cQ as vR, cR as mR, cS as gR, h as yR, V as bR, cU as CR, ch as wR, cZ as kR, c_ as SR, cd as ER, ce as $R, cf as TR, c7 as NR, c9 as IR, cT as MR, bJ as RR, bY as OR, e as PR, db as AR, cV as _R, r as LR, cD as VR, cE as BR, cF as DR, cG as xR, aq as FR, ay as HR, cJ as zR, d7 as KR } from "./useElementPlus.5a2e6faa.js";
import { watch as ue, isRef as Nn, ref as N, onUnmounted as Jl, h as fe, Teleport as Go, onMounted as We, getCurrentInstance as je, unref as s, nextTick as Ne, watchEffect as en, defineComponent as F, renderSlot as ne, shallowRef as ht, computed as k, openBlock as E, createElementBlock as _, normalizeClass as $, normalizeStyle as ye, createElementVNode as H, useSlots as kn, createBlock as q, Transition as jt, withCtx as K, withDirectives as qe, resolveDynamicComponent as Ge, createCommentVNode as W, createTextVNode as st, toDisplayString as ce, Fragment as Re, createVNode as x, vShow as at, useAttrs as ca, renderList as Xe, mergeProps as Be, withKeys as ut, withModifiers as Ae, createSlots as Yn, provide as tt, inject as Oe, toRefs as Ut, normalizeProps as Zt, onBeforeUnmount as Dt, reactive as ct, resolveComponent as $e, onBeforeUpdate as Sf, vModelText as Ri, readonly as Ef, toRef as tn, guardReactiveProps as da, markRaw as Rl, effectScope as $f, onUpdated as fa, resolveDirective as Oo, isVNode as Mt, onBeforeMount as Oi, Comment as Tf, TransitionGroup as Nf, createApp as If, shallowReactive as Mf, render as vl } from "vue";
import { a as Yo, k as pa, d as Rf, E as Pi, l as Of, F as Pf, q as Af, G as Ai, i as bs, H as _f, I as Lf, J as Vf, K as Bf, L as Df, B as nr, M as xf, N as Ff, w as Hf, m as zf, h as Gt, O as ns, P as _i, S as Kf, o as Wf, f as bn, Q as jf, g as Lt } from "./isEqual.c2f76849.js";
import { E as Li, a as Kt, b as lr } from "./index.0fb88f51.js";
import { a as jR, E as UR, c as qR, f as GR, d as YR, e as XR, b as ZR } from "./index.0fb88f51.js";
import { t as Uf, u as qf, T as or, a as Gf, b as Yf, c as Vi, d as Xf, e as Zf, D as Jf, C as Qf, r as rl, l as ep, W as ls, f as sr, g as ar, E as tp } from "./index.dfa51ea7.js";
import { C as QR, o as eO, q as tO, D as nO, E as lO, R as oO, e as sO, W as aO, h as rO, i as iO, w as uO, j as cO, k as dO, m as fO, n as pO, p as hO, r as vO, d as mO, s as gO, v as yO } from "./index.dfa51ea7.js";
import { f as Vt } from "./weekYear.7d67b0c3.js";
import { f as CO } from "./weekYear.7d67b0c3.js";
import { E as np } from "./index.edf279c2.js";
import { E as kO, c as SO } from "./index.edf279c2.js";
import { E as Yt, p as $n, a as Bi, b as lp } from "./index.da468ef6.js";
import { E as $O, b as TO, a as NO, e as IO, g as MO, c as RO, d as OO, f as PO } from "./index.da468ef6.js";
import { E as Di, a as op, b as sp } from "./index.e1b0fec6.js";
import { E as _O, a as LO, b as VO, g as BO, r as DO, e as xO, h as FO, f as HO, c as zO, d as KO } from "./index.e1b0fec6.js";
import { b as ha } from "./flatten.3de0f950.js";
import { e as xi, i as Fi, f as ap, b as rp, d as ip, c as up, g as va } from "./_arrayIncludesWith.fc5f2209.js";
import { E as cp } from "./index.bf284462.js";
import { E as jO, c as UO } from "./index.bf284462.js";
import { T as dp } from "./index.1e43ecc1.js";
import { E as fp } from "./index.a834623b.js";
import { E as GO, R as YO, a as XO, r as ZO } from "./index.a834623b.js";
import { r as QO } from "./constants.7f69fb4e.js";
import "./index.f6071fa7.js";
import "./_commonjsHelpers.da91e947.js";
import "./hasIn.d68b1023.js";
const pp = 'a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])', hp = (e) => process.env.NODE_ENV === "test" ? !0 : getComputedStyle(e).position === "fixed" ? !1 : e.offsetParent !== null, rr = (e) => Array.from(e.querySelectorAll(pp)).filter((t) => vp(t) && hp(t)), vp = (e) => {
  if (e.tabIndex > 0 || e.tabIndex === 0 && e.getAttribute("tabIndex") !== null)
    return !0;
  if (e.disabled)
    return !1;
  switch (e.nodeName) {
    case "A":
      return !!e.href && e.rel !== "ignore";
    case "INPUT":
      return !(e.type === "hidden" || e.type === "file");
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA":
      return !0;
    default:
      return !1;
  }
}, io = function(e, t, ...n) {
  let l;
  t.includes("mouse") || t.includes("click") ? l = "MouseEvents" : t.includes("key") ? l = "KeyboardEvent" : l = "HTMLEvents";
  const o = document.createEvent(l);
  return o.initEvent(t, ...n), e.dispatchEvent(o), e;
}, Hi = (e) => !e.getAttribute("aria-owns"), zi = (e, t, n) => {
  const { parentNode: l } = e;
  if (!l)
    return null;
  const o = l.querySelectorAll(n), a = Array.prototype.indexOf.call(o, e);
  return o[a + t] || null;
}, uo = (e) => {
  !e || (e.focus(), !Hi(e) && e.click());
}, mp = (e, t) => {
  if (!rt || !e || !t)
    return !1;
  const n = e.getBoundingClientRect();
  let l;
  return t instanceof Element ? l = t.getBoundingClientRect() : l = {
    top: 0,
    right: window.innerWidth,
    bottom: window.innerHeight,
    left: 0
  }, n.top < l.bottom && n.bottom > l.top && n.right > l.left && n.left < l.right;
}, ir = (e) => {
  let t = 0, n = e;
  for (; n; )
    t += n.offsetTop, n = n.offsetParent;
  return t;
}, gp = (e, t) => Math.abs(ir(e) - ir(t)), ma = (e) => {
  let t, n;
  return e.type === "touchend" ? (n = e.changedTouches[0].clientY, t = e.changedTouches[0].clientX) : e.type.startsWith("touch") ? (n = e.touches[0].clientY, t = e.touches[0].clientX) : (n = e.clientY, t = e.clientX), {
    clientX: t,
    clientY: n
  };
};
function yp() {
}
function bp(e, t, n) {
  if (!Yo(n))
    return !1;
  var l = typeof t;
  return (l == "number" ? pa(n) && Rf(t, n.length) : l == "string" && t in n) ? Pi(n[t], e) : !1;
}
function Cp(e) {
  return xi(function(t, n) {
    var l = -1, o = n.length, a = o > 1 ? n[o - 1] : void 0, r = o > 2 ? n[2] : void 0;
    for (a = e.length > 3 && typeof a == "function" ? (o--, a) : void 0, r && bp(n[0], n[1], r) && (a = o < 3 ? void 0 : a, o = 1), t = Object(t); ++l < o; ) {
      var i = n[l];
      i && e(t, i, l, a);
    }
    return t;
  });
}
function wp(e) {
  return function(t, n, l) {
    for (var o = -1, a = Object(t), r = l(t), i = r.length; i--; ) {
      var u = r[e ? i : ++o];
      if (n(a[u], u, a) === !1)
        break;
    }
    return t;
  };
}
var kp = wp();
const Ki = kp;
function Sp(e, t) {
  return e && Ki(e, t, Of);
}
function Ep(e, t) {
  return function(n, l) {
    if (n == null)
      return n;
    if (!pa(n))
      return e(n, l);
    for (var o = n.length, a = t ? o : -1, r = Object(n); (t ? a-- : ++a < o) && l(r[a], a, r) !== !1; )
      ;
    return n;
  };
}
var $p = Ep(Sp);
const Tp = $p;
function Cs(e, t, n) {
  (n !== void 0 && !Pi(e[t], n) || n === void 0 && !(t in e)) && Pf(e, t, n);
}
function ws(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
function Np(e) {
  return Af(e, Ai(e));
}
function Ip(e, t, n, l, o, a, r) {
  var i = ws(e, n), u = ws(t, n), c = r.get(u);
  if (c) {
    Cs(e, n, c);
    return;
  }
  var p = a ? a(i, u, n + "", e, t, r) : void 0, d = p === void 0;
  if (d) {
    var f = bs(u), h = !f && _f(u), v = !f && !h && Lf(u);
    p = u, f || h || v ? bs(i) ? p = i : Fi(i) ? p = Vf(i) : h ? (d = !1, p = Bf(u, !0)) : v ? (d = !1, p = Df(u, !0)) : p = [] : ap(u) || nr(u) ? (p = i, nr(i) ? p = Np(i) : (!Yo(i) || xf(i)) && (p = Ff(u))) : d = !1;
  }
  d && (r.set(u, p), o(p, u, l, a, r), r.delete(u)), Cs(e, n, p);
}
function Wi(e, t, n, l, o) {
  e !== t && Ki(t, function(a, r) {
    if (o || (o = new Hf()), Yo(a))
      Ip(e, t, r, n, Wi, l, o);
    else {
      var i = l ? l(ws(e, r), a, r + "", e, t, o) : void 0;
      i === void 0 && (i = a), Cs(e, r, i);
    }
  }, Ai);
}
function Mp(e, t) {
  var n = -1, l = pa(e) ? Array(e.length) : [];
  return Tp(e, function(o, a, r) {
    l[++n] = t(o, a, r);
  }), l;
}
function Rp(e, t) {
  var n = bs(e) ? zf : Mp;
  return n(e, rp(t));
}
function Op(e, t) {
  return ha(Rp(e, t), 1);
}
var Pp = 1 / 0;
function Ap(e) {
  var t = e == null ? 0 : e.length;
  return t ? ha(e, Pp) : [];
}
var _p = Cp(function(e, t, n) {
  Wi(e, t, n);
});
const ji = _p;
var Lp = "Expected a function";
function Wn(e, t, n) {
  var l = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Lp);
  return Yo(n) && (l = "leading" in n ? !!n.leading : l, o = "trailing" in n ? !!n.trailing : o), Gt(e, t, {
    leading: l,
    maxWait: t,
    trailing: o
  });
}
var Vp = 1 / 0, Bp = ns && 1 / _i(new ns([, -0]))[1] == Vp ? function(e) {
  return new ns(e);
} : yp;
const Dp = Bp;
var xp = 200;
function Fp(e, t, n) {
  var l = -1, o = ip, a = e.length, r = !0, i = [], u = i;
  if (n)
    r = !1, o = up;
  else if (a >= xp) {
    var c = t ? null : Dp(e);
    if (c)
      return _i(c);
    r = !1, o = Wf, u = new Kf();
  } else
    u = t ? [] : i;
  e:
    for (; ++l < a; ) {
      var p = e[l], d = t ? t(p) : p;
      if (p = n || p !== 0 ? p : 0, r && d === d) {
        for (var f = u.length; f--; )
          if (u[f] === d)
            continue e;
        t && u.push(d), i.push(p);
      } else
        o(u, d, n) || (u !== i && u.push(d), i.push(p));
    }
  return i;
}
var Hp = xi(function(e) {
  return Fp(ha(e, 1, Fi, !0));
});
const os = Hp, ks = [];
let zp = rt ? document.body : void 0;
function Kp(e) {
  const t = document.createElement("div");
  return e !== void 0 && t.setAttribute("id", e), zp.appendChild(t), ks.push(t), t;
}
function Wp(e) {
  ks.splice(ks.indexOf(e), 1), e.remove();
}
const ur = Symbol("INSTALLED_KEY"), Bl = (e) => rt ? window.requestAnimationFrame(e) : setTimeout(e, 16), Xo = (e) => rt ? window.cancelAnimationFrame(e) : clearTimeout(e), il = [], jp = (e) => {
  il.length !== 0 && e.code === Ce.esc && (e.stopPropagation(), il[il.length - 1].handleClose());
}, GN = (e, t) => {
  ue(t, (n) => {
    n ? il.push(e) : il.splice(il.indexOf(e), 1);
  });
};
rt && Nt(document, "keydown", jp);
const YN = (e, t, n) => {
  const l = (a) => {
    n(a) && a.stopImmediatePropagation();
  };
  let o;
  ue(() => e.value, (a) => {
    a ? o = Nt(document, t, l, !0) : o == null || o();
  }, { immediate: !0 });
}, Up = (e, t) => {
  let n;
  ue(() => e.value, (l) => {
    var o, a;
    l ? (n = document.activeElement, Nn(t) && ((a = (o = t.value).focus) == null || a.call(o))) : process.env.NODE_ENV === "test" ? n.focus.call(n) : n.focus();
  });
}, XN = (e, t) => {
  const n = N(!1);
  if (!rt)
    return {
      isTeleportVisible: n,
      showTeleport: bt,
      hideTeleport: bt,
      renderTeleport: bt
    };
  let l = null;
  const o = () => {
    n.value = !0, l === null && (l = Kp());
  }, a = () => {
    n.value = !1, l !== null && (Wp(l), l = null);
  }, r = () => t.value !== !0 ? e() : n.value ? [fe(Go, { to: l }, e())] : void 0;
  return Jl(a), {
    isTeleportVisible: n,
    showTeleport: o,
    hideTeleport: a,
    renderTeleport: r
  };
}, qp = (e, t = 0) => {
  if (t === 0)
    return e;
  const n = N(!1);
  let l = 0;
  const o = () => {
    l && clearTimeout(l), l = window.setTimeout(() => {
      n.value = e.value;
    }, t);
  };
  return We(o), ue(() => e.value, (a) => {
    a ? o() : n.value = a;
  }), n;
}, Ui = "after-appear", qi = "after-enter", Gi = "after-leave", Gp = "appear", Yi = "appear-cancelled", Xi = "before-enter", Zi = "before-leave", Ji = "enter", Qi = "enter-cancelled", eu = "leave", tu = "leave-cancelled", ZN = [
  Ui,
  qi,
  Gi,
  Gp,
  Yi,
  Xi,
  Zi,
  Ji,
  Qi,
  eu,
  tu
], JN = () => {
  const { emit: e } = je();
  return {
    onAfterAppear: () => {
      e(Ui);
    },
    onAfterEnter: () => {
      e(qi);
    },
    onAfterLeave: () => {
      e(Gi);
    },
    onAppearCancelled: () => {
      e(Yi);
    },
    onBeforeEnter: () => {
      e(Xi);
    },
    onBeforeLeave: () => {
      e(Zi);
    },
    onEnter: () => {
      e(Ji);
    },
    onEnterCancelled: () => {
      e(Qi);
    },
    onLeave: () => {
      e(eu);
    },
    onLeaveCancelled: () => {
      e(tu);
    }
  };
}, QN = ({
  indicator: e,
  intermediateIndicator: t,
  shouldSetIntermediate: n = () => !0,
  beforeShow: l,
  afterShow: o,
  afterHide: a,
  beforeHide: r
}) => {
  ue(() => s(e), (i) => {
    i ? (l == null || l(), Ne(() => {
      !s(e) || n("show") && (t.value = !0);
    })) : (r == null || r(), Ne(() => {
      s(e) || n("hide") && (t.value = !1);
    }));
  }), ue(() => t.value, (i) => {
    i ? o == null || o() : a == null || a();
  });
};
function ga(e) {
  return e.split("-")[1];
}
function nu(e) {
  return e === "y" ? "height" : "width";
}
function ya(e) {
  return e.split("-")[0];
}
function ba(e) {
  return ["top", "bottom"].includes(ya(e)) ? "x" : "y";
}
function cr(e, t, n) {
  let {
    reference: l,
    floating: o
  } = e;
  const a = l.x + l.width / 2 - o.width / 2, r = l.y + l.height / 2 - o.height / 2, i = ba(t), u = nu(i), c = l[u] / 2 - o[u] / 2, p = ya(t), d = i === "x";
  let f;
  switch (p) {
    case "top":
      f = {
        x: a,
        y: l.y - o.height
      };
      break;
    case "bottom":
      f = {
        x: a,
        y: l.y + l.height
      };
      break;
    case "right":
      f = {
        x: l.x + l.width,
        y: r
      };
      break;
    case "left":
      f = {
        x: l.x - o.width,
        y: r
      };
      break;
    default:
      f = {
        x: l.x,
        y: l.y
      };
  }
  switch (ga(t)) {
    case "start":
      f[i] -= c * (n && d ? -1 : 1);
      break;
    case "end":
      f[i] += c * (n && d ? -1 : 1);
      break;
  }
  return f;
}
const Yp = async (e, t, n) => {
  const {
    placement: l = "bottom",
    strategy: o = "absolute",
    middleware: a = [],
    platform: r
  } = n, i = a.filter(Boolean), u = await (r.isRTL == null ? void 0 : r.isRTL(t));
  let c = await r.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: p,
    y: d
  } = cr(c, l, u), f = l, h = {}, v = 0;
  for (let m = 0; m < i.length; m++) {
    const {
      name: g,
      fn: w
    } = i[m], {
      x: C,
      y,
      data: b,
      reset: S
    } = await w({
      x: p,
      y: d,
      initialPlacement: l,
      placement: f,
      strategy: o,
      middlewareData: h,
      rects: c,
      platform: r,
      elements: {
        reference: e,
        floating: t
      }
    });
    if (p = C != null ? C : p, d = y != null ? y : d, h = {
      ...h,
      [g]: {
        ...h[g],
        ...b
      }
    }, S && v <= 50) {
      v++, typeof S == "object" && (S.placement && (f = S.placement), S.rects && (c = S.rects === !0 ? await r.getElementRects({
        reference: e,
        floating: t,
        strategy: o
      }) : S.rects), {
        x: p,
        y: d
      } = cr(c, f, u)), m = -1;
      continue;
    }
  }
  return {
    x: p,
    y: d,
    placement: f,
    strategy: o,
    middlewareData: h
  };
};
function Xp(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function Zp(e) {
  return typeof e != "number" ? Xp(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function lu(e) {
  return {
    ...e,
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  };
}
const Jp = Math.min, Qp = Math.max;
function eh(e, t, n) {
  return Qp(e, Jp(t, n));
}
const th = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      element: n,
      padding: l = 0
    } = e || {}, {
      x: o,
      y: a,
      placement: r,
      rects: i,
      platform: u,
      elements: c
    } = t;
    if (n == null)
      return {};
    const p = Zp(l), d = {
      x: o,
      y: a
    }, f = ba(r), h = nu(f), v = await u.getDimensions(n), m = f === "y", g = m ? "top" : "left", w = m ? "bottom" : "right", C = m ? "clientHeight" : "clientWidth", y = i.reference[h] + i.reference[f] - d[f] - i.floating[h], b = d[f] - i.reference[f], S = await (u.getOffsetParent == null ? void 0 : u.getOffsetParent(n));
    let T = S ? S[C] : 0;
    (!T || !await (u.isElement == null ? void 0 : u.isElement(S))) && (T = c.floating[C] || i.floating[h]);
    const O = y / 2 - b / 2, I = p[g], R = T - v[h] - p[w], B = T / 2 - v[h] / 2 + O, D = eh(I, B, R), z = ga(r) != null && B != D && i.reference[h] / 2 - (B < I ? p[g] : p[w]) - v[h] / 2 < 0 ? B < I ? I - B : R - B : 0;
    return {
      [f]: d[f] - z,
      data: {
        [f]: D,
        centerOffset: B - D
      }
    };
  }
});
async function nh(e, t) {
  const {
    placement: n,
    platform: l,
    elements: o
  } = e, a = await (l.isRTL == null ? void 0 : l.isRTL(o.floating)), r = ya(n), i = ga(n), u = ba(n) === "x", c = ["left", "top"].includes(r) ? -1 : 1, p = a && u ? -1 : 1, d = typeof t == "function" ? t(e) : t;
  let {
    mainAxis: f,
    crossAxis: h,
    alignmentAxis: v
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...d
  };
  return i && typeof v == "number" && (h = i === "end" ? v * -1 : v), u ? {
    x: h * p,
    y: f * c
  } : {
    x: f * c,
    y: h * p
  };
}
const lh = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: l
      } = t, o = await nh(t, e);
      return {
        x: n + o.x,
        y: l + o.y,
        data: o
      };
    }
  };
};
function Ht(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function cn(e) {
  return Ht(e).getComputedStyle(e);
}
function ou(e) {
  return e instanceof Ht(e).Node;
}
function Rn(e) {
  return ou(e) ? (e.nodeName || "").toLowerCase() : "";
}
let lo;
function su() {
  if (lo)
    return lo;
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? (lo = e.brands.map((t) => t.brand + "/" + t.version).join(" "), lo) : navigator.userAgent;
}
function ln(e) {
  return e instanceof Ht(e).HTMLElement;
}
function On(e) {
  return e instanceof Ht(e).Element;
}
function dr(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  const t = Ht(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function Zo(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: l,
    display: o
  } = cn(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + l + n) && !["inline", "contents"].includes(o);
}
function oh(e) {
  return ["table", "td", "th"].includes(Rn(e));
}
function Ca(e) {
  const t = /firefox/i.test(su()), n = cn(e), l = n.backdropFilter || n.WebkitBackdropFilter;
  return n.transform !== "none" || n.perspective !== "none" || (l ? l !== "none" : !1) || t && n.willChange === "filter" || t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective"].some((o) => n.willChange.includes(o)) || ["paint", "layout", "strict", "content"].some((o) => {
    const a = n.contain;
    return a != null ? a.includes(o) : !1;
  });
}
function wa() {
  return /^((?!chrome|android).)*safari/i.test(su());
}
function ka(e) {
  return ["html", "body", "#document"].includes(Rn(e));
}
const fr = Math.min, Ol = Math.max, Po = Math.round;
function au(e) {
  const t = cn(e);
  let n = parseFloat(t.width), l = parseFloat(t.height);
  const o = ln(e), a = o ? e.offsetWidth : n, r = o ? e.offsetHeight : l, i = Po(n) !== a || Po(l) !== r;
  return i && (n = a, l = r), {
    width: n,
    height: l,
    fallback: i
  };
}
function ru(e) {
  return On(e) ? e : e.contextElement;
}
const iu = {
  x: 1,
  y: 1
};
function ul(e) {
  const t = ru(e);
  if (!ln(t))
    return iu;
  const n = t.getBoundingClientRect(), {
    width: l,
    height: o,
    fallback: a
  } = au(t);
  let r = (a ? Po(n.width) : n.width) / l, i = (a ? Po(n.height) : n.height) / o;
  return (!r || !Number.isFinite(r)) && (r = 1), (!i || !Number.isFinite(i)) && (i = 1), {
    x: r,
    y: i
  };
}
function Dl(e, t, n, l) {
  var o, a;
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), i = ru(e);
  let u = iu;
  t && (l ? On(l) && (u = ul(l)) : u = ul(e));
  const c = i ? Ht(i) : window, p = wa() && n;
  let d = (r.left + (p && ((o = c.visualViewport) == null ? void 0 : o.offsetLeft) || 0)) / u.x, f = (r.top + (p && ((a = c.visualViewport) == null ? void 0 : a.offsetTop) || 0)) / u.y, h = r.width / u.x, v = r.height / u.y;
  if (i) {
    const m = Ht(i), g = l && On(l) ? Ht(l) : l;
    let w = m.frameElement;
    for (; w && l && g !== m; ) {
      const C = ul(w), y = w.getBoundingClientRect(), b = getComputedStyle(w);
      y.x += (w.clientLeft + parseFloat(b.paddingLeft)) * C.x, y.y += (w.clientTop + parseFloat(b.paddingTop)) * C.y, d *= C.x, f *= C.y, h *= C.x, v *= C.y, d += y.x, f += y.y, w = Ht(w).frameElement;
    }
  }
  return lu({
    width: h,
    height: v,
    x: d,
    y: f
  });
}
function An(e) {
  return ((ou(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function Jo(e) {
  return On(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  };
}
function sh(e) {
  let {
    rect: t,
    offsetParent: n,
    strategy: l
  } = e;
  const o = ln(n), a = An(n);
  if (n === a)
    return t;
  let r = {
    scrollLeft: 0,
    scrollTop: 0
  }, i = {
    x: 1,
    y: 1
  };
  const u = {
    x: 0,
    y: 0
  };
  if ((o || !o && l !== "fixed") && ((Rn(n) !== "body" || Zo(a)) && (r = Jo(n)), ln(n))) {
    const c = Dl(n);
    i = ul(n), u.x = c.x + n.clientLeft, u.y = c.y + n.clientTop;
  }
  return {
    width: t.width * i.x,
    height: t.height * i.y,
    x: t.x * i.x - r.scrollLeft * i.x + u.x,
    y: t.y * i.y - r.scrollTop * i.y + u.y
  };
}
function uu(e) {
  return Dl(An(e)).left + Jo(e).scrollLeft;
}
function ah(e) {
  const t = An(e), n = Jo(e), l = e.ownerDocument.body, o = Ol(t.scrollWidth, t.clientWidth, l.scrollWidth, l.clientWidth), a = Ol(t.scrollHeight, t.clientHeight, l.scrollHeight, l.clientHeight);
  let r = -n.scrollLeft + uu(e);
  const i = -n.scrollTop;
  return cn(l).direction === "rtl" && (r += Ol(t.clientWidth, l.clientWidth) - o), {
    width: o,
    height: a,
    x: r,
    y: i
  };
}
function xl(e) {
  if (Rn(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || dr(e) && e.host || An(e);
  return dr(t) ? t.host : t;
}
function cu(e) {
  const t = xl(e);
  return ka(t) ? t.ownerDocument.body : ln(t) && Zo(t) ? t : cu(t);
}
function du(e, t) {
  var n;
  t === void 0 && (t = []);
  const l = cu(e), o = l === ((n = e.ownerDocument) == null ? void 0 : n.body), a = Ht(l);
  return o ? t.concat(a, a.visualViewport || [], Zo(l) ? l : []) : t.concat(l, du(l));
}
function rh(e, t) {
  const n = Ht(e), l = An(e), o = n.visualViewport;
  let a = l.clientWidth, r = l.clientHeight, i = 0, u = 0;
  if (o) {
    a = o.width, r = o.height;
    const c = wa();
    (!c || c && t === "fixed") && (i = o.offsetLeft, u = o.offsetTop);
  }
  return {
    width: a,
    height: r,
    x: i,
    y: u
  };
}
function ih(e, t) {
  const n = Dl(e, !0, t === "fixed"), l = n.top + e.clientTop, o = n.left + e.clientLeft, a = ln(e) ? ul(e) : {
    x: 1,
    y: 1
  }, r = e.clientWidth * a.x, i = e.clientHeight * a.y, u = o * a.x, c = l * a.y;
  return {
    width: r,
    height: i,
    x: u,
    y: c
  };
}
function pr(e, t, n) {
  let l;
  if (t === "viewport")
    l = rh(e, n);
  else if (t === "document")
    l = ah(An(e));
  else if (On(t))
    l = ih(t, n);
  else {
    const r = {
      ...t
    };
    if (wa()) {
      var o, a;
      const i = Ht(e);
      r.x -= ((o = i.visualViewport) == null ? void 0 : o.offsetLeft) || 0, r.y -= ((a = i.visualViewport) == null ? void 0 : a.offsetTop) || 0;
    }
    l = r;
  }
  return lu(l);
}
function uh(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let l = du(e).filter((i) => On(i) && Rn(i) !== "body"), o = null;
  const a = cn(e).position === "fixed";
  let r = a ? xl(e) : e;
  for (; On(r) && !ka(r); ) {
    const i = cn(r), u = Ca(r);
    i.position === "fixed" ? o = null : (a ? !u && !o : !u && i.position === "static" && !!o && ["absolute", "fixed"].includes(o.position)) ? l = l.filter((d) => d !== r) : o = i, r = xl(r);
  }
  return t.set(e, l), l;
}
function ch(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: l,
    strategy: o
  } = e;
  const r = [...n === "clippingAncestors" ? uh(t, this._c) : [].concat(n), l], i = r[0], u = r.reduce((c, p) => {
    const d = pr(t, p, o);
    return c.top = Ol(d.top, c.top), c.right = fr(d.right, c.right), c.bottom = fr(d.bottom, c.bottom), c.left = Ol(d.left, c.left), c;
  }, pr(t, i, o));
  return {
    width: u.right - u.left,
    height: u.bottom - u.top,
    x: u.left,
    y: u.top
  };
}
function dh(e) {
  return au(e);
}
function hr(e, t) {
  return !ln(e) || cn(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
function fh(e) {
  let t = xl(e);
  for (; ln(t) && !ka(t); ) {
    if (Ca(t))
      return t;
    t = xl(t);
  }
  return null;
}
function vr(e, t) {
  const n = Ht(e);
  if (!ln(e))
    return n;
  let l = hr(e, t);
  for (; l && oh(l) && cn(l).position === "static"; )
    l = hr(l, t);
  return l && (Rn(l) === "html" || Rn(l) === "body" && cn(l).position === "static" && !Ca(l)) ? n : l || fh(e) || n;
}
function ph(e, t, n) {
  const l = ln(t), o = An(t), a = Dl(e, !0, n === "fixed", t);
  let r = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const i = {
    x: 0,
    y: 0
  };
  if (l || !l && n !== "fixed")
    if ((Rn(t) !== "body" || Zo(o)) && (r = Jo(t)), ln(t)) {
      const u = Dl(t, !0);
      i.x = u.x + t.clientLeft, i.y = u.y + t.clientTop;
    } else
      o && (i.x = uu(o));
  return {
    x: a.left + r.scrollLeft - i.x,
    y: a.top + r.scrollTop - i.y,
    width: a.width,
    height: a.height
  };
}
const hh = {
  getClippingRect: ch,
  convertOffsetParentRelativeRectToViewportRelativeRect: sh,
  isElement: On,
  getDimensions: dh,
  getOffsetParent: vr,
  getDocumentElement: An,
  getScale: ul,
  async getElementRects(e) {
    let {
      reference: t,
      floating: n,
      strategy: l
    } = e;
    const o = this.getOffsetParent || vr, a = this.getDimensions;
    return {
      reference: ph(t, await o(n), l),
      floating: {
        x: 0,
        y: 0,
        ...await a(n)
      }
    };
  },
  getClientRects: (e) => Array.from(e.getClientRects()),
  isRTL: (e) => cn(e).direction === "rtl"
}, vh = (e, t, n) => {
  const l = /* @__PURE__ */ new Map(), o = {
    platform: hh,
    ...n
  }, a = {
    ...o.platform,
    _c: l
  };
  return Yp(e, t, {
    ...o,
    platform: a
  });
}, eI = he({}), mh = (e) => {
  if (!rt)
    return;
  if (!e)
    return e;
  const t = pi(e);
  return t || (Nn(e) ? t : e);
}, tI = (e, t) => {
  const n = e == null ? void 0 : e[t];
  return un(n) ? "" : `${n}px`;
}, gh = ({
  middleware: e,
  placement: t,
  strategy: n
}) => {
  const l = N(), o = N(), a = N(), r = N(), i = N({}), u = {
    x: a,
    y: r,
    placement: t,
    strategy: n,
    middlewareData: i
  }, c = async () => {
    if (!rt)
      return;
    const p = mh(l), d = pi(o);
    if (!p || !d)
      return;
    const f = await vh(p, d, {
      placement: s(t),
      strategy: s(n),
      middleware: s(e)
    });
    la(u).forEach((h) => {
      u[h].value = f[h];
    });
  };
  return We(() => {
    en(() => {
      c();
    });
  }), {
    ...u,
    update: c,
    referenceRef: l,
    contentRef: o
  };
}, yh = ({
  arrowRef: e,
  padding: t
}) => ({
  name: "arrow",
  options: {
    element: e,
    padding: t
  },
  fn(n) {
    const l = s(e);
    return l ? th({
      element: l,
      padding: t
    }).fn(n) : {};
  }
}), bh = he({
  a11y: {
    type: Boolean,
    default: !0
  },
  locale: {
    type: j(Object)
  },
  size: Cn,
  button: {
    type: j(Object)
  },
  experimentalFeatures: {
    type: j(Object)
  },
  keyboardNavigation: {
    type: Boolean,
    default: !0
  },
  message: {
    type: j(Object)
  },
  zIndex: Number,
  namespace: {
    type: String,
    default: "el"
  }
}), Ss = {}, Ch = F({
  name: "ElConfigProvider",
  props: bh,
  setup(e, { slots: t }) {
    ue(() => e.message, (l) => {
      Object.assign(Ss, l != null ? l : {});
    }, { immediate: !0, deep: !0 });
    const n = hi(e);
    return () => ne(t, "default", { config: n == null ? void 0 : n.value });
  }
}), wh = xe(Ch), kh = "2.3.2", Sh = (e = []) => ({
  version: kh,
  install: (n, l) => {
    n[ur] || (n[ur] = !0, e.forEach((o) => n.use(o)), l && hi(l, n, !0));
  }
}), Eh = he({
  zIndex: {
    type: j([Number, String]),
    default: 100
  },
  target: {
    type: String,
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  position: {
    type: String,
    values: ["top", "bottom"],
    default: "top"
  }
}), $h = {
  scroll: ({ scrollTop: e, fixed: t }) => Pe(e) && Qt(t),
  [vt]: (e) => Qt(e)
}, fu = "ElAffix", Th = F({
  name: fu
}), Nh = /* @__PURE__ */ F({
  ...Th,
  props: Eh,
  emits: $h,
  setup(e, { expose: t, emit: n }) {
    const l = e, o = se("affix"), a = ht(), r = ht(), i = ht(), { height: u } = cd(), {
      height: c,
      width: p,
      top: d,
      bottom: f,
      update: h
    } = Za(r, { windowScroll: !1 }), v = Za(a), m = N(!1), g = N(0), w = N(0), C = k(() => ({
      height: m.value ? `${c.value}px` : "",
      width: m.value ? `${p.value}px` : ""
    })), y = k(() => {
      if (!m.value)
        return {};
      const T = l.offset ? It(l.offset) : 0;
      return {
        height: `${c.value}px`,
        width: `${p.value}px`,
        top: l.position === "top" ? T : "",
        bottom: l.position === "bottom" ? T : "",
        transform: w.value ? `translateY(${w.value}px)` : "",
        zIndex: l.zIndex
      };
    }), b = () => {
      if (!!i.value)
        if (g.value = i.value instanceof Window ? document.documentElement.scrollTop : i.value.scrollTop || 0, l.position === "top")
          if (l.target) {
            const T = v.bottom.value - l.offset - c.value;
            m.value = l.offset > d.value && v.bottom.value > 0, w.value = T < 0 ? T : 0;
          } else
            m.value = l.offset > d.value;
        else if (l.target) {
          const T = u.value - v.top.value - l.offset - c.value;
          m.value = u.value - l.offset < f.value && u.value > v.top.value, w.value = T < 0 ? -T : 0;
        } else
          m.value = u.value - l.offset < f.value;
    }, S = () => {
      h(), n("scroll", {
        scrollTop: g.value,
        fixed: m.value
      });
    };
    return ue(m, (T) => n("change", T)), We(() => {
      var T;
      l.target ? (a.value = (T = document.querySelector(l.target)) != null ? T : void 0, a.value || wt(fu, `Target is not existed: ${l.target}`)) : a.value = document.documentElement, i.value = oa(r.value, !0), h();
    }), Nt(i, "scroll", S), en(b), t({
      update: b,
      updateRoot: h
    }), (T, O) => (E(), _("div", {
      ref_key: "root",
      ref: r,
      class: $(s(o).b()),
      style: ye(s(C))
    }, [
      H("div", {
        class: $({ [s(o).m("fixed")]: m.value }),
        style: ye(s(y))
      }, [
        ne(T.$slots, "default")
      ], 6)
    ], 6));
  }
});
var Ih = /* @__PURE__ */ de(Nh, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/affix/src/affix.vue"]]);
const Mh = xe(Ih), Rh = ["light", "dark"], Oh = he({
  title: {
    type: String,
    default: ""
  },
  description: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: la(In),
    default: "info"
  },
  closable: {
    type: Boolean,
    default: !0
  },
  closeText: {
    type: String,
    default: ""
  },
  showIcon: Boolean,
  center: Boolean,
  effect: {
    type: String,
    values: Rh,
    default: "light"
  }
}), Ph = {
  close: (e) => e instanceof MouseEvent
}, Ah = F({
  name: "ElAlert"
}), _h = /* @__PURE__ */ F({
  ...Ah,
  props: Oh,
  emits: Ph,
  setup(e, { emit: t }) {
    const n = e, { Close: l } = sa, o = kn(), a = se("alert"), r = N(!0), i = k(() => In[n.type]), u = k(() => [
      a.e("icon"),
      { [a.is("big")]: !!n.description || !!o.default }
    ]), c = k(() => ({ [a.is("bold")]: n.description || o.default })), p = (d) => {
      r.value = !1, t("close", d);
    };
    return (d, f) => (E(), q(jt, {
      name: s(a).b("fade"),
      persisted: ""
    }, {
      default: K(() => [
        qe(H("div", {
          class: $([s(a).b(), s(a).m(d.type), s(a).is("center", d.center), s(a).is(d.effect)]),
          role: "alert"
        }, [
          d.showIcon && s(i) ? (E(), q(s(Se), {
            key: 0,
            class: $(s(u))
          }, {
            default: K(() => [
              (E(), q(Ge(s(i))))
            ]),
            _: 1
          }, 8, ["class"])) : W("v-if", !0),
          H("div", {
            class: $(s(a).e("content"))
          }, [
            d.title || d.$slots.title ? (E(), _("span", {
              key: 0,
              class: $([s(a).e("title"), s(c)])
            }, [
              ne(d.$slots, "title", {}, () => [
                st(ce(d.title), 1)
              ])
            ], 2)) : W("v-if", !0),
            d.$slots.default || d.description ? (E(), _("p", {
              key: 1,
              class: $(s(a).e("description"))
            }, [
              ne(d.$slots, "default", {}, () => [
                st(ce(d.description), 1)
              ])
            ], 2)) : W("v-if", !0),
            d.closable ? (E(), _(Re, { key: 2 }, [
              d.closeText ? (E(), _("div", {
                key: 0,
                class: $([s(a).e("close-btn"), s(a).is("customed")]),
                onClick: p
              }, ce(d.closeText), 3)) : (E(), q(s(Se), {
                key: 1,
                class: $(s(a).e("close-btn")),
                onClick: p
              }, {
                default: K(() => [
                  x(s(l))
                ]),
                _: 1
              }, 8, ["class"]))
            ], 64)) : W("v-if", !0)
          ], 2)
        ], 2), [
          [at, r.value]
        ])
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var Lh = /* @__PURE__ */ de(_h, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/alert/src/alert.vue"]]);
const Vh = xe(Lh), Bh = he({
  valueKey: {
    type: String,
    default: "value"
  },
  modelValue: {
    type: [String, Number],
    default: ""
  },
  debounce: {
    type: Number,
    default: 300
  },
  placement: {
    type: j(String),
    values: [
      "top",
      "top-start",
      "top-end",
      "bottom",
      "bottom-start",
      "bottom-end"
    ],
    default: "bottom-start"
  },
  fetchSuggestions: {
    type: j([Function, Array]),
    default: bt
  },
  popperClass: {
    type: String,
    default: ""
  },
  triggerOnFocus: {
    type: Boolean,
    default: !0
  },
  selectWhenUnmatched: {
    type: Boolean,
    default: !1
  },
  hideLoading: {
    type: Boolean,
    default: !1
  },
  label: {
    type: String
  },
  teleported: Pt.teleported,
  highlightFirstItem: {
    type: Boolean,
    default: !1
  },
  fitInputWidth: {
    type: Boolean,
    default: !1
  },
  clearable: {
    type: Boolean,
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  name: String
}), Dh = {
  [et]: (e) => Ue(e),
  [nn]: (e) => Ue(e),
  [vt]: (e) => Ue(e),
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent,
  clear: () => !0,
  select: (e) => Ct(e)
}, xh = ["aria-expanded", "aria-owns"], Fh = { key: 0 }, Hh = ["id", "aria-selected", "onClick"], pu = "ElAutocomplete", zh = F({
  name: pu,
  inheritAttrs: !1
}), Kh = /* @__PURE__ */ F({
  ...zh,
  props: Bh,
  emits: Dh,
  setup(e, { expose: t, emit: n }) {
    const l = e, o = vi(), a = ca(), r = Pn(), i = se("autocomplete"), u = N(), c = N(), p = N(), d = N();
    let f = !1, h = !1;
    const v = N([]), m = N(-1), g = N(""), w = N(!1), C = N(!1), y = N(!1), b = k(() => i.b(String(mi()))), S = k(() => a.style), T = k(() => (v.value.length > 0 || y.value) && w.value), O = k(() => !l.hideLoading && y.value), I = k(() => u.value ? Array.from(u.value.$el.querySelectorAll("input")) : []), R = async () => {
      await Ne(), T.value && (g.value = `${u.value.$el.offsetWidth}px`);
    }, B = () => {
      m.value = -1;
    }, A = Gt(async (te) => {
      if (C.value)
        return;
      const ve = (G) => {
        y.value = !1, !C.value && (Je(G) ? (v.value = G, m.value = l.highlightFirstItem ? 0 : -1) : wt(pu, "autocomplete suggestions must be an array"));
      };
      if (y.value = !0, Je(l.fetchSuggestions))
        ve(l.fetchSuggestions);
      else {
        const G = await l.fetchSuggestions(te, ve);
        Je(G) && ve(G);
      }
    }, l.debounce), z = (te) => {
      const ve = !!te;
      if (n(nn, te), n(et, te), C.value = !1, w.value || (w.value = ve), !l.triggerOnFocus && !te) {
        C.value = !0, v.value = [];
        return;
      }
      A(te);
    }, Z = (te) => {
      var ve;
      r.value || (((ve = te.target) == null ? void 0 : ve.tagName) !== "INPUT" || I.value.includes(document.activeElement)) && (w.value = !0);
    }, J = (te) => {
      n(vt, te);
    }, V = (te) => {
      h ? h = !1 : (w.value = !0, n("focus", te), l.triggerOnFocus && !f && A(String(l.modelValue)));
    }, M = (te) => {
      setTimeout(() => {
        var ve;
        if ((ve = p.value) != null && ve.isFocusInsideContent()) {
          h = !0;
          return;
        }
        w.value && oe(), n("blur", te);
      });
    }, P = () => {
      w.value = !1, n(et, ""), n("clear");
    }, L = async () => {
      T.value && m.value >= 0 && m.value < v.value.length ? pe(v.value[m.value]) : l.selectWhenUnmatched && (n("select", { value: l.modelValue }), v.value = [], m.value = -1);
    }, U = (te) => {
      T.value && (te.preventDefault(), te.stopPropagation(), oe());
    }, oe = () => {
      w.value = !1;
    }, le = () => {
      var te;
      (te = u.value) == null || te.focus();
    }, ee = () => {
      var te;
      (te = u.value) == null || te.blur();
    }, pe = async (te) => {
      n(nn, te[l.valueKey]), n(et, te[l.valueKey]), n("select", te), v.value = [], m.value = -1;
    }, ge = (te) => {
      if (!T.value || y.value)
        return;
      if (te < 0) {
        m.value = -1;
        return;
      }
      te >= v.value.length && (te = v.value.length - 1);
      const ve = c.value.querySelector(`.${i.be("suggestion", "wrap")}`), Q = ve.querySelectorAll(`.${i.be("suggestion", "list")} li`)[te], ie = ve.scrollTop, { offsetTop: Ee, scrollHeight: De } = Q;
      Ee + De > ie + ve.clientHeight && (ve.scrollTop += De), Ee < ie && (ve.scrollTop -= De), m.value = te, u.value.ref.setAttribute("aria-activedescendant", `${b.value}-item-${m.value}`);
    };
    return dd(d, () => {
      T.value && oe();
    }), We(() => {
      u.value.ref.setAttribute("role", "textbox"), u.value.ref.setAttribute("aria-autocomplete", "list"), u.value.ref.setAttribute("aria-controls", "id"), u.value.ref.setAttribute("aria-activedescendant", `${b.value}-item-${m.value}`), f = u.value.ref.hasAttribute("readonly");
    }), t({
      highlightedIndex: m,
      activated: w,
      loading: y,
      inputRef: u,
      popperRef: p,
      suggestions: v,
      handleSelect: pe,
      handleKeyEnter: L,
      focus: le,
      blur: ee,
      close: oe,
      highlight: ge
    }), (te, ve) => (E(), q(s(Wt), {
      ref_key: "popperRef",
      ref: p,
      visible: s(T),
      placement: te.placement,
      "fallback-placements": ["bottom-start", "top-start"],
      "popper-class": [s(i).e("popper"), te.popperClass],
      teleported: te.teleported,
      "gpu-acceleration": !1,
      pure: "",
      "manual-mode": "",
      effect: "light",
      trigger: "click",
      transition: `${s(i).namespace.value}-zoom-in-top`,
      persistent: "",
      onBeforeShow: R,
      onHide: B
    }, {
      content: K(() => [
        H("div", {
          ref_key: "regionRef",
          ref: c,
          class: $([s(i).b("suggestion"), s(i).is("loading", s(O))]),
          style: ye({
            [te.fitInputWidth ? "width" : "minWidth"]: g.value,
            outline: "none"
          }),
          role: "region"
        }, [
          x(s(Zn), {
            id: s(b),
            tag: "ul",
            "wrap-class": s(i).be("suggestion", "wrap"),
            "view-class": s(i).be("suggestion", "list"),
            role: "listbox"
          }, {
            default: K(() => [
              s(O) ? (E(), _("li", Fh, [
                x(s(Se), {
                  class: $(s(i).is("loading"))
                }, {
                  default: K(() => [
                    x(s(wl))
                  ]),
                  _: 1
                }, 8, ["class"])
              ])) : (E(!0), _(Re, { key: 1 }, Xe(v.value, (G, Q) => (E(), _("li", {
                id: `${s(b)}-item-${Q}`,
                key: Q,
                class: $({ highlighted: m.value === Q }),
                role: "option",
                "aria-selected": m.value === Q,
                onClick: (ie) => pe(G)
              }, [
                ne(te.$slots, "default", { item: G }, () => [
                  st(ce(G[te.valueKey]), 1)
                ])
              ], 10, Hh))), 128))
            ]),
            _: 3
          }, 8, ["id", "wrap-class", "view-class"])
        ], 6)
      ]),
      default: K(() => [
        H("div", {
          ref_key: "listboxRef",
          ref: d,
          class: $([s(i).b(), te.$attrs.class]),
          style: ye(s(S)),
          role: "combobox",
          "aria-haspopup": "listbox",
          "aria-expanded": s(T),
          "aria-owns": s(b)
        }, [
          x(s(Jn), Be({
            ref_key: "inputRef",
            ref: u
          }, s(o), {
            clearable: te.clearable,
            disabled: s(r),
            name: te.name,
            "model-value": te.modelValue,
            onInput: z,
            onChange: J,
            onFocus: V,
            onBlur: M,
            onClear: P,
            onKeydown: [
              ve[0] || (ve[0] = ut(Ae((G) => ge(m.value - 1), ["prevent"]), ["up"])),
              ve[1] || (ve[1] = ut(Ae((G) => ge(m.value + 1), ["prevent"]), ["down"])),
              ut(L, ["enter"]),
              ut(oe, ["tab"]),
              ut(U, ["esc"])
            ],
            onMousedown: Z
          }), Yn({ _: 2 }, [
            te.$slots.prepend ? {
              name: "prepend",
              fn: K(() => [
                ne(te.$slots, "prepend")
              ])
            } : void 0,
            te.$slots.append ? {
              name: "append",
              fn: K(() => [
                ne(te.$slots, "append")
              ])
            } : void 0,
            te.$slots.prefix ? {
              name: "prefix",
              fn: K(() => [
                ne(te.$slots, "prefix")
              ])
            } : void 0,
            te.$slots.suffix ? {
              name: "suffix",
              fn: K(() => [
                ne(te.$slots, "suffix")
              ])
            } : void 0
          ]), 1040, ["clearable", "disabled", "name", "model-value", "onKeydown"])
        ], 14, xh)
      ]),
      _: 3
    }, 8, ["visible", "placement", "popper-class", "teleported", "transition"]));
  }
});
var Wh = /* @__PURE__ */ de(Kh, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/autocomplete/src/autocomplete.vue"]]);
const jh = xe(Wh), Uh = he({
  size: {
    type: [Number, String],
    values: Yl,
    default: "",
    validator: (e) => Pe(e)
  },
  shape: {
    type: String,
    values: ["circle", "square"],
    default: "circle"
  },
  icon: {
    type: ft
  },
  src: {
    type: String,
    default: ""
  },
  alt: String,
  srcSet: String,
  fit: {
    type: j(String),
    default: "cover"
  }
}), qh = {
  error: (e) => e instanceof Event
}, Gh = ["src", "alt", "srcset"], Yh = F({
  name: "ElAvatar"
}), Xh = /* @__PURE__ */ F({
  ...Yh,
  props: Uh,
  emits: qh,
  setup(e, { emit: t }) {
    const n = e, l = se("avatar"), o = N(!1), a = k(() => {
      const { size: c, icon: p, shape: d } = n, f = [l.b()];
      return Ue(c) && f.push(l.m(c)), p && f.push(l.m("icon")), d && f.push(l.m(d)), f;
    }), r = k(() => {
      const { size: c } = n;
      return Pe(c) ? l.cssVarBlock({
        size: It(c) || ""
      }) : void 0;
    }), i = k(() => ({
      objectFit: n.fit
    }));
    ue(() => n.src, () => o.value = !1);
    function u(c) {
      o.value = !0, t("error", c);
    }
    return (c, p) => (E(), _("span", {
      class: $(s(a)),
      style: ye(s(r))
    }, [
      (c.src || c.srcSet) && !o.value ? (E(), _("img", {
        key: 0,
        src: c.src,
        alt: c.alt,
        srcset: c.srcSet,
        style: ye(s(i)),
        onError: u
      }, null, 44, Gh)) : c.icon ? (E(), q(s(Se), { key: 1 }, {
        default: K(() => [
          (E(), q(Ge(c.icon)))
        ]),
        _: 1
      })) : ne(c.$slots, "default", { key: 2 })
    ], 6));
  }
});
var Zh = /* @__PURE__ */ de(Xh, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/avatar/src/avatar.vue"]]);
const Jh = xe(Zh), Qh = {
  visibilityHeight: {
    type: Number,
    default: 200
  },
  target: {
    type: String,
    default: ""
  },
  right: {
    type: Number,
    default: 40
  },
  bottom: {
    type: Number,
    default: 40
  }
}, ev = {
  click: (e) => e instanceof MouseEvent
}, tv = (e, t, n) => {
  const l = ht(), o = ht(), a = N(!1), r = () => {
    l.value && (a.value = l.value.scrollTop >= e.visibilityHeight);
  }, i = (c) => {
    var p;
    (p = l.value) == null || p.scrollTo({ top: 0, behavior: "smooth" }), t("click", c);
  }, u = gi(r, 300, !0);
  return Nt(o, "scroll", u), We(() => {
    var c;
    o.value = document, l.value = document.documentElement, e.target && (l.value = (c = document.querySelector(e.target)) != null ? c : void 0, l.value || wt(n, `target does not exist: ${e.target}`), o.value = l.value);
  }), {
    visible: a,
    handleClick: i
  };
}, hu = "ElBacktop", nv = F({
  name: hu
}), lv = /* @__PURE__ */ F({
  ...nv,
  props: Qh,
  emits: ev,
  setup(e, { emit: t }) {
    const n = e, l = se("backtop"), { handleClick: o, visible: a } = tv(n, t, hu), r = k(() => ({
      right: `${n.right}px`,
      bottom: `${n.bottom}px`
    }));
    return (i, u) => (E(), q(jt, {
      name: `${s(l).namespace.value}-fade-in`
    }, {
      default: K(() => [
        s(a) ? (E(), _("div", {
          key: 0,
          style: ye(s(r)),
          class: $(s(l).b()),
          onClick: u[0] || (u[0] = Ae((...c) => s(o) && s(o)(...c), ["stop"]))
        }, [
          ne(i.$slots, "default", {}, () => [
            x(s(Se), {
              class: $(s(l).e("icon"))
            }, {
              default: K(() => [
                x(s(fd))
              ]),
              _: 1
            }, 8, ["class"])
          ])
        ], 6)) : W("v-if", !0)
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var ov = /* @__PURE__ */ de(lv, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/backtop/src/backtop.vue"]]);
const sv = xe(ov), av = he({
  value: {
    type: [String, Number],
    default: ""
  },
  max: {
    type: Number,
    default: 99
  },
  isDot: Boolean,
  hidden: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger"],
    default: "danger"
  }
}), rv = ["textContent"], iv = F({
  name: "ElBadge"
}), uv = /* @__PURE__ */ F({
  ...iv,
  props: av,
  setup(e, { expose: t }) {
    const n = e, l = se("badge"), o = k(() => n.isDot ? "" : Pe(n.value) && Pe(n.max) ? n.max < n.value ? `${n.max}+` : `${n.value}` : `${n.value}`);
    return t({
      content: o
    }), (a, r) => (E(), _("div", {
      class: $(s(l).b())
    }, [
      ne(a.$slots, "default"),
      x(jt, {
        name: `${s(l).namespace.value}-zoom-in-center`,
        persisted: ""
      }, {
        default: K(() => [
          qe(H("sup", {
            class: $([
              s(l).e("content"),
              s(l).em("content", a.type),
              s(l).is("fixed", !!a.$slots.default),
              s(l).is("dot", a.isDot)
            ]),
            textContent: ce(s(o))
          }, null, 10, rv), [
            [at, !a.hidden && (s(o) || a.isDot)]
          ])
        ]),
        _: 1
      }, 8, ["name"])
    ], 2));
  }
});
var cv = /* @__PURE__ */ de(uv, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]);
const vu = xe(cv), mu = Symbol("breadcrumbKey"), dv = he({
  separator: {
    type: String,
    default: "/"
  },
  separatorIcon: {
    type: ft
  }
}), fv = F({
  name: "ElBreadcrumb"
}), pv = /* @__PURE__ */ F({
  ...fv,
  props: dv,
  setup(e) {
    const t = e, n = se("breadcrumb"), l = N();
    return tt(mu, t), We(() => {
      const o = l.value.querySelectorAll(`.${n.e("item")}`);
      o.length && o[o.length - 1].setAttribute("aria-current", "page");
    }), (o, a) => (E(), _("div", {
      ref_key: "breadcrumb",
      ref: l,
      class: $(s(n).b()),
      "aria-label": "Breadcrumb",
      role: "navigation"
    }, [
      ne(o.$slots, "default")
    ], 2));
  }
});
var hv = /* @__PURE__ */ de(pv, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/breadcrumb/src/breadcrumb.vue"]]);
const vv = he({
  to: {
    type: j([String, Object]),
    default: ""
  },
  replace: {
    type: Boolean,
    default: !1
  }
}), mv = F({
  name: "ElBreadcrumbItem"
}), gv = /* @__PURE__ */ F({
  ...mv,
  props: vv,
  setup(e) {
    const t = e, n = je(), l = Oe(mu, void 0), o = se("breadcrumb"), { separator: a, separatorIcon: r } = Ut(l), i = n.appContext.config.globalProperties.$router, u = N(), c = () => {
      !t.to || !i || (t.replace ? i.replace(t.to) : i.push(t.to));
    };
    return (p, d) => (E(), _("span", {
      class: $(s(o).e("item"))
    }, [
      H("span", {
        ref_key: "link",
        ref: u,
        class: $([s(o).e("inner"), s(o).is("link", !!p.to)]),
        role: "link",
        onClick: c
      }, [
        ne(p.$slots, "default")
      ], 2),
      s(r) ? (E(), q(s(Se), {
        key: 0,
        class: $(s(o).e("separator"))
      }, {
        default: K(() => [
          (E(), q(Ge(s(r))))
        ]),
        _: 1
      }, 8, ["class"])) : (E(), _("span", {
        key: 1,
        class: $(s(o).e("separator")),
        role: "presentation"
      }, ce(s(a)), 3))
    ], 2));
  }
});
var gu = /* @__PURE__ */ de(gv, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/breadcrumb/src/breadcrumb-item.vue"]]);
const yv = xe(hv, {
  BreadcrumbItem: gu
}), bv = Rt(gu), Es = "_trap-focus-children", xn = [], mr = (e) => {
  var t;
  if (xn.length === 0)
    return;
  const n = xn[xn.length - 1][Es];
  if (n.length > 0 && e.code === Ce.tab) {
    if (n.length === 1) {
      e.preventDefault(), document.activeElement !== n[0] && n[0].focus();
      return;
    }
    const l = e.shiftKey, o = e.target === n[0], a = e.target === n[n.length - 1];
    if (o && l && (e.preventDefault(), n[n.length - 1].focus()), a && !l && (e.preventDefault(), n[0].focus()), process.env.NODE_ENV === "test") {
      const r = n.indexOf(e.target);
      r !== -1 && ((t = n[l ? r - 1 : r + 1]) == null || t.focus());
    }
  }
}, Cv = {
  beforeMount(e) {
    e[Es] = rr(e), xn.push(e), xn.length <= 1 && document.addEventListener("keydown", mr);
  },
  updated(e) {
    Ne(() => {
      e[Es] = rr(e);
    });
  },
  unmounted() {
    xn.shift(), xn.length === 0 && document.removeEventListener("keydown", mr);
  }
};
var gr = !1, Bn, $s, Ts, co, fo, yu, po, Ns, Is, Ms, bu, Rs, Os, Cu, wu;
function At() {
  if (!gr) {
    gr = !0;
    var e = navigator.userAgent, t = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), n = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
    if (Rs = /\b(iPhone|iP[ao]d)/.exec(e), Os = /\b(iP[ao]d)/.exec(e), Ms = /Android/i.exec(e), Cu = /FBAN\/\w+;/i.exec(e), wu = /Mobile/i.exec(e), bu = !!/Win64/.exec(e), t) {
      Bn = t[1] ? parseFloat(t[1]) : t[5] ? parseFloat(t[5]) : NaN, Bn && document && document.documentMode && (Bn = document.documentMode);
      var l = /(?:Trident\/(\d+.\d+))/.exec(e);
      yu = l ? parseFloat(l[1]) + 4 : Bn, $s = t[2] ? parseFloat(t[2]) : NaN, Ts = t[3] ? parseFloat(t[3]) : NaN, co = t[4] ? parseFloat(t[4]) : NaN, co ? (t = /(?:Chrome\/(\d+\.\d+))/.exec(e), fo = t && t[1] ? parseFloat(t[1]) : NaN) : fo = NaN;
    } else
      Bn = $s = Ts = fo = co = NaN;
    if (n) {
      if (n[1]) {
        var o = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
        po = o ? parseFloat(o[1].replace("_", ".")) : !0;
      } else
        po = !1;
      Ns = !!n[2], Is = !!n[3];
    } else
      po = Ns = Is = !1;
  }
}
var Ps = { ie: function() {
  return At() || Bn;
}, ieCompatibilityMode: function() {
  return At() || yu > Bn;
}, ie64: function() {
  return Ps.ie() && bu;
}, firefox: function() {
  return At() || $s;
}, opera: function() {
  return At() || Ts;
}, webkit: function() {
  return At() || co;
}, safari: function() {
  return Ps.webkit();
}, chrome: function() {
  return At() || fo;
}, windows: function() {
  return At() || Ns;
}, osx: function() {
  return At() || po;
}, linux: function() {
  return At() || Is;
}, iphone: function() {
  return At() || Rs;
}, mobile: function() {
  return At() || Rs || Os || Ms || wu;
}, nativeApp: function() {
  return At() || Cu;
}, android: function() {
  return At() || Ms;
}, ipad: function() {
  return At() || Os;
} }, wv = Ps, oo = !!(typeof window < "u" && window.document && window.document.createElement), kv = { canUseDOM: oo, canUseWorkers: typeof Worker < "u", canUseEventListeners: oo && !!(window.addEventListener || window.attachEvent), canUseViewport: oo && !!window.screen, isInWorker: !oo }, ku = kv, Su;
ku.canUseDOM && (Su = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);
function Sv(e, t) {
  if (!ku.canUseDOM || t && !("addEventListener" in document))
    return !1;
  var n = "on" + e, l = n in document;
  if (!l) {
    var o = document.createElement("div");
    o.setAttribute(n, "return;"), l = typeof o[n] == "function";
  }
  return !l && Su && e === "wheel" && (l = document.implementation.hasFeature("Events.wheel", "3.0")), l;
}
var Ev = Sv, yr = 10, br = 40, Cr = 800;
function Eu(e) {
  var t = 0, n = 0, l = 0, o = 0;
  return "detail" in e && (n = e.detail), "wheelDelta" in e && (n = -e.wheelDelta / 120), "wheelDeltaY" in e && (n = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = n, n = 0), l = t * yr, o = n * yr, "deltaY" in e && (o = e.deltaY), "deltaX" in e && (l = e.deltaX), (l || o) && e.deltaMode && (e.deltaMode == 1 ? (l *= br, o *= br) : (l *= Cr, o *= Cr)), l && !t && (t = l < 1 ? -1 : 1), o && !n && (n = o < 1 ? -1 : 1), { spinX: t, spinY: n, pixelX: l, pixelY: o };
}
Eu.getEventType = function() {
  return wv.firefox() ? "DOMMouseScroll" : Ev("wheel") ? "wheel" : "mousewheel";
};
var $v = Eu;
/**
* Checks if an event is supported in the current execution environment.
*
* NOTE: This will not work correctly for non-generic events such as `change`,
* `reset`, `load`, `error`, and `select`.
*
* Borrows from Modernizr.
*
* @param {string} eventNameSuffix Event name, e.g. "click".
* @param {?boolean} capture Check if the capture phase is supported.
* @return {boolean} True if the event is supported.
* @internal
* @license Modernizr 3.0.0pre (Custom Build) | MIT
*/
const Tv = function(e, t) {
  if (e && e.addEventListener) {
    const n = function(l) {
      const o = $v(l);
      t && Reflect.apply(t, this, [l, o]);
    };
    e.addEventListener("wheel", n, { passive: !0 });
  }
}, Nv = {
  beforeMount(e, t) {
    Tv(e, t.value);
  }
}, Iv = he({
  ...Uf,
  parsedValue: {
    type: j(Array)
  }
}), Mv = ["disabled"], Rv = /* @__PURE__ */ F({
  __name: "panel-time-range",
  props: Iv,
  emits: ["pick", "select-range", "set-picker-option"],
  setup(e, { emit: t }) {
    const n = e, l = (Q, ie) => {
      const Ee = [];
      for (let De = Q; De <= ie; De++)
        Ee.push(De);
      return Ee;
    }, { t: o, lang: a } = ot(), r = se("time"), i = se("picker"), u = Oe("EP_PICKER_BASE"), {
      arrowControl: c,
      disabledHours: p,
      disabledMinutes: d,
      disabledSeconds: f,
      defaultValue: h
    } = u.props, v = k(() => n.parsedValue[0]), m = k(() => n.parsedValue[1]), g = qf(n), w = () => {
      t("pick", g.value, !1);
    }, C = k(() => n.format.includes("ss")), y = k(() => n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : ""), b = (Q = !1) => {
      t("pick", [v.value, m.value], Q);
    }, S = (Q) => {
      I(Q.millisecond(0), m.value);
    }, T = (Q) => {
      I(v.value, Q.millisecond(0));
    }, O = (Q) => {
      const ie = Q.map((De) => Vt(De).locale(a.value)), Ee = L(ie);
      return ie[0].isSame(Ee[0]) && ie[1].isSame(Ee[1]);
    }, I = (Q, ie) => {
      t("pick", [Q, ie], !0);
    }, R = k(() => v.value > m.value), B = N([0, 2]), D = (Q, ie) => {
      t("select-range", Q, ie, "min"), B.value = [Q, ie];
    }, A = k(() => C.value ? 11 : 8), z = (Q, ie) => {
      t("select-range", Q, ie, "max");
      const Ee = s(A);
      B.value = [Q + Ee, ie + Ee];
    }, Z = (Q) => {
      const ie = C.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11], Ee = ["hours", "minutes"].concat(C.value ? ["seconds"] : []), Ve = (ie.indexOf(B.value[0]) + Q + ie.length) % ie.length, Fe = ie.length / 2;
      Ve < Fe ? ee.start_emitSelectRange(Ee[Ve]) : ee.end_emitSelectRange(Ee[Ve - Fe]);
    }, J = (Q) => {
      const ie = Q.code, { left: Ee, right: De, up: Ve, down: Fe } = Ce;
      if ([Ee, De].includes(ie)) {
        Z(ie === Ee ? -1 : 1), Q.preventDefault();
        return;
      }
      if ([Ve, Fe].includes(ie)) {
        const ze = ie === Ve ? -1 : 1, it = B.value[0] < A.value ? "start" : "end";
        ee[`${it}_scrollDown`](ze), Q.preventDefault();
        return;
      }
    }, V = (Q, ie) => {
      const Ee = p ? p(Q) : [], De = Q === "start", Fe = (ie || (De ? m.value : v.value)).hour(), ze = De ? l(Fe + 1, 23) : l(0, Fe - 1);
      return os(Ee, ze);
    }, M = (Q, ie, Ee) => {
      const De = d ? d(Q, ie) : [], Ve = ie === "start", Fe = Ee || (Ve ? m.value : v.value), ze = Fe.hour();
      if (Q !== ze)
        return De;
      const it = Fe.minute(), be = Ve ? l(it + 1, 59) : l(0, it - 1);
      return os(De, be);
    }, P = (Q, ie, Ee, De) => {
      const Ve = f ? f(Q, ie, Ee) : [], Fe = Ee === "start", ze = De || (Fe ? m.value : v.value), it = ze.hour(), be = ze.minute();
      if (Q !== it || ie !== be)
        return Ve;
      const Te = ze.second(), we = Fe ? l(Te + 1, 59) : l(0, Te - 1);
      return os(Ve, we);
    }, L = ([Q, ie]) => [
      pe(Q, "start", !0, ie),
      pe(ie, "end", !1, Q)
    ], { getAvailableHours: U, getAvailableMinutes: oe, getAvailableSeconds: le } = Yf(V, M, P), {
      timePickerOptions: ee,
      getAvailableTime: pe,
      onSetOption: ge
    } = Gf({
      getAvailableHours: U,
      getAvailableMinutes: oe,
      getAvailableSeconds: le
    }), te = (Q) => Q ? Je(Q) ? Q.map((ie) => Vt(ie, n.format).locale(a.value)) : Vt(Q, n.format).locale(a.value) : null, ve = (Q) => Q ? Je(Q) ? Q.map((ie) => ie.format(n.format)) : Q.format(n.format) : null, G = () => {
      if (Je(h))
        return h.map((ie) => Vt(ie).locale(a.value));
      const Q = Vt(h).locale(a.value);
      return [Q, Q.add(60, "m")];
    };
    return t("set-picker-option", ["formatToString", ve]), t("set-picker-option", ["parseUserInput", te]), t("set-picker-option", ["isValidValue", O]), t("set-picker-option", ["handleKeydownInput", J]), t("set-picker-option", ["getDefaultValue", G]), t("set-picker-option", ["getRangeAvailableTime", L]), (Q, ie) => Q.actualVisible ? (E(), _("div", {
      key: 0,
      class: $([s(r).b("range-picker"), s(i).b("panel")])
    }, [
      H("div", {
        class: $(s(r).be("range-picker", "content"))
      }, [
        H("div", {
          class: $(s(r).be("range-picker", "cell"))
        }, [
          H("div", {
            class: $(s(r).be("range-picker", "header"))
          }, ce(s(o)("el.datepicker.startTime")), 3),
          H("div", {
            class: $([
              s(r).be("range-picker", "body"),
              s(r).be("panel", "content"),
              s(r).is("arrow", s(c)),
              { "has-seconds": s(C) }
            ])
          }, [
            x(or, {
              ref: "minSpinner",
              role: "start",
              "show-seconds": s(C),
              "am-pm-mode": s(y),
              "arrow-control": s(c),
              "spinner-date": s(v),
              "disabled-hours": V,
              "disabled-minutes": M,
              "disabled-seconds": P,
              onChange: S,
              onSetOption: s(ge),
              onSelectRange: D
            }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
          ], 2)
        ], 2),
        H("div", {
          class: $(s(r).be("range-picker", "cell"))
        }, [
          H("div", {
            class: $(s(r).be("range-picker", "header"))
          }, ce(s(o)("el.datepicker.endTime")), 3),
          H("div", {
            class: $([
              s(r).be("range-picker", "body"),
              s(r).be("panel", "content"),
              s(r).is("arrow", s(c)),
              { "has-seconds": s(C) }
            ])
          }, [
            x(or, {
              ref: "maxSpinner",
              role: "end",
              "show-seconds": s(C),
              "am-pm-mode": s(y),
              "arrow-control": s(c),
              "spinner-date": s(m),
              "disabled-hours": V,
              "disabled-minutes": M,
              "disabled-seconds": P,
              onChange: T,
              onSetOption: s(ge),
              onSelectRange: z
            }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
          ], 2)
        ], 2)
      ], 2),
      H("div", {
        class: $(s(r).be("panel", "footer"))
      }, [
        H("button", {
          type: "button",
          class: $([s(r).be("panel", "btn"), "cancel"]),
          onClick: ie[0] || (ie[0] = (Ee) => w())
        }, ce(s(o)("el.datepicker.cancel")), 3),
        H("button", {
          type: "button",
          class: $([s(r).be("panel", "btn"), "confirm"]),
          disabled: s(R),
          onClick: ie[1] || (ie[1] = (Ee) => b())
        }, ce(s(o)("el.datepicker.confirm")), 11, Mv)
      ], 2)
    ], 2)) : W("v-if", !0);
  }
});
var Ov = /* @__PURE__ */ de(Rv, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-range.vue"]]);
Vt.extend(Vi);
var Pv = F({
  name: "ElTimePicker",
  install: null,
  props: {
    ...Xf,
    isRange: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, t) {
    const n = N(), [l, o] = e.isRange ? ["timerange", Ov] : ["time", Zf], a = (r) => t.emit("update:modelValue", r);
    return tt("ElPopperOptions", e.popperOptions), t.expose({
      focus: (r) => {
        var i;
        (i = n.value) == null || i.handleFocusInput(r);
      },
      blur: (r) => {
        var i;
        (i = n.value) == null || i.handleBlurInput(r);
      },
      handleOpen: () => {
        var r;
        (r = n.value) == null || r.handleOpen();
      },
      handleClose: () => {
        var r;
        (r = n.value) == null || r.handleClose();
      }
    }), () => {
      var r;
      const i = (r = e.format) != null ? r : Jf;
      return x(Qf, Be(e, {
        ref: n,
        type: l,
        format: i,
        "onUpdate:modelValue": a
      }), {
        default: (u) => x(o, u, null)
      });
    };
  }
});
const ho = Pv;
ho.install = (e) => {
  e.component(ho.name, ho);
};
const Av = ho, _v = (e, t) => {
  const n = e.subtract(1, "month").endOf("month").date();
  return rl(t).map((l, o) => n - (t - o - 1));
}, Lv = (e) => {
  const t = e.daysInMonth();
  return rl(t).map((n, l) => l + 1);
}, Vv = (e) => rl(e.length / 7).map((t) => {
  const n = t * 7;
  return e.slice(n, n + 7);
}), Bv = he({
  selectedDay: {
    type: j(Object)
  },
  range: {
    type: j(Array)
  },
  date: {
    type: j(Object),
    required: !0
  },
  hideHeader: {
    type: Boolean
  }
}), Dv = {
  pick: (e) => Ct(e)
}, xv = (e, t) => {
  Vt.extend(ep);
  const n = Vt.localeData().firstDayOfWeek(), { t: l, lang: o } = ot(), a = Vt().locale(o.value), r = k(() => !!e.range && !!e.range.length), i = k(() => {
    let f = [];
    if (r.value) {
      const [h, v] = e.range, m = rl(v.date() - h.date() + 1).map((C) => ({
        text: h.date() + C,
        type: "current"
      }));
      let g = m.length % 7;
      g = g === 0 ? 0 : 7 - g;
      const w = rl(g).map((C, y) => ({
        text: y + 1,
        type: "next"
      }));
      f = m.concat(w);
    } else {
      const h = e.date.startOf("month").day(), v = _v(e.date, (h - n + 7) % 7).map((C) => ({
        text: C,
        type: "prev"
      })), m = Lv(e.date).map((C) => ({
        text: C,
        type: "current"
      }));
      f = [...v, ...m];
      const g = 7 - (f.length % 7 || 7), w = rl(g).map((C, y) => ({
        text: y + 1,
        type: "next"
      }));
      f = f.concat(w);
    }
    return Vv(f);
  }), u = k(() => {
    const f = n;
    return f === 0 ? ls.map((h) => l(`el.datepicker.weeks.${h}`)) : ls.slice(f).concat(ls.slice(0, f)).map((h) => l(`el.datepicker.weeks.${h}`));
  }), c = (f, h) => {
    switch (h) {
      case "prev":
        return e.date.startOf("month").subtract(1, "month").date(f);
      case "next":
        return e.date.startOf("month").add(1, "month").date(f);
      case "current":
        return e.date.date(f);
    }
  };
  return {
    now: a,
    isInRange: r,
    rows: i,
    weekDays: u,
    getFormattedDate: c,
    handlePickDay: ({ text: f, type: h }) => {
      const v = c(f, h);
      t("pick", v);
    },
    getSlotData: ({ text: f, type: h }) => {
      const v = c(f, h);
      return {
        isSelected: v.isSame(e.selectedDay),
        type: `${h}-month`,
        day: v.format("YYYY-MM-DD"),
        date: v.toDate()
      };
    }
  };
}, Fv = { key: 0 }, Hv = ["onClick"], zv = F({
  name: "DateTable"
}), Kv = /* @__PURE__ */ F({
  ...zv,
  props: Bv,
  emits: Dv,
  setup(e, { expose: t, emit: n }) {
    const l = e, {
      isInRange: o,
      now: a,
      rows: r,
      weekDays: i,
      getFormattedDate: u,
      handlePickDay: c,
      getSlotData: p
    } = xv(l, n), d = se("calendar-table"), f = se("calendar-day"), h = ({ text: v, type: m }) => {
      const g = [m];
      if (m === "current") {
        const w = u(v, m);
        w.isSame(l.selectedDay, "day") && g.push(f.is("selected")), w.isSame(a, "day") && g.push(f.is("today"));
      }
      return g;
    };
    return t({
      getFormattedDate: u
    }), (v, m) => (E(), _("table", {
      class: $([s(d).b(), s(d).is("range", s(o))]),
      cellspacing: "0",
      cellpadding: "0"
    }, [
      v.hideHeader ? W("v-if", !0) : (E(), _("thead", Fv, [
        (E(!0), _(Re, null, Xe(s(i), (g) => (E(), _("th", { key: g }, ce(g), 1))), 128))
      ])),
      H("tbody", null, [
        (E(!0), _(Re, null, Xe(s(r), (g, w) => (E(), _("tr", {
          key: w,
          class: $({
            [s(d).e("row")]: !0,
            [s(d).em("row", "hide-border")]: w === 0 && v.hideHeader
          })
        }, [
          (E(!0), _(Re, null, Xe(g, (C, y) => (E(), _("td", {
            key: y,
            class: $(h(C)),
            onClick: (b) => s(c)(C)
          }, [
            H("div", {
              class: $(s(f).b())
            }, [
              ne(v.$slots, "date-cell", {
                data: s(p)(C)
              }, () => [
                H("span", null, ce(C.text), 1)
              ])
            ], 2)
          ], 10, Hv))), 128))
        ], 2))), 128))
      ])
    ], 2));
  }
});
var wr = /* @__PURE__ */ de(Kv, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/calendar/src/date-table.vue"]]);
const Wv = (e, t) => {
  const n = e.endOf("month"), l = t.startOf("month"), a = n.isSame(l, "week") ? l.add(1, "week") : l;
  return [
    [e, n],
    [a.startOf("week"), t]
  ];
}, jv = (e, t) => {
  const n = e.endOf("month"), l = e.add(1, "month").startOf("month"), o = n.isSame(l, "week") ? l.add(1, "week") : l, a = o.endOf("month"), r = t.startOf("month"), i = a.isSame(r, "week") ? r.add(1, "week") : r;
  return [
    [e, n],
    [o.startOf("week"), a],
    [i.startOf("week"), t]
  ];
}, Uv = (e, t, n) => {
  const l = kn(), { lang: o } = ot(), a = N(), r = Vt().locale(o.value), i = k({
    get() {
      return e.modelValue ? c.value : a.value;
    },
    set(w) {
      if (!w)
        return;
      a.value = w;
      const C = w.toDate();
      t(nn, C), t(et, C);
    }
  }), u = k(() => {
    if (!e.range)
      return [];
    const w = e.range.map((b) => Vt(b).locale(o.value)), [C, y] = w;
    return C.isAfter(y) ? (pt(n, "end time should be greater than start time"), []) : C.isSame(y, "month") ? v(C, y) : C.add(1, "month").month() !== y.month() ? (pt(n, "start time and end time interval must not exceed two months"), []) : v(C, y);
  }), c = k(() => e.modelValue ? Vt(e.modelValue).locale(o.value) : i.value || (u.value.length ? u.value[0][0] : r)), p = k(() => c.value.subtract(1, "month").date(1)), d = k(() => c.value.add(1, "month").date(1)), f = k(() => c.value.subtract(1, "year").date(1)), h = k(() => c.value.add(1, "year").date(1)), v = (w, C) => {
    const y = w.startOf("week"), b = C.endOf("week"), S = y.get("month"), T = b.get("month");
    return S === T ? [[y, b]] : (S + 1) % 12 === T ? Wv(y, b) : S + 2 === T || (S + 1) % 11 === T ? jv(y, b) : (pt(n, "start time and end time interval must not exceed two months"), []);
  }, m = (w) => {
    i.value = w;
  }, g = (w) => {
    const y = {
      "prev-month": p.value,
      "next-month": d.value,
      "prev-year": f.value,
      "next-year": h.value,
      today: r
    }[w];
    y.isSame(c.value, "day") || m(y);
  };
  return Ll({
    from: '"dateCell"',
    replacement: '"date-cell"',
    scope: "ElCalendar",
    version: "2.3.0",
    ref: "https://element-plus.org/en-US/component/calendar.html#slots",
    type: "Slot"
  }, k(() => !!l.dateCell)), {
    calculateValidatedDateRange: v,
    date: c,
    realSelectedDay: i,
    pickDay: m,
    selectDate: g,
    validatedRange: u
  };
}, qv = (e) => Je(e) && e.length === 2 && e.every((t) => ms(t)), Gv = he({
  modelValue: {
    type: Date
  },
  range: {
    type: j(Array),
    validator: qv
  }
}), Yv = {
  [et]: (e) => ms(e),
  [nn]: (e) => ms(e)
}, $u = "ElCalendar", Xv = F({
  name: $u
}), Zv = /* @__PURE__ */ F({
  ...Xv,
  props: Gv,
  emits: Yv,
  setup(e, { expose: t, emit: n }) {
    const l = e, o = se("calendar"), {
      calculateValidatedDateRange: a,
      date: r,
      pickDay: i,
      realSelectedDay: u,
      selectDate: c,
      validatedRange: p
    } = Uv(l, n, $u), { t: d } = ot(), f = k(() => {
      const h = `el.datepicker.month${r.value.format("M")}`;
      return `${r.value.year()} ${d("el.datepicker.year")} ${d(h)}`;
    });
    return t({
      selectedDay: u,
      pickDay: i,
      selectDate: c,
      calculateValidatedDateRange: a
    }), (h, v) => (E(), _("div", {
      class: $(s(o).b())
    }, [
      H("div", {
        class: $(s(o).e("header"))
      }, [
        ne(h.$slots, "header", { date: s(f) }, () => [
          H("div", {
            class: $(s(o).e("title"))
          }, ce(s(f)), 3),
          s(p).length === 0 ? (E(), _("div", {
            key: 0,
            class: $(s(o).e("button-group"))
          }, [
            x(s(Li), null, {
              default: K(() => [
                x(s(Kt), {
                  size: "small",
                  onClick: v[0] || (v[0] = (m) => s(c)("prev-month"))
                }, {
                  default: K(() => [
                    st(ce(s(d)("el.datepicker.prevMonth")), 1)
                  ]),
                  _: 1
                }),
                x(s(Kt), {
                  size: "small",
                  onClick: v[1] || (v[1] = (m) => s(c)("today"))
                }, {
                  default: K(() => [
                    st(ce(s(d)("el.datepicker.today")), 1)
                  ]),
                  _: 1
                }),
                x(s(Kt), {
                  size: "small",
                  onClick: v[2] || (v[2] = (m) => s(c)("next-month"))
                }, {
                  default: K(() => [
                    st(ce(s(d)("el.datepicker.nextMonth")), 1)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ], 2)) : W("v-if", !0)
        ])
      ], 2),
      s(p).length === 0 ? (E(), _("div", {
        key: 0,
        class: $(s(o).e("body"))
      }, [
        x(wr, {
          date: s(r),
          "selected-day": s(u),
          onPick: s(i)
        }, Yn({ _: 2 }, [
          h.$slots["date-cell"] || h.$slots.dateCell ? {
            name: "date-cell",
            fn: K((m) => [
              h.$slots["date-cell"] ? ne(h.$slots, "date-cell", Zt(Be({ key: 0 }, m))) : ne(h.$slots, "dateCell", Zt(Be({ key: 1 }, m)))
            ])
          } : void 0
        ]), 1032, ["date", "selected-day", "onPick"])
      ], 2)) : (E(), _("div", {
        key: 1,
        class: $(s(o).e("body"))
      }, [
        (E(!0), _(Re, null, Xe(s(p), (m, g) => (E(), q(wr, {
          key: g,
          date: m[0],
          "selected-day": s(u),
          range: m,
          "hide-header": g !== 0,
          onPick: s(i)
        }, Yn({ _: 2 }, [
          h.$slots["date-cell"] || h.$slots.dateCell ? {
            name: "date-cell",
            fn: K((w) => [
              h.$slots["date-cell"] ? ne(h.$slots, "date-cell", Zt(Be({ key: 0 }, w))) : ne(h.$slots, "dateCell", Zt(Be({ key: 1 }, w)))
            ])
          } : void 0
        ]), 1032, ["date", "selected-day", "range", "hide-header", "onPick"]))), 128))
      ], 2))
    ], 2));
  }
});
var Jv = /* @__PURE__ */ de(Zv, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/calendar/src/calendar.vue"]]);
const Qv = xe(Jv), em = he({
  initialIndex: {
    type: Number,
    default: 0
  },
  height: {
    type: String,
    default: ""
  },
  trigger: {
    type: String,
    values: ["hover", "click"],
    default: "hover"
  },
  autoplay: {
    type: Boolean,
    default: !0
  },
  interval: {
    type: Number,
    default: 3e3
  },
  indicatorPosition: {
    type: String,
    values: ["", "none", "outside"],
    default: ""
  },
  arrow: {
    type: String,
    values: ["always", "hover", "never"],
    default: "hover"
  },
  type: {
    type: String,
    values: ["", "card"],
    default: ""
  },
  loop: {
    type: Boolean,
    default: !0
  },
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  pauseOnHover: {
    type: Boolean,
    default: !0
  }
}), tm = {
  change: (e, t) => [e, t].every(Pe)
}, Tu = Symbol("carouselContextKey"), kr = 300, nm = (e, t, n) => {
  const {
    children: l,
    addChild: o,
    removeChild: a
  } = pd(je(), "ElCarouselItem"), r = N(-1), i = N(null), u = N(!1), c = N(), p = k(() => e.arrow !== "never" && !s(h)), d = k(() => l.value.some((V) => V.props.label.toString().length > 0)), f = k(() => e.type === "card"), h = k(() => e.direction === "vertical"), v = Wn((V) => {
    y(V);
  }, kr, { trailing: !0 }), m = Wn((V) => {
    D(V);
  }, kr);
  function g() {
    i.value && (clearInterval(i.value), i.value = null);
  }
  function w() {
    e.interval <= 0 || !e.autoplay || i.value || (i.value = setInterval(() => C(), e.interval));
  }
  const C = () => {
    r.value < l.value.length - 1 ? r.value = r.value + 1 : e.loop && (r.value = 0);
  };
  function y(V) {
    if (Ue(V)) {
      const L = l.value.filter((U) => U.props.name === V);
      L.length > 0 && (V = l.value.indexOf(L[0]));
    }
    if (V = Number(V), Number.isNaN(V) || V !== Math.floor(V)) {
      pt(n, "index must be integer.");
      return;
    }
    const M = l.value.length, P = r.value;
    V < 0 ? r.value = e.loop ? M - 1 : 0 : V >= M ? r.value = e.loop ? 0 : M - 1 : r.value = V, P === r.value && b(P), Z();
  }
  function b(V) {
    l.value.forEach((M, P) => {
      M.translateItem(P, r.value, V);
    });
  }
  function S(V, M) {
    var P, L, U, oe;
    const le = s(l), ee = le.length;
    if (ee === 0 || !V.states.inStage)
      return !1;
    const pe = M + 1, ge = M - 1, te = ee - 1, ve = le[te].states.active, G = le[0].states.active, Q = (L = (P = le[pe]) == null ? void 0 : P.states) == null ? void 0 : L.active, ie = (oe = (U = le[ge]) == null ? void 0 : U.states) == null ? void 0 : oe.active;
    return M === te && G || Q ? "left" : M === 0 && ve || ie ? "right" : !1;
  }
  function T() {
    u.value = !0, e.pauseOnHover && g();
  }
  function O() {
    u.value = !1, w();
  }
  function I(V) {
    s(h) || l.value.forEach((M, P) => {
      V === S(M, P) && (M.states.hover = !0);
    });
  }
  function R() {
    s(h) || l.value.forEach((V) => {
      V.states.hover = !1;
    });
  }
  function B(V) {
    r.value = V;
  }
  function D(V) {
    e.trigger === "hover" && V !== r.value && (r.value = V);
  }
  function A() {
    y(r.value - 1);
  }
  function z() {
    y(r.value + 1);
  }
  function Z() {
    g(), w();
  }
  ue(() => r.value, (V, M) => {
    b(M), M > -1 && t("change", V, M);
  }), ue(() => e.autoplay, (V) => {
    V ? w() : g();
  }), ue(() => e.loop, () => {
    y(r.value);
  }), ue(() => e.interval, () => {
    Z();
  }), ue(() => l.value, () => {
    l.value.length > 0 && y(e.initialIndex);
  });
  const J = ht();
  return We(() => {
    J.value = Mn(c.value, () => {
      b();
    }), w();
  }), Dt(() => {
    g(), c.value && J.value && J.value.stop();
  }), tt(Tu, {
    root: c,
    isCardType: f,
    isVertical: h,
    items: l,
    loop: e.loop,
    addItem: o,
    removeItem: a,
    setActiveItem: y
  }), {
    root: c,
    activeIndex: r,
    arrowDisplay: p,
    hasLabel: d,
    hover: u,
    isCardType: f,
    items: l,
    handleButtonEnter: I,
    handleButtonLeave: R,
    handleIndicatorClick: B,
    handleMouseEnter: T,
    handleMouseLeave: O,
    setActiveItem: y,
    prev: A,
    next: z,
    throttledArrowClick: v,
    throttledIndicatorHover: m
  };
}, lm = ["onMouseenter", "onClick"], om = { key: 0 }, Nu = "ElCarousel", sm = F({
  name: Nu
}), am = /* @__PURE__ */ F({
  ...sm,
  props: em,
  emits: tm,
  setup(e, { expose: t, emit: n }) {
    const l = e, {
      root: o,
      activeIndex: a,
      arrowDisplay: r,
      hasLabel: i,
      hover: u,
      isCardType: c,
      items: p,
      handleButtonEnter: d,
      handleButtonLeave: f,
      handleIndicatorClick: h,
      handleMouseEnter: v,
      handleMouseLeave: m,
      setActiveItem: g,
      prev: w,
      next: C,
      throttledArrowClick: y,
      throttledIndicatorHover: b
    } = nm(l, n, Nu), S = se("carousel"), T = k(() => {
      const I = [S.b(), S.m(l.direction)];
      return s(c) && I.push(S.m("card")), I;
    }), O = k(() => {
      const I = [S.e("indicators"), S.em("indicators", l.direction)];
      return s(i) && I.push(S.em("indicators", "labels")), (l.indicatorPosition === "outside" || s(c)) && I.push(S.em("indicators", "outside")), I;
    });
    return t({
      setActiveItem: g,
      prev: w,
      next: C
    }), (I, R) => (E(), _("div", {
      ref_key: "root",
      ref: o,
      class: $(s(T)),
      onMouseenter: R[6] || (R[6] = Ae((...B) => s(v) && s(v)(...B), ["stop"])),
      onMouseleave: R[7] || (R[7] = Ae((...B) => s(m) && s(m)(...B), ["stop"]))
    }, [
      H("div", {
        class: $(s(S).e("container")),
        style: ye({ height: I.height })
      }, [
        s(r) ? (E(), q(jt, {
          key: 0,
          name: "carousel-arrow-left",
          persisted: ""
        }, {
          default: K(() => [
            qe(H("button", {
              type: "button",
              class: $([s(S).e("arrow"), s(S).em("arrow", "left")]),
              onMouseenter: R[0] || (R[0] = (B) => s(d)("left")),
              onMouseleave: R[1] || (R[1] = (...B) => s(f) && s(f)(...B)),
              onClick: R[2] || (R[2] = Ae((B) => s(y)(s(a) - 1), ["stop"]))
            }, [
              x(s(Se), null, {
                default: K(() => [
                  x(s(zo))
                ]),
                _: 1
              })
            ], 34), [
              [
                at,
                (I.arrow === "always" || s(u)) && (l.loop || s(a) > 0)
              ]
            ])
          ]),
          _: 1
        })) : W("v-if", !0),
        s(r) ? (E(), q(jt, {
          key: 1,
          name: "carousel-arrow-right",
          persisted: ""
        }, {
          default: K(() => [
            qe(H("button", {
              type: "button",
              class: $([s(S).e("arrow"), s(S).em("arrow", "right")]),
              onMouseenter: R[3] || (R[3] = (B) => s(d)("right")),
              onMouseleave: R[4] || (R[4] = (...B) => s(f) && s(f)(...B)),
              onClick: R[5] || (R[5] = Ae((B) => s(y)(s(a) + 1), ["stop"]))
            }, [
              x(s(Se), null, {
                default: K(() => [
                  x(s(wn))
                ]),
                _: 1
              })
            ], 34), [
              [
                at,
                (I.arrow === "always" || s(u)) && (l.loop || s(a) < s(p).length - 1)
              ]
            ])
          ]),
          _: 1
        })) : W("v-if", !0),
        ne(I.$slots, "default")
      ], 6),
      I.indicatorPosition !== "none" ? (E(), _("ul", {
        key: 0,
        class: $(s(O))
      }, [
        (E(!0), _(Re, null, Xe(s(p), (B, D) => (E(), _("li", {
          key: D,
          class: $([
            s(S).e("indicator"),
            s(S).em("indicator", I.direction),
            s(S).is("active", D === s(a))
          ]),
          onMouseenter: (A) => s(b)(D),
          onClick: Ae((A) => s(h)(D), ["stop"])
        }, [
          H("button", {
            class: $(s(S).e("button"))
          }, [
            s(i) ? (E(), _("span", om, ce(B.props.label), 1)) : W("v-if", !0)
          ], 2)
        ], 42, lm))), 128))
      ], 2)) : W("v-if", !0)
    ], 34));
  }
});
var rm = /* @__PURE__ */ de(am, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/carousel/src/carousel.vue"]]);
const im = he({
  name: { type: String, default: "" },
  label: {
    type: [String, Number],
    default: ""
  }
}), um = (e, t) => {
  const n = Oe(Tu), l = je();
  n || pt(t, "usage: <el-carousel></el-carousel-item></el-carousel>"), l || pt(t, "compositional hook can only be invoked inside setups");
  const o = 0.83, a = N(!1), r = N(0), i = N(1), u = N(!1), c = N(!1), p = N(!1), d = N(!1), { isCardType: f, isVertical: h } = n;
  function v(y, b, S) {
    const T = S - 1, O = b - 1, I = b + 1, R = S / 2;
    return b === 0 && y === T ? -1 : b === T && y === 0 ? S : y < O && b - y >= R ? S + 1 : y > I && y - b >= R ? -2 : y;
  }
  function m(y, b) {
    var S;
    const T = ((S = n.root.value) == null ? void 0 : S.offsetWidth) || 0;
    return p.value ? T * ((2 - o) * (y - b) + 1) / 4 : y < b ? -(1 + o) * T / 4 : (3 + o) * T / 4;
  }
  function g(y, b, S) {
    const T = n.root.value;
    return T ? ((S ? T.offsetHeight : T.offsetWidth) || 0) * (y - b) : 0;
  }
  const w = (y, b, S) => {
    var T;
    const O = s(f), I = (T = n.items.value.length) != null ? T : Number.NaN, R = y === b;
    !O && !qn(S) && (d.value = R || y === S), !R && I > 2 && n.loop && (y = v(y, b, I));
    const B = s(h);
    u.value = R, O ? (B && pt("Carousel", "vertical direction is not supported for card mode"), p.value = Math.round(Math.abs(y - b)) <= 1, r.value = m(y, b), i.value = s(u) ? 1 : o) : r.value = g(y, b, B), c.value = !0;
  };
  function C() {
    if (n && s(f)) {
      const y = n.items.value.findIndex(({ uid: b }) => b === l.uid);
      n.setActiveItem(y);
    }
  }
  return We(() => {
    n.addItem({
      props: e,
      states: ct({
        hover: a,
        translate: r,
        scale: i,
        active: u,
        ready: c,
        inStage: p,
        animating: d
      }),
      uid: l.uid,
      translateItem: w
    });
  }), Jl(() => {
    n.removeItem(l.uid);
  }), {
    active: u,
    animating: d,
    hover: a,
    inStage: p,
    isVertical: h,
    translate: r,
    isCardType: f,
    scale: i,
    ready: c,
    handleItemClick: C
  };
}, cm = "ElCarouselItem", dm = F({
  name: "ElCarouselItem"
}), fm = /* @__PURE__ */ F({
  ...dm,
  props: im,
  setup(e) {
    const t = e, n = se("carousel"), {
      active: l,
      animating: o,
      hover: a,
      inStage: r,
      isVertical: i,
      translate: u,
      isCardType: c,
      scale: p,
      ready: d,
      handleItemClick: f
    } = um(t, cm), h = k(() => {
      const m = `${`translate${s(i) ? "Y" : "X"}`}(${s(u)}px)`, g = `scale(${s(p)})`;
      return {
        transform: [m, g].join(" ")
      };
    });
    return (v, m) => qe((E(), _("div", {
      class: $([
        s(n).e("item"),
        s(n).is("active", s(l)),
        s(n).is("in-stage", s(r)),
        s(n).is("hover", s(a)),
        s(n).is("animating", s(o)),
        { [s(n).em("item", "card")]: s(c) }
      ]),
      style: ye(s(h)),
      onClick: m[0] || (m[0] = (...g) => s(f) && s(f)(...g))
    }, [
      s(c) ? qe((E(), _("div", {
        key: 0,
        class: $(s(n).e("mask"))
      }, null, 2)), [
        [at, !s(l)]
      ]) : W("v-if", !0),
      ne(v.$slots, "default")
    ], 6)), [
      [at, s(d)]
    ]);
  }
});
var Iu = /* @__PURE__ */ de(fm, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/carousel/src/carousel-item.vue"]]);
const pm = xe(rm, {
  CarouselItem: Iu
}), hm = Rt(Iu);
var vm = F({
  name: "NodeContent",
  setup() {
    return {
      ns: se("cascader-node")
    };
  },
  render() {
    const { ns: e } = this, { node: t, panel: n } = this.$parent, { data: l, label: o } = t, { renderLabelFn: a } = n;
    return fe("span", { class: e.e("label") }, a ? a({ node: t, data: l }) : o);
  }
});
const Sa = Symbol(), mm = F({
  name: "ElCascaderNode",
  components: {
    ElCheckbox: Yt,
    ElRadio: Di,
    NodeContent: vm,
    ElIcon: Se,
    Check: Xl,
    Loading: wl,
    ArrowRight: wn
  },
  props: {
    node: {
      type: Object,
      required: !0
    },
    menuId: String
  },
  emits: ["expand"],
  setup(e, { emit: t }) {
    const n = Oe(Sa), l = se("cascader-node"), o = k(() => n.isHoverMenu), a = k(() => n.config.multiple), r = k(() => n.config.checkStrictly), i = k(() => {
      var T;
      return (T = n.checkedNodes[0]) == null ? void 0 : T.uid;
    }), u = k(() => e.node.isDisabled), c = k(() => e.node.isLeaf), p = k(() => r.value && !c.value || !u.value), d = k(() => h(n.expandingNode)), f = k(() => r.value && n.checkedNodes.some(h)), h = (T) => {
      var O;
      const { level: I, uid: R } = e.node;
      return ((O = T == null ? void 0 : T.pathNodes[I - 1]) == null ? void 0 : O.uid) === R;
    }, v = () => {
      d.value || n.expandNode(e.node);
    }, m = (T) => {
      const { node: O } = e;
      T !== O.checked && n.handleCheckChange(O, T);
    }, g = () => {
      n.lazyLoad(e.node, () => {
        c.value || v();
      });
    }, w = (T) => {
      !o.value || (C(), !c.value && t("expand", T));
    }, C = () => {
      const { node: T } = e;
      !p.value || T.loading || (T.loaded ? v() : g());
    }, y = () => {
      o.value && !c.value || (c.value && !u.value && !r.value && !a.value ? S(!0) : C());
    }, b = (T) => {
      r.value ? (m(T), e.node.loaded && v()) : S(T);
    }, S = (T) => {
      e.node.loaded ? (m(T), !r.value && v()) : g();
    };
    return {
      panel: n,
      isHoverMenu: o,
      multiple: a,
      checkStrictly: r,
      checkedNodeId: i,
      isDisabled: u,
      isLeaf: c,
      expandable: p,
      inExpandingPath: d,
      inCheckedPath: f,
      ns: l,
      handleHoverExpand: w,
      handleExpand: C,
      handleClick: y,
      handleCheck: S,
      handleSelectCheck: b
    };
  }
}), gm = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"], ym = /* @__PURE__ */ H("span", null, null, -1);
function bm(e, t, n, l, o, a) {
  const r = $e("el-checkbox"), i = $e("el-radio"), u = $e("check"), c = $e("el-icon"), p = $e("node-content"), d = $e("loading"), f = $e("arrow-right");
  return E(), _("li", {
    id: `${e.menuId}-${e.node.uid}`,
    role: "menuitem",
    "aria-haspopup": !e.isLeaf,
    "aria-owns": e.isLeaf ? null : e.menuId,
    "aria-expanded": e.inExpandingPath,
    tabindex: e.expandable ? -1 : void 0,
    class: $([
      e.ns.b(),
      e.ns.is("selectable", e.checkStrictly),
      e.ns.is("active", e.node.checked),
      e.ns.is("disabled", !e.expandable),
      e.inExpandingPath && "in-active-path",
      e.inCheckedPath && "in-checked-path"
    ]),
    onMouseenter: t[2] || (t[2] = (...h) => e.handleHoverExpand && e.handleHoverExpand(...h)),
    onFocus: t[3] || (t[3] = (...h) => e.handleHoverExpand && e.handleHoverExpand(...h)),
    onClick: t[4] || (t[4] = (...h) => e.handleClick && e.handleClick(...h))
  }, [
    W(" prefix "),
    e.multiple ? (E(), q(r, {
      key: 0,
      "model-value": e.node.checked,
      indeterminate: e.node.indeterminate,
      disabled: e.isDisabled,
      onClick: t[0] || (t[0] = Ae(() => {
      }, ["stop"])),
      "onUpdate:modelValue": e.handleSelectCheck
    }, null, 8, ["model-value", "indeterminate", "disabled", "onUpdate:modelValue"])) : e.checkStrictly ? (E(), q(i, {
      key: 1,
      "model-value": e.checkedNodeId,
      label: e.node.uid,
      disabled: e.isDisabled,
      "onUpdate:modelValue": e.handleSelectCheck,
      onClick: t[1] || (t[1] = Ae(() => {
      }, ["stop"]))
    }, {
      default: K(() => [
        W(`
        Add an empty element to avoid render label,
        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485
      `),
        ym
      ]),
      _: 1
    }, 8, ["model-value", "label", "disabled", "onUpdate:modelValue"])) : e.isLeaf && e.node.checked ? (E(), q(c, {
      key: 2,
      class: $(e.ns.e("prefix"))
    }, {
      default: K(() => [
        x(u)
      ]),
      _: 1
    }, 8, ["class"])) : W("v-if", !0),
    W(" content "),
    x(p),
    W(" postfix "),
    e.isLeaf ? W("v-if", !0) : (E(), _(Re, { key: 3 }, [
      e.node.loading ? (E(), q(c, {
        key: 0,
        class: $([e.ns.is("loading"), e.ns.e("postfix")])
      }, {
        default: K(() => [
          x(d)
        ]),
        _: 1
      }, 8, ["class"])) : (E(), q(c, {
        key: 1,
        class: $(["arrow-right", e.ns.e("postfix")])
      }, {
        default: K(() => [
          x(f)
        ]),
        _: 1
      }, 8, ["class"]))
    ], 64))
  ], 42, gm);
}
var Cm = /* @__PURE__ */ de(mm, [["render", bm], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/node.vue"]]);
const wm = F({
  name: "ElCascaderMenu",
  components: {
    Loading: wl,
    ElIcon: Se,
    ElScrollbar: Zn,
    ElCascaderNode: Cm
  },
  props: {
    nodes: {
      type: Array,
      required: !0
    },
    index: {
      type: Number,
      required: !0
    }
  },
  setup(e) {
    const t = je(), n = se("cascader-menu"), { t: l } = ot(), o = mi();
    let a = null, r = null;
    const i = Oe(Sa), u = N(null), c = k(() => !e.nodes.length), p = k(() => !i.initialLoaded), d = k(() => `cascader-menu-${o}-${e.index}`), f = (g) => {
      a = g.target;
    }, h = (g) => {
      if (!(!i.isHoverMenu || !a || !u.value))
        if (a.contains(g.target)) {
          v();
          const w = t.vnode.el, { left: C } = w.getBoundingClientRect(), { offsetWidth: y, offsetHeight: b } = w, S = g.clientX - C, T = a.offsetTop, O = T + a.offsetHeight;
          u.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${S} ${T} L${y} 0 V${T} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${S} ${O} L${y} ${b} V${O} Z" />
        `;
        } else
          r || (r = window.setTimeout(m, i.config.hoverThreshold));
    }, v = () => {
      !r || (clearTimeout(r), r = null);
    }, m = () => {
      !u.value || (u.value.innerHTML = "", v());
    };
    return {
      ns: n,
      panel: i,
      hoverZone: u,
      isEmpty: c,
      isLoading: p,
      menuId: d,
      t: l,
      handleExpand: f,
      handleMouseMove: h,
      clearHoverZone: m
    };
  }
});
function km(e, t, n, l, o, a) {
  const r = $e("el-cascader-node"), i = $e("loading"), u = $e("el-icon"), c = $e("el-scrollbar");
  return E(), q(c, {
    key: e.menuId,
    tag: "ul",
    role: "menu",
    class: $(e.ns.b()),
    "wrap-class": e.ns.e("wrap"),
    "view-class": [e.ns.e("list"), e.ns.is("empty", e.isEmpty)],
    onMousemove: e.handleMouseMove,
    onMouseleave: e.clearHoverZone
  }, {
    default: K(() => {
      var p;
      return [
        (E(!0), _(Re, null, Xe(e.nodes, (d) => (E(), q(r, {
          key: d.uid,
          node: d,
          "menu-id": e.menuId,
          onExpand: e.handleExpand
        }, null, 8, ["node", "menu-id", "onExpand"]))), 128)),
        e.isLoading ? (E(), _("div", {
          key: 0,
          class: $(e.ns.e("empty-text"))
        }, [
          x(u, {
            size: "14",
            class: $(e.ns.is("loading"))
          }, {
            default: K(() => [
              x(i)
            ]),
            _: 1
          }, 8, ["class"]),
          st(" " + ce(e.t("el.cascader.loading")), 1)
        ], 2)) : e.isEmpty ? (E(), _("div", {
          key: 1,
          class: $(e.ns.e("empty-text"))
        }, ce(e.t("el.cascader.noData")), 3)) : (p = e.panel) != null && p.isHoverMenu ? (E(), _("svg", {
          key: 2,
          ref: "hoverZone",
          class: $(e.ns.e("hover-zone"))
        }, null, 2)) : W("v-if", !0)
      ];
    }),
    _: 1
  }, 8, ["class", "wrap-class", "view-class", "onMousemove", "onMouseleave"]);
}
var Sm = /* @__PURE__ */ de(wm, [["render", km], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/menu.vue"]]);
let Em = 0;
const $m = (e) => {
  const t = [e];
  let { parent: n } = e;
  for (; n; )
    t.unshift(n), n = n.parent;
  return t;
};
class ml {
  constructor(t, n, l, o = !1) {
    this.data = t, this.config = n, this.parent = l, this.root = o, this.uid = Em++, this.checked = !1, this.indeterminate = !1, this.loading = !1;
    const { value: a, label: r, children: i } = n, u = t[i], c = $m(this);
    this.level = o ? 0 : l ? l.level + 1 : 1, this.value = t[a], this.label = t[r], this.pathNodes = c, this.pathValues = c.map((p) => p.value), this.pathLabels = c.map((p) => p.label), this.childrenData = u, this.children = (u || []).map((p) => new ml(p, n, this)), this.loaded = !n.lazy || this.isLeaf || !an(u);
  }
  get isDisabled() {
    const { data: t, parent: n, config: l } = this, { disabled: o, checkStrictly: a } = l;
    return (mt(o) ? o(t, this) : !!t[o]) || !a && (n == null ? void 0 : n.isDisabled);
  }
  get isLeaf() {
    const { data: t, config: n, childrenData: l, loaded: o } = this, { lazy: a, leaf: r } = n, i = mt(r) ? r(t, this) : t[r];
    return qn(i) ? a && !o ? !1 : !(Array.isArray(l) && l.length) : !!i;
  }
  get valueByOption() {
    return this.config.emitPath ? this.pathValues : this.value;
  }
  appendChild(t) {
    const { childrenData: n, children: l } = this, o = new ml(t, this.config, this);
    return Array.isArray(n) ? n.push(t) : this.childrenData = [t], l.push(o), o;
  }
  calcText(t, n) {
    const l = t ? this.pathLabels.join(n) : this.label;
    return this.text = l, l;
  }
  broadcast(t, ...n) {
    const l = `onParent${Ja(t)}`;
    this.children.forEach((o) => {
      o && (o.broadcast(t, ...n), o[l] && o[l](...n));
    });
  }
  emit(t, ...n) {
    const { parent: l } = this, o = `onChild${Ja(t)}`;
    l && (l[o] && l[o](...n), l.emit(t, ...n));
  }
  onParentCheck(t) {
    this.isDisabled || this.setCheckState(t);
  }
  onChildCheck() {
    const { children: t } = this, n = t.filter((o) => !o.isDisabled), l = n.length ? n.every((o) => o.checked) : !1;
    this.setCheckState(l);
  }
  setCheckState(t) {
    const n = this.children.length, l = this.children.reduce((o, a) => {
      const r = a.checked ? 1 : a.indeterminate ? 0.5 : 0;
      return o + r;
    }, 0);
    this.checked = this.loaded && this.children.filter((o) => !o.isDisabled).every((o) => o.loaded && o.checked) && t, this.indeterminate = this.loaded && l !== n && l > 0;
  }
  doCheck(t) {
    if (this.checked === t)
      return;
    const { checkStrictly: n, multiple: l } = this.config;
    n || !l ? this.checked = t : (this.broadcast("check", t), this.setCheckState(t), this.emit("check"));
  }
}
const As = (e, t) => e.reduce((n, l) => (l.isLeaf ? n.push(l) : (!t && n.push(l), n = n.concat(As(l.children, t))), n), []);
class Sr {
  constructor(t, n) {
    this.config = n;
    const l = (t || []).map((o) => new ml(o, this.config));
    this.nodes = l, this.allNodes = As(l, !1), this.leafNodes = As(l, !0);
  }
  getNodes() {
    return this.nodes;
  }
  getFlattedNodes(t) {
    return t ? this.leafNodes : this.allNodes;
  }
  appendNode(t, n) {
    const l = n ? n.appendChild(t) : new ml(t, this.config);
    n || this.nodes.push(l), this.allNodes.push(l), l.isLeaf && this.leafNodes.push(l);
  }
  appendNodes(t, n) {
    t.forEach((l) => this.appendNode(l, n));
  }
  getNodeByValue(t, n = !1) {
    return !t && t !== 0 ? null : this.getFlattedNodes(n).find((o) => bn(o.value, t) || bn(o.pathValues, t)) || null;
  }
  getSameNode(t) {
    return t && this.getFlattedNodes(!1).find(({ value: l, level: o }) => bn(t.value, l) && t.level === o) || null;
  }
}
const Mu = he({
  modelValue: {
    type: j([Number, String, Array])
  },
  options: {
    type: j(Array),
    default: () => []
  },
  props: {
    type: j(Object),
    default: () => ({})
  }
}), Tm = {
  expandTrigger: "click",
  multiple: !1,
  checkStrictly: !1,
  emitPath: !0,
  lazy: !1,
  lazyLoad: bt,
  value: "value",
  label: "label",
  children: "children",
  leaf: "leaf",
  disabled: "disabled",
  hoverThreshold: 500
}, Nm = (e) => k(() => ({
  ...Tm,
  ...e.props
})), Er = (e) => {
  if (!e)
    return 0;
  const t = e.id.split("-");
  return Number(t[t.length - 2]);
}, Im = (e) => {
  if (!e)
    return;
  const t = e.querySelector("input");
  t ? t.click() : Hi(e) && e.click();
}, Mm = (e, t) => {
  const n = t.slice(0), l = n.map((a) => a.uid), o = e.reduce((a, r) => {
    const i = l.indexOf(r.uid);
    return i > -1 && (a.push(r), n.splice(i, 1), l.splice(i, 1)), a;
  }, []);
  return o.push(...n), o;
}, Rm = F({
  name: "ElCascaderPanel",
  components: {
    ElCascaderMenu: Sm
  },
  props: {
    ...Mu,
    border: {
      type: Boolean,
      default: !0
    },
    renderLabel: Function
  },
  emits: [et, vt, "close", "expand-change"],
  setup(e, { emit: t, slots: n }) {
    let l = !1;
    const o = se("cascader"), a = Nm(e);
    let r = null;
    const i = N(!0), u = N([]), c = N(null), p = N([]), d = N(null), f = N([]), h = k(() => a.value.expandTrigger === "hover"), v = k(() => e.renderLabel || n.default), m = () => {
      const { options: A } = e, z = a.value;
      l = !1, r = new Sr(A, z), p.value = [r.getNodes()], z.lazy && an(e.options) ? (i.value = !1, g(void 0, (Z) => {
        Z && (r = new Sr(Z, z), p.value = [r.getNodes()]), i.value = !0, I(!1, !0);
      })) : I(!1, !0);
    }, g = (A, z) => {
      const Z = a.value;
      A = A || new ml({}, Z, void 0, !0), A.loading = !0;
      const J = (V) => {
        const M = A, P = M.root ? null : M;
        V && (r == null || r.appendNodes(V, P)), M.loading = !1, M.loaded = !0, M.childrenData = M.childrenData || [], z && z(V);
      };
      Z.lazyLoad(A, J);
    }, w = (A, z) => {
      var Z;
      const { level: J } = A, V = p.value.slice(0, J);
      let M;
      A.isLeaf ? M = A.pathNodes[J - 2] : (M = A, V.push(A.children)), ((Z = d.value) == null ? void 0 : Z.uid) !== (M == null ? void 0 : M.uid) && (d.value = A, p.value = V, !z && t("expand-change", (A == null ? void 0 : A.pathValues) || []));
    }, C = (A, z, Z = !0) => {
      const { checkStrictly: J, multiple: V } = a.value, M = f.value[0];
      l = !0, !V && (M == null || M.doCheck(!1)), A.doCheck(z), O(), Z && !V && !J && t("close"), !Z && !V && !J && y(A);
    }, y = (A) => {
      !A || (A = A.parent, y(A), A && w(A));
    }, b = (A) => r == null ? void 0 : r.getFlattedNodes(A), S = (A) => {
      var z;
      return (z = b(A)) == null ? void 0 : z.filter((Z) => Z.checked !== !1);
    }, T = () => {
      f.value.forEach((A) => A.doCheck(!1)), O(), p.value = p.value.slice(0, 1), d.value = null, t("expand-change", []);
    }, O = () => {
      var A;
      const { checkStrictly: z, multiple: Z } = a.value, J = f.value, V = S(!z), M = Mm(J, V), P = M.map((L) => L.valueByOption);
      f.value = M, c.value = Z ? P : (A = P[0]) != null ? A : null;
    }, I = (A = !1, z = !1) => {
      const { modelValue: Z } = e, { lazy: J, multiple: V, checkStrictly: M } = a.value, P = !M;
      if (!(!i.value || l || !z && bn(Z, c.value)))
        if (J && !A) {
          const U = sr(Ap(ar(Z))).map((oe) => r == null ? void 0 : r.getNodeByValue(oe)).filter((oe) => !!oe && !oe.loaded && !oe.loading);
          U.length ? U.forEach((oe) => {
            g(oe, () => I(!1, z));
          }) : I(!0, z);
        } else {
          const L = V ? ar(Z) : [Z], U = sr(L.map((oe) => r == null ? void 0 : r.getNodeByValue(oe, P)));
          R(U, z), c.value = va(Z);
        }
    }, R = (A, z = !0) => {
      const { checkStrictly: Z } = a.value, J = f.value, V = A.filter((L) => !!L && (Z || L.isLeaf)), M = r == null ? void 0 : r.getSameNode(d.value), P = z && M || V[0];
      P ? P.pathNodes.forEach((L) => w(L, !0)) : d.value = null, J.forEach((L) => L.doCheck(!1)), V.forEach((L) => L.doCheck(!0)), f.value = V, Ne(B);
    }, B = () => {
      !rt || u.value.forEach((A) => {
        const z = A == null ? void 0 : A.$el;
        if (z) {
          const Z = z.querySelector(`.${o.namespace.value}-scrollbar__wrap`), J = z.querySelector(`.${o.b("node")}.${o.is("active")}`) || z.querySelector(`.${o.b("node")}.in-active-path`);
          hd(Z, J);
        }
      });
    }, D = (A) => {
      const z = A.target, { code: Z } = A;
      switch (Z) {
        case Ce.up:
        case Ce.down: {
          A.preventDefault();
          const J = Z === Ce.up ? -1 : 1;
          uo(zi(z, J, `.${o.b("node")}[tabindex="-1"]`));
          break;
        }
        case Ce.left: {
          A.preventDefault();
          const J = u.value[Er(z) - 1], V = J == null ? void 0 : J.$el.querySelector(`.${o.b("node")}[aria-expanded="true"]`);
          uo(V);
          break;
        }
        case Ce.right: {
          A.preventDefault();
          const J = u.value[Er(z) + 1], V = J == null ? void 0 : J.$el.querySelector(`.${o.b("node")}[tabindex="-1"]`);
          uo(V);
          break;
        }
        case Ce.enter:
          Im(z);
          break;
      }
    };
    return tt(Sa, ct({
      config: a,
      expandingNode: d,
      checkedNodes: f,
      isHoverMenu: h,
      initialLoaded: i,
      renderLabelFn: v,
      lazyLoad: g,
      expandNode: w,
      handleCheckChange: C
    })), ue([a, () => e.options], m, {
      deep: !0,
      immediate: !0
    }), ue(() => e.modelValue, () => {
      l = !1, I();
    }, {
      deep: !0
    }), ue(() => c.value, (A) => {
      bn(A, e.modelValue) || (t(et, A), t(vt, A));
    }), Sf(() => u.value = []), We(() => !an(e.modelValue) && I()), {
      ns: o,
      menuList: u,
      menus: p,
      checkedNodes: f,
      handleKeyDown: D,
      handleCheckChange: C,
      getFlattedNodes: b,
      getCheckedNodes: S,
      clearCheckedNodes: T,
      calculateCheckedValue: O,
      scrollToExpandingNode: B
    };
  }
});
function Om(e, t, n, l, o, a) {
  const r = $e("el-cascader-menu");
  return E(), _("div", {
    class: $([e.ns.b("panel"), e.ns.is("bordered", e.border)]),
    onKeydown: t[0] || (t[0] = (...i) => e.handleKeyDown && e.handleKeyDown(...i))
  }, [
    (E(!0), _(Re, null, Xe(e.menus, (i, u) => (E(), q(r, {
      key: u,
      ref_for: !0,
      ref: (c) => e.menuList[u] = c,
      index: u,
      nodes: [...i]
    }, null, 8, ["index", "nodes"]))), 128))
  ], 34);
}
var vo = /* @__PURE__ */ de(Rm, [["render", Om], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/index.vue"]]);
vo.install = (e) => {
  e.component(vo.name, vo);
};
const Ru = vo, Pm = Ru, Am = he({
  ...Mu,
  size: Cn,
  placeholder: String,
  disabled: Boolean,
  clearable: Boolean,
  filterable: Boolean,
  filterMethod: {
    type: j(Function),
    default: (e, t) => e.text.includes(t)
  },
  separator: {
    type: String,
    default: " / "
  },
  showAllLevels: {
    type: Boolean,
    default: !0
  },
  collapseTags: Boolean,
  collapseTagsTooltip: {
    type: Boolean,
    default: !1
  },
  debounce: {
    type: Number,
    default: 300
  },
  beforeFilter: {
    type: j(Function),
    default: () => !0
  },
  popperClass: {
    type: String,
    default: ""
  },
  teleported: Pt.teleported,
  tagType: { ...vd.type, default: "info" },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), _m = {
  [et]: (e) => !!e || e === null,
  [vt]: (e) => !!e || e === null,
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent,
  visibleChange: (e) => Qt(e),
  expandChange: (e) => !!e,
  removeTag: (e) => !!e
}, Lm = { key: 0 }, Vm = ["placeholder", "onKeydown"], Bm = ["onClick"], Dm = "ElCascader", xm = F({
  name: Dm
}), Fm = /* @__PURE__ */ F({
  ...xm,
  props: Am,
  emits: _m,
  setup(e, { expose: t, emit: n }) {
    const l = e, o = {
      modifiers: [
        {
          name: "arrowPosition",
          enabled: !0,
          phase: "main",
          fn: ({ state: Y }) => {
            const { modifiersData: ae, placement: re } = Y;
            ["right", "left", "bottom", "top"].includes(re) || (ae.arrow.x = 35);
          },
          requires: ["arrow"]
        }
      ]
    }, a = ca();
    let r = 0, i = 0;
    const u = se("cascader"), c = se("input"), { t: p } = ot(), { form: d, formItem: f } = kl(), h = N(null), v = N(null), m = N(null), g = N(null), w = N(null), C = N(!1), y = N(!1), b = N(!1), S = N(!1), T = N(""), O = N(""), I = N([]), R = N([]), B = N([]), D = N(!1), A = k(() => a.style), z = k(() => l.disabled || (d == null ? void 0 : d.disabled)), Z = k(() => l.placeholder || p("el.cascader.placeholder")), J = k(() => O.value || I.value.length > 0 || D.value ? "" : Z.value), V = dn(), M = k(() => ["small"].includes(V.value) ? "small" : "default"), P = k(() => !!l.props.multiple), L = k(() => !l.filterable || P.value), U = k(() => P.value ? O.value : T.value), oe = k(() => {
      var Y;
      return ((Y = g.value) == null ? void 0 : Y.checkedNodes) || [];
    }), le = k(() => !l.clearable || z.value || b.value || !y.value ? !1 : !!oe.value.length), ee = k(() => {
      const { showAllLevels: Y, separator: ae } = l, re = oe.value;
      return re.length ? P.value ? "" : re[0].calcText(Y, ae) : "";
    }), pe = k({
      get() {
        return va(l.modelValue);
      },
      set(Y) {
        n(et, Y), n(vt, Y), l.validateEvent && (f == null || f.validate("change").catch((ae) => pt(ae)));
      }
    }), ge = k(() => [
      u.b(),
      u.m(V.value),
      u.is("disabled", z.value),
      a.class
    ]), te = k(() => [
      c.e("icon"),
      "icon-arrow-down",
      u.is("reverse", C.value)
    ]), ve = k(() => u.is("focus", C.value || S.value)), G = k(() => {
      var Y, ae;
      return (ae = (Y = h.value) == null ? void 0 : Y.popperRef) == null ? void 0 : ae.contentRef;
    }), Q = (Y) => {
      var ae, re, Me;
      z.value || (Y = Y != null ? Y : !C.value, Y !== C.value && (C.value = Y, (re = (ae = v.value) == null ? void 0 : ae.input) == null || re.setAttribute("aria-expanded", `${Y}`), Y ? (ie(), Ne((Me = g.value) == null ? void 0 : Me.scrollToExpandingNode)) : l.filterable && Ke(), n("visibleChange", Y)));
    }, ie = () => {
      Ne(() => {
        var Y;
        (Y = h.value) == null || Y.updatePopper();
      });
    }, Ee = () => {
      b.value = !1;
    }, De = (Y) => {
      const { showAllLevels: ae, separator: re } = l;
      return {
        node: Y,
        key: Y.uid,
        text: Y.calcText(ae, re),
        hitState: !1,
        closable: !z.value && !Y.isDisabled,
        isCollapseTag: !1
      };
    }, Ve = (Y) => {
      var ae;
      const re = Y.node;
      re.doCheck(!1), (ae = g.value) == null || ae.calculateCheckedValue(), n("removeTag", re.valueByOption);
    }, Fe = () => {
      if (!P.value)
        return;
      const Y = oe.value, ae = [], re = [];
      if (Y.forEach((Me) => re.push(De(Me))), R.value = re, Y.length) {
        const [Me, ...Ze] = Y, Qe = Ze.length;
        ae.push(De(Me)), Qe && (l.collapseTags ? ae.push({
          key: -1,
          text: `+ ${Qe}`,
          closable: !1,
          isCollapseTag: !0
        }) : Ze.forEach((dt) => ae.push(De(dt))));
      }
      I.value = ae;
    }, ze = () => {
      var Y, ae;
      const { filterMethod: re, showAllLevels: Me, separator: Ze } = l, Qe = (ae = (Y = g.value) == null ? void 0 : Y.getFlattedNodes(!l.props.checkStrictly)) == null ? void 0 : ae.filter((dt) => dt.isDisabled ? !1 : (dt.calcText(Me, Ze), re(dt, U.value)));
      P.value && (I.value.forEach((dt) => {
        dt.hitState = !1;
      }), R.value.forEach((dt) => {
        dt.hitState = !1;
      })), b.value = !0, B.value = Qe, ie();
    }, it = () => {
      var Y;
      let ae;
      b.value && w.value ? ae = w.value.$el.querySelector(`.${u.e("suggestion-item")}`) : ae = (Y = g.value) == null ? void 0 : Y.$el.querySelector(`.${u.b("node")}[tabindex="-1"]`), ae && (ae.focus(), !b.value && ae.click());
    }, be = () => {
      var Y, ae;
      const re = (Y = v.value) == null ? void 0 : Y.input, Me = m.value, Ze = (ae = w.value) == null ? void 0 : ae.$el;
      if (!(!rt || !re)) {
        if (Ze) {
          const Qe = Ze.querySelector(`.${u.e("suggestion-list")}`);
          Qe.style.minWidth = `${re.offsetWidth}px`;
        }
        if (Me) {
          const { offsetHeight: Qe } = Me, dt = I.value.length > 0 ? `${Math.max(Qe + 6, r)}px` : `${r}px`;
          re.style.height = dt, ie();
        }
      }
    }, Te = (Y) => {
      var ae;
      return (ae = g.value) == null ? void 0 : ae.getCheckedNodes(Y);
    }, we = (Y) => {
      ie(), n("expandChange", Y);
    }, _e = (Y) => {
      var ae;
      const re = (ae = Y.target) == null ? void 0 : ae.value;
      if (Y.type === "compositionend")
        D.value = !1, Ne(() => ke(re));
      else {
        const Me = re[re.length - 1] || "";
        D.value = !yi(Me);
      }
    }, Ie = (Y) => {
      if (!D.value)
        switch (Y.code) {
          case Ce.enter:
            Q();
            break;
          case Ce.down:
            Q(!0), Ne(it), Y.preventDefault();
            break;
          case Ce.esc:
            C.value === !0 && (Y.preventDefault(), Y.stopPropagation(), Q(!1));
            break;
          case Ce.tab:
            Q(!1);
            break;
        }
    }, Le = () => {
      var Y;
      (Y = g.value) == null || Y.clearCheckedNodes(), !C.value && l.filterable && Ke(), Q(!1);
    }, Ke = () => {
      const { value: Y } = ee;
      T.value = Y, O.value = Y;
    }, Ye = (Y) => {
      var ae, re;
      const { checked: Me } = Y;
      P.value ? (ae = g.value) == null || ae.handleCheckChange(Y, !Me, !1) : (!Me && ((re = g.value) == null || re.handleCheckChange(Y, !0, !1)), Q(!1));
    }, nt = (Y) => {
      const ae = Y.target, { code: re } = Y;
      switch (re) {
        case Ce.up:
        case Ce.down: {
          const Me = re === Ce.up ? -1 : 1;
          uo(zi(ae, Me, `.${u.e("suggestion-item")}[tabindex="-1"]`));
          break;
        }
        case Ce.enter:
          ae.click();
          break;
      }
    }, gt = () => {
      const Y = I.value, ae = Y[Y.length - 1];
      i = O.value ? 0 : i + 1, !(!ae || !i || l.collapseTags && Y.length > 1) && (ae.hitState ? Ve(ae) : ae.hitState = !0);
    }, kt = (Y) => {
      const ae = Y.target, re = u.e("search-input");
      ae.className === re && (S.value = !0), n("focus", Y);
    }, St = (Y) => {
      S.value = !1, n("blur", Y);
    }, yt = Gt(() => {
      const { value: Y } = U;
      if (!Y)
        return;
      const ae = l.beforeFilter(Y);
      gs(ae) ? ae.then(ze).catch(() => {
      }) : ae !== !1 ? ze() : Ee();
    }, l.debounce), ke = (Y, ae) => {
      !C.value && Q(!0), !(ae != null && ae.isComposing) && (Y ? yt() : Ee());
    };
    return ue(b, ie), ue([oe, z], Fe), ue(I, () => {
      Ne(() => be());
    }), ue(ee, Ke, { immediate: !0 }), We(() => {
      const Y = v.value.input, ae = Number.parseFloat(md(c.cssVarName("input-height"), Y).value) - 2;
      r = Y.offsetHeight || ae, Mn(Y, be);
    }), t({
      getCheckedNodes: Te,
      cascaderPanelRef: g,
      togglePopperVisible: Q,
      contentRef: G
    }), (Y, ae) => (E(), q(s(Wt), {
      ref_key: "tooltipRef",
      ref: h,
      visible: C.value,
      teleported: Y.teleported,
      "popper-class": [s(u).e("dropdown"), Y.popperClass],
      "popper-options": o,
      "fallback-placements": [
        "bottom-start",
        "bottom",
        "top-start",
        "top",
        "right",
        "left"
      ],
      "stop-popper-mouse-event": !1,
      "gpu-acceleration": !1,
      placement: "bottom-start",
      transition: `${s(u).namespace.value}-zoom-in-top`,
      effect: "light",
      pure: "",
      persistent: "",
      onHide: Ee
    }, {
      default: K(() => [
        qe((E(), _("div", {
          class: $(s(ge)),
          style: ye(s(A)),
          onClick: ae[5] || (ae[5] = () => Q(s(L) ? void 0 : !0)),
          onKeydown: Ie,
          onMouseenter: ae[6] || (ae[6] = (re) => y.value = !0),
          onMouseleave: ae[7] || (ae[7] = (re) => y.value = !1)
        }, [
          x(s(Jn), {
            ref_key: "input",
            ref: v,
            modelValue: T.value,
            "onUpdate:modelValue": ae[1] || (ae[1] = (re) => T.value = re),
            placeholder: s(J),
            readonly: s(L),
            disabled: s(z),
            "validate-event": !1,
            size: s(V),
            class: $(s(ve)),
            tabindex: s(P) && Y.filterable && !s(z) ? -1 : void 0,
            onCompositionstart: _e,
            onCompositionupdate: _e,
            onCompositionend: _e,
            onFocus: kt,
            onBlur: St,
            onInput: ke
          }, {
            suffix: K(() => [
              s(le) ? (E(), q(s(Se), {
                key: "clear",
                class: $([s(c).e("icon"), "icon-circle-close"]),
                onClick: Ae(Le, ["stop"])
              }, {
                default: K(() => [
                  x(s(Ko))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : (E(), q(s(Se), {
                key: "arrow-down",
                class: $(s(te)),
                onClick: ae[0] || (ae[0] = Ae((re) => Q(), ["stop"]))
              }, {
                default: K(() => [
                  x(s(Zl))
                ]),
                _: 1
              }, 8, ["class"]))
            ]),
            _: 1
          }, 8, ["modelValue", "placeholder", "readonly", "disabled", "size", "class", "tabindex"]),
          s(P) ? (E(), _("div", {
            key: 0,
            ref_key: "tagWrapper",
            ref: m,
            class: $(s(u).e("tags"))
          }, [
            (E(!0), _(Re, null, Xe(I.value, (re) => (E(), q(s(Mo), {
              key: re.key,
              type: Y.tagType,
              size: s(M),
              hit: re.hitState,
              closable: re.closable,
              "disable-transitions": "",
              onClose: (Me) => Ve(re)
            }, {
              default: K(() => [
                re.isCollapseTag === !1 ? (E(), _("span", Lm, ce(re.text), 1)) : (E(), q(s(Wt), {
                  key: 1,
                  disabled: C.value || !Y.collapseTagsTooltip,
                  "fallback-placements": ["bottom", "top", "right", "left"],
                  placement: "bottom",
                  effect: "light"
                }, {
                  default: K(() => [
                    H("span", null, ce(re.text), 1)
                  ]),
                  content: K(() => [
                    H("div", {
                      class: $(s(u).e("collapse-tags"))
                    }, [
                      (E(!0), _(Re, null, Xe(R.value.slice(1), (Me, Ze) => (E(), _("div", {
                        key: Ze,
                        class: $(s(u).e("collapse-tag"))
                      }, [
                        (E(), q(s(Mo), {
                          key: Me.key,
                          class: "in-tooltip",
                          type: Y.tagType,
                          size: s(M),
                          hit: Me.hitState,
                          closable: Me.closable,
                          "disable-transitions": "",
                          onClose: (Qe) => Ve(Me)
                        }, {
                          default: K(() => [
                            H("span", null, ce(Me.text), 1)
                          ]),
                          _: 2
                        }, 1032, ["type", "size", "hit", "closable", "onClose"]))
                      ], 2))), 128))
                    ], 2)
                  ]),
                  _: 2
                }, 1032, ["disabled"]))
              ]),
              _: 2
            }, 1032, ["type", "size", "hit", "closable", "onClose"]))), 128)),
            Y.filterable && !s(z) ? qe((E(), _("input", {
              key: 0,
              "onUpdate:modelValue": ae[2] || (ae[2] = (re) => O.value = re),
              type: "text",
              class: $(s(u).e("search-input")),
              placeholder: s(ee) ? "" : s(Z),
              onInput: ae[3] || (ae[3] = (re) => ke(O.value, re)),
              onClick: ae[4] || (ae[4] = Ae((re) => Q(!0), ["stop"])),
              onKeydown: ut(gt, ["delete"]),
              onCompositionstart: _e,
              onCompositionupdate: _e,
              onCompositionend: _e,
              onFocus: kt,
              onBlur: St
            }, null, 42, Vm)), [
              [Ri, O.value]
            ]) : W("v-if", !0)
          ], 2)) : W("v-if", !0)
        ], 38)), [
          [s(Wo), () => Q(!1), s(G)]
        ])
      ]),
      content: K(() => [
        qe(x(s(Ru), {
          ref_key: "cascaderPanelRef",
          ref: g,
          modelValue: s(pe),
          "onUpdate:modelValue": ae[8] || (ae[8] = (re) => Nn(pe) ? pe.value = re : null),
          options: Y.options,
          props: l.props,
          border: !1,
          "render-label": Y.$slots.default,
          onExpandChange: we,
          onClose: ae[9] || (ae[9] = (re) => Y.$nextTick(() => Q(!1)))
        }, null, 8, ["modelValue", "options", "props", "render-label"]), [
          [at, !b.value]
        ]),
        Y.filterable ? qe((E(), q(s(Zn), {
          key: 0,
          ref_key: "suggestionPanel",
          ref: w,
          tag: "ul",
          class: $(s(u).e("suggestion-panel")),
          "view-class": s(u).e("suggestion-list"),
          onKeydown: nt
        }, {
          default: K(() => [
            B.value.length ? (E(!0), _(Re, { key: 0 }, Xe(B.value, (re) => (E(), _("li", {
              key: re.uid,
              class: $([
                s(u).e("suggestion-item"),
                s(u).is("checked", re.checked)
              ]),
              tabindex: -1,
              onClick: (Me) => Ye(re)
            }, [
              H("span", null, ce(re.text), 1),
              re.checked ? (E(), q(s(Se), { key: 0 }, {
                default: K(() => [
                  x(s(Xl))
                ]),
                _: 1
              })) : W("v-if", !0)
            ], 10, Bm))), 128)) : ne(Y.$slots, "empty", { key: 1 }, () => [
              H("li", {
                class: $(s(u).e("empty-text"))
              }, ce(s(p)("el.cascader.noMatch")), 3)
            ])
          ]),
          _: 3
        }, 8, ["class", "view-class"])), [
          [at, b.value]
        ]) : W("v-if", !0)
      ]),
      _: 3
    }, 8, ["visible", "teleported", "popper-class", "transition"]));
  }
});
var mo = /* @__PURE__ */ de(Fm, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader/src/cascader.vue"]]);
mo.install = (e) => {
  e.component(mo.name, mo);
};
const Hm = mo, zm = Hm, Km = he({
  checked: {
    type: Boolean,
    default: !1
  }
}), Wm = {
  "update:checked": (e) => Qt(e),
  [vt]: (e) => Qt(e)
}, jm = F({
  name: "ElCheckTag"
}), Um = /* @__PURE__ */ F({
  ...jm,
  props: Km,
  emits: Wm,
  setup(e, { emit: t }) {
    const n = e, l = se("check-tag"), o = () => {
      const a = !n.checked;
      t(vt, a), t("update:checked", a);
    };
    return (a, r) => (E(), _("span", {
      class: $([s(l).b(), s(l).is("checked", a.checked)]),
      onClick: o
    }, [
      ne(a.$slots, "default")
    ], 2));
  }
});
var qm = /* @__PURE__ */ de(Um, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/check-tag/src/check-tag.vue"]]);
const Gm = xe(qm), Ym = he({
  color: {
    type: j(Object),
    required: !0
  },
  vertical: {
    type: Boolean,
    default: !1
  }
});
let ss = !1;
function Fl(e, t) {
  if (!rt)
    return;
  const n = function(a) {
    var r;
    (r = t.drag) == null || r.call(t, a);
  }, l = function(a) {
    var r;
    document.removeEventListener("mousemove", n), document.removeEventListener("mouseup", l), document.removeEventListener("touchmove", n), document.removeEventListener("touchend", l), document.onselectstart = null, document.ondragstart = null, ss = !1, (r = t.end) == null || r.call(t, a);
  }, o = function(a) {
    var r;
    ss || (a.preventDefault(), document.onselectstart = () => !1, document.ondragstart = () => !1, document.addEventListener("mousemove", n), document.addEventListener("mouseup", l), document.addEventListener("touchmove", n), document.addEventListener("touchend", l), ss = !0, (r = t.start) == null || r.call(t, a));
  };
  e.addEventListener("mousedown", o), e.addEventListener("touchstart", o);
}
const Xm = (e) => {
  const t = je(), n = ht(), l = ht();
  function o(r) {
    r.target !== n.value && a(r);
  }
  function a(r) {
    if (!l.value || !n.value)
      return;
    const u = t.vnode.el.getBoundingClientRect(), { clientX: c, clientY: p } = ma(r);
    if (e.vertical) {
      let d = p - u.top;
      d = Math.max(n.value.offsetHeight / 2, d), d = Math.min(d, u.height - n.value.offsetHeight / 2), e.color.set("alpha", Math.round((d - n.value.offsetHeight / 2) / (u.height - n.value.offsetHeight) * 100));
    } else {
      let d = c - u.left;
      d = Math.max(n.value.offsetWidth / 2, d), d = Math.min(d, u.width - n.value.offsetWidth / 2), e.color.set("alpha", Math.round((d - n.value.offsetWidth / 2) / (u.width - n.value.offsetWidth) * 100));
    }
  }
  return {
    thumb: n,
    bar: l,
    handleDrag: a,
    handleClick: o
  };
}, Zm = (e, {
  bar: t,
  thumb: n,
  handleDrag: l
}) => {
  const o = je(), a = se("color-alpha-slider"), r = N(0), i = N(0), u = N();
  function c() {
    if (!n.value || e.vertical)
      return 0;
    const C = o.vnode.el, y = e.color.get("alpha");
    return C ? Math.round(y * (C.offsetWidth - n.value.offsetWidth / 2) / 100) : 0;
  }
  function p() {
    if (!n.value)
      return 0;
    const C = o.vnode.el;
    if (!e.vertical)
      return 0;
    const y = e.color.get("alpha");
    return C ? Math.round(y * (C.offsetHeight - n.value.offsetHeight / 2) / 100) : 0;
  }
  function d() {
    if (e.color && e.color.value) {
      const { r: C, g: y, b } = e.color.toRgb();
      return `linear-gradient(to right, rgba(${C}, ${y}, ${b}, 0) 0%, rgba(${C}, ${y}, ${b}, 1) 100%)`;
    }
    return "";
  }
  function f() {
    r.value = c(), i.value = p(), u.value = d();
  }
  We(() => {
    if (!t.value || !n.value)
      return;
    const C = {
      drag: (y) => {
        l(y);
      },
      end: (y) => {
        l(y);
      }
    };
    Fl(t.value, C), Fl(n.value, C), f();
  }), ue(() => e.color.get("alpha"), () => f()), ue(() => e.color.value, () => f());
  const h = k(() => [a.b(), a.is("vertical", e.vertical)]), v = k(() => a.e("bar")), m = k(() => a.e("thumb")), g = k(() => ({ background: u.value })), w = k(() => ({
    left: It(r.value),
    top: It(i.value)
  }));
  return { rootKls: h, barKls: v, barStyle: g, thumbKls: m, thumbStyle: w, update: f };
}, Jm = "ElColorAlphaSlider", Qm = F({
  name: Jm
}), eg = /* @__PURE__ */ F({
  ...Qm,
  props: Ym,
  setup(e, { expose: t }) {
    const n = e, { bar: l, thumb: o, handleDrag: a, handleClick: r } = Xm(n), { rootKls: i, barKls: u, barStyle: c, thumbKls: p, thumbStyle: d, update: f } = Zm(n, {
      bar: l,
      thumb: o,
      handleDrag: a
    });
    return t({
      update: f,
      bar: l,
      thumb: o
    }), (h, v) => (E(), _("div", {
      class: $(s(i))
    }, [
      H("div", {
        ref_key: "bar",
        ref: l,
        class: $(s(u)),
        style: ye(s(c)),
        onClick: v[0] || (v[0] = (...m) => s(r) && s(r)(...m))
      }, null, 6),
      H("div", {
        ref_key: "thumb",
        ref: o,
        class: $(s(p)),
        style: ye(s(d))
      }, null, 6)
    ], 2));
  }
});
var tg = /* @__PURE__ */ de(eg, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/alpha-slider.vue"]]);
const ng = F({
  name: "ElColorHueSlider",
  props: {
    color: {
      type: Object,
      required: !0
    },
    vertical: Boolean
  },
  setup(e) {
    const t = se("color-hue-slider"), n = je(), l = N(), o = N(), a = N(0), r = N(0), i = k(() => e.color.get("hue"));
    ue(() => i.value, () => {
      f();
    });
    function u(h) {
      h.target !== l.value && c(h);
    }
    function c(h) {
      if (!o.value || !l.value)
        return;
      const m = n.vnode.el.getBoundingClientRect(), { clientX: g, clientY: w } = ma(h);
      let C;
      if (e.vertical) {
        let y = w - m.top;
        y = Math.min(y, m.height - l.value.offsetHeight / 2), y = Math.max(l.value.offsetHeight / 2, y), C = Math.round((y - l.value.offsetHeight / 2) / (m.height - l.value.offsetHeight) * 360);
      } else {
        let y = g - m.left;
        y = Math.min(y, m.width - l.value.offsetWidth / 2), y = Math.max(l.value.offsetWidth / 2, y), C = Math.round((y - l.value.offsetWidth / 2) / (m.width - l.value.offsetWidth) * 360);
      }
      e.color.set("hue", C);
    }
    function p() {
      if (!l.value)
        return 0;
      const h = n.vnode.el;
      if (e.vertical)
        return 0;
      const v = e.color.get("hue");
      return h ? Math.round(v * (h.offsetWidth - l.value.offsetWidth / 2) / 360) : 0;
    }
    function d() {
      if (!l.value)
        return 0;
      const h = n.vnode.el;
      if (!e.vertical)
        return 0;
      const v = e.color.get("hue");
      return h ? Math.round(v * (h.offsetHeight - l.value.offsetHeight / 2) / 360) : 0;
    }
    function f() {
      a.value = p(), r.value = d();
    }
    return We(() => {
      if (!o.value || !l.value)
        return;
      const h = {
        drag: (v) => {
          c(v);
        },
        end: (v) => {
          c(v);
        }
      };
      Fl(o.value, h), Fl(l.value, h), f();
    }), {
      bar: o,
      thumb: l,
      thumbLeft: a,
      thumbTop: r,
      hueValue: i,
      handleClick: u,
      update: f,
      ns: t
    };
  }
});
function lg(e, t, n, l, o, a) {
  return E(), _("div", {
    class: $([e.ns.b(), e.ns.is("vertical", e.vertical)])
  }, [
    H("div", {
      ref: "bar",
      class: $(e.ns.e("bar")),
      onClick: t[0] || (t[0] = (...r) => e.handleClick && e.handleClick(...r))
    }, null, 2),
    H("div", {
      ref: "thumb",
      class: $(e.ns.e("thumb")),
      style: ye({
        left: e.thumbLeft + "px",
        top: e.thumbTop + "px"
      })
    }, null, 6)
  ], 2);
}
var og = /* @__PURE__ */ de(ng, [["render", lg], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/hue-slider.vue"]]);
const sg = he({
  modelValue: String,
  id: String,
  showAlpha: Boolean,
  colorFormat: String,
  disabled: Boolean,
  size: Cn,
  popperClass: {
    type: String,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  predefine: {
    type: j(Array)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), ag = {
  [et]: (e) => Ue(e) || un(e),
  [vt]: (e) => Ue(e) || un(e),
  activeChange: (e) => Ue(e) || un(e)
}, Ou = Symbol("colorPickerContextKey"), $r = function(e, t, n) {
  return [
    e,
    t * n / ((e = (2 - t) * n) < 1 ? e : 2 - e) || 0,
    e / 2
  ];
}, rg = function(e) {
  return typeof e == "string" && e.includes(".") && Number.parseFloat(e) === 1;
}, ig = function(e) {
  return typeof e == "string" && e.includes("%");
}, cl = function(e, t) {
  rg(e) && (e = "100%");
  const n = ig(e);
  return e = Math.min(t, Math.max(0, Number.parseFloat(`${e}`))), n && (e = Number.parseInt(`${e * t}`, 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : e % t / Number.parseFloat(t);
}, Tr = {
  10: "A",
  11: "B",
  12: "C",
  13: "D",
  14: "E",
  15: "F"
}, go = (e) => {
  e = Math.min(Math.round(e), 255);
  const t = Math.floor(e / 16), n = e % 16;
  return `${Tr[t] || t}${Tr[n] || n}`;
}, Nr = function({ r: e, g: t, b: n }) {
  return Number.isNaN(+e) || Number.isNaN(+t) || Number.isNaN(+n) ? "" : `#${go(e)}${go(t)}${go(n)}`;
}, as = {
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
}, Ln = function(e) {
  return e.length === 2 ? (as[e[0].toUpperCase()] || +e[0]) * 16 + (as[e[1].toUpperCase()] || +e[1]) : as[e[1].toUpperCase()] || +e[1];
}, ug = function(e, t, n) {
  t = t / 100, n = n / 100;
  let l = t;
  const o = Math.max(n, 0.01);
  n *= 2, t *= n <= 1 ? n : 2 - n, l *= o <= 1 ? o : 2 - o;
  const a = (n + t) / 2, r = n === 0 ? 2 * l / (o + l) : 2 * t / (n + t);
  return {
    h: e,
    s: r * 100,
    v: a * 100
  };
}, Ir = (e, t, n) => {
  e = cl(e, 255), t = cl(t, 255), n = cl(n, 255);
  const l = Math.max(e, t, n), o = Math.min(e, t, n);
  let a;
  const r = l, i = l - o, u = l === 0 ? 0 : i / l;
  if (l === o)
    a = 0;
  else {
    switch (l) {
      case e: {
        a = (t - n) / i + (t < n ? 6 : 0);
        break;
      }
      case t: {
        a = (n - e) / i + 2;
        break;
      }
      case n: {
        a = (e - t) / i + 4;
        break;
      }
    }
    a /= 6;
  }
  return { h: a * 360, s: u * 100, v: r * 100 };
}, Tl = function(e, t, n) {
  e = cl(e, 360) * 6, t = cl(t, 100), n = cl(n, 100);
  const l = Math.floor(e), o = e - l, a = n * (1 - t), r = n * (1 - o * t), i = n * (1 - (1 - o) * t), u = l % 6, c = [n, r, a, a, i, n][u], p = [i, n, n, r, a, a][u], d = [a, a, i, n, n, r][u];
  return {
    r: Math.round(c * 255),
    g: Math.round(p * 255),
    b: Math.round(d * 255)
  };
};
class Pl {
  constructor(t = {}) {
    this._hue = 0, this._saturation = 100, this._value = 100, this._alpha = 100, this.enableAlpha = !1, this.format = "hex", this.value = "";
    for (const n in t)
      Bt(t, n) && (this[n] = t[n]);
    t.value ? this.fromString(t.value) : this.doOnChange();
  }
  set(t, n) {
    if (arguments.length === 1 && typeof t == "object") {
      for (const l in t)
        Bt(t, l) && this.set(l, t[l]);
      return;
    }
    this[`_${t}`] = n, this.doOnChange();
  }
  get(t) {
    return t === "alpha" ? Math.floor(this[`_${t}`]) : this[`_${t}`];
  }
  toRgb() {
    return Tl(this._hue, this._saturation, this._value);
  }
  fromString(t) {
    if (!t) {
      this._hue = 0, this._saturation = 100, this._value = 100, this.doOnChange();
      return;
    }
    const n = (l, o, a) => {
      this._hue = Math.max(0, Math.min(360, l)), this._saturation = Math.max(0, Math.min(100, o)), this._value = Math.max(0, Math.min(100, a)), this.doOnChange();
    };
    if (t.includes("hsl")) {
      const l = t.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((o) => o !== "").map((o, a) => a > 2 ? Number.parseFloat(o) : Number.parseInt(o, 10));
      if (l.length === 4 ? this._alpha = Number.parseFloat(l[3]) * 100 : l.length === 3 && (this._alpha = 100), l.length >= 3) {
        const { h: o, s: a, v: r } = ug(l[0], l[1], l[2]);
        n(o, a, r);
      }
    } else if (t.includes("hsv")) {
      const l = t.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((o) => o !== "").map((o, a) => a > 2 ? Number.parseFloat(o) : Number.parseInt(o, 10));
      l.length === 4 ? this._alpha = Number.parseFloat(l[3]) * 100 : l.length === 3 && (this._alpha = 100), l.length >= 3 && n(l[0], l[1], l[2]);
    } else if (t.includes("rgb")) {
      const l = t.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((o) => o !== "").map((o, a) => a > 2 ? Number.parseFloat(o) : Number.parseInt(o, 10));
      if (l.length === 4 ? this._alpha = Number.parseFloat(l[3]) * 100 : l.length === 3 && (this._alpha = 100), l.length >= 3) {
        const { h: o, s: a, v: r } = Ir(l[0], l[1], l[2]);
        n(o, a, r);
      }
    } else if (t.includes("#")) {
      const l = t.replace("#", "").trim();
      if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(l))
        return;
      let o, a, r;
      l.length === 3 ? (o = Ln(l[0] + l[0]), a = Ln(l[1] + l[1]), r = Ln(l[2] + l[2])) : (l.length === 6 || l.length === 8) && (o = Ln(l.slice(0, 2)), a = Ln(l.slice(2, 4)), r = Ln(l.slice(4, 6))), l.length === 8 ? this._alpha = Ln(l.slice(6)) / 255 * 100 : (l.length === 3 || l.length === 6) && (this._alpha = 100);
      const { h: i, s: u, v: c } = Ir(o, a, r);
      n(i, u, c);
    }
  }
  compare(t) {
    return Math.abs(t._hue - this._hue) < 2 && Math.abs(t._saturation - this._saturation) < 1 && Math.abs(t._value - this._value) < 1 && Math.abs(t._alpha - this._alpha) < 1;
  }
  doOnChange() {
    const { _hue: t, _saturation: n, _value: l, _alpha: o, format: a } = this;
    if (this.enableAlpha)
      switch (a) {
        case "hsl": {
          const r = $r(t, n / 100, l / 100);
          this.value = `hsla(${t}, ${Math.round(r[1] * 100)}%, ${Math.round(r[2] * 100)}%, ${this.get("alpha") / 100})`;
          break;
        }
        case "hsv": {
          this.value = `hsva(${t}, ${Math.round(n)}%, ${Math.round(l)}%, ${this.get("alpha") / 100})`;
          break;
        }
        case "hex": {
          this.value = `${Nr(Tl(t, n, l))}${go(o * 255 / 100)}`;
          break;
        }
        default: {
          const { r, g: i, b: u } = Tl(t, n, l);
          this.value = `rgba(${r}, ${i}, ${u}, ${this.get("alpha") / 100})`;
        }
      }
    else
      switch (a) {
        case "hsl": {
          const r = $r(t, n / 100, l / 100);
          this.value = `hsl(${t}, ${Math.round(r[1] * 100)}%, ${Math.round(r[2] * 100)}%)`;
          break;
        }
        case "hsv": {
          this.value = `hsv(${t}, ${Math.round(n)}%, ${Math.round(l)}%)`;
          break;
        }
        case "rgb": {
          const { r, g: i, b: u } = Tl(t, n, l);
          this.value = `rgb(${r}, ${i}, ${u})`;
          break;
        }
        default:
          this.value = Nr(Tl(t, n, l));
      }
  }
}
const cg = F({
  props: {
    colors: {
      type: Array,
      required: !0
    },
    color: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const t = se("color-predefine"), { currentColor: n } = Oe(Ou), l = N(a(e.colors, e.color));
    ue(() => n.value, (r) => {
      const i = new Pl();
      i.fromString(r), l.value.forEach((u) => {
        u.selected = i.compare(u);
      });
    }), en(() => {
      l.value = a(e.colors, e.color);
    });
    function o(r) {
      e.color.fromString(e.colors[r]);
    }
    function a(r, i) {
      return r.map((u) => {
        const c = new Pl();
        return c.enableAlpha = !0, c.format = "rgba", c.fromString(u), c.selected = c.value === i.value, c;
      });
    }
    return {
      rgbaColors: l,
      handleSelect: o,
      ns: t
    };
  }
}), dg = ["onClick"];
function fg(e, t, n, l, o, a) {
  return E(), _("div", {
    class: $(e.ns.b())
  }, [
    H("div", {
      class: $(e.ns.e("colors"))
    }, [
      (E(!0), _(Re, null, Xe(e.rgbaColors, (r, i) => (E(), _("div", {
        key: e.colors[i],
        class: $([
          e.ns.e("color-selector"),
          e.ns.is("alpha", r._alpha < 100),
          { selected: r.selected }
        ]),
        onClick: (u) => e.handleSelect(i)
      }, [
        H("div", {
          style: ye({ backgroundColor: r.value })
        }, null, 4)
      ], 10, dg))), 128))
    ], 2)
  ], 2);
}
var pg = /* @__PURE__ */ de(cg, [["render", fg], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/predefine.vue"]]);
const hg = F({
  name: "ElSlPanel",
  props: {
    color: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const t = se("color-svpanel"), n = je(), l = N(0), o = N(0), a = N("hsl(0, 100%, 50%)"), r = k(() => {
      const c = e.color.get("hue"), p = e.color.get("value");
      return { hue: c, value: p };
    });
    function i() {
      const c = e.color.get("saturation"), p = e.color.get("value"), d = n.vnode.el, { clientWidth: f, clientHeight: h } = d;
      o.value = c * f / 100, l.value = (100 - p) * h / 100, a.value = `hsl(${e.color.get("hue")}, 100%, 50%)`;
    }
    function u(c) {
      const d = n.vnode.el.getBoundingClientRect(), { clientX: f, clientY: h } = ma(c);
      let v = f - d.left, m = h - d.top;
      v = Math.max(0, v), v = Math.min(v, d.width), m = Math.max(0, m), m = Math.min(m, d.height), o.value = v, l.value = m, e.color.set({
        saturation: v / d.width * 100,
        value: 100 - m / d.height * 100
      });
    }
    return ue(() => r.value, () => {
      i();
    }), We(() => {
      Fl(n.vnode.el, {
        drag: (c) => {
          u(c);
        },
        end: (c) => {
          u(c);
        }
      }), i();
    }), {
      cursorTop: l,
      cursorLeft: o,
      background: a,
      colorValue: r,
      handleDrag: u,
      update: i,
      ns: t
    };
  }
}), vg = /* @__PURE__ */ H("div", null, null, -1), mg = [
  vg
];
function gg(e, t, n, l, o, a) {
  return E(), _("div", {
    class: $(e.ns.b()),
    style: ye({
      backgroundColor: e.background
    })
  }, [
    H("div", {
      class: $(e.ns.e("white"))
    }, null, 2),
    H("div", {
      class: $(e.ns.e("black"))
    }, null, 2),
    H("div", {
      class: $(e.ns.e("cursor")),
      style: ye({
        top: e.cursorTop + "px",
        left: e.cursorLeft + "px"
      })
    }, mg, 6)
  ], 6);
}
var yg = /* @__PURE__ */ de(hg, [["render", gg], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/sv-panel.vue"]]);
const bg = ["id", "aria-label", "aria-labelledby", "aria-description", "tabindex", "onKeydown"], Cg = F({
  name: "ElColorPicker"
}), wg = /* @__PURE__ */ F({
  ...Cg,
  props: sg,
  emits: ag,
  setup(e, { expose: t, emit: n }) {
    const l = e, { t: o } = ot(), a = se("color"), { formItem: r } = kl(), i = dn(), u = Pn(), { inputId: c, isLabeledByFormItem: p } = jo(l, {
      formItemContext: r
    }), d = N(), f = N(), h = N(), v = N();
    let m = !0;
    const g = ct(new Pl({
      enableAlpha: l.showAlpha,
      format: l.colorFormat || "",
      value: l.modelValue
    })), w = N(!1), C = N(!1), y = N(""), b = k(() => !l.modelValue && !C.value ? "transparent" : R(g, l.showAlpha)), S = k(() => !l.modelValue && !C.value ? "" : g.value), T = k(() => p.value ? void 0 : l.label || o("el.colorpicker.defaultLabel")), O = k(() => p.value ? r == null ? void 0 : r.labelId : void 0), I = k(() => [
      a.b("picker"),
      a.is("disabled", u.value),
      a.bm("picker", i.value)
    ]);
    function R(P, L) {
      if (!(P instanceof Pl))
        throw new TypeError("color should be instance of _color Class");
      const { r: U, g: oe, b: le } = P.toRgb();
      return L ? `rgba(${U}, ${oe}, ${le}, ${P.get("alpha") / 100})` : `rgb(${U}, ${oe}, ${le})`;
    }
    function B(P) {
      w.value = P;
    }
    const D = Gt(B, 100);
    function A() {
      D(!1), z();
    }
    function z() {
      Ne(() => {
        l.modelValue ? g.fromString(l.modelValue) : (g.value = "", Ne(() => {
          C.value = !1;
        }));
      });
    }
    function Z() {
      u.value || D(!w.value);
    }
    function J() {
      g.fromString(y.value);
    }
    function V() {
      const P = g.value;
      n(et, P), n("change", P), l.validateEvent && (r == null || r.validate("change").catch((L) => pt(L))), D(!1), Ne(() => {
        const L = new Pl({
          enableAlpha: l.showAlpha,
          format: l.colorFormat || "",
          value: l.modelValue
        });
        g.compare(L) || z();
      });
    }
    function M() {
      D(!1), n(et, null), n("change", null), l.modelValue !== null && l.validateEvent && (r == null || r.validate("change").catch((P) => pt(P))), z();
    }
    return We(() => {
      l.modelValue && (y.value = S.value);
    }), ue(() => l.modelValue, (P) => {
      P ? P && P !== g.value && (m = !1, g.fromString(P)) : C.value = !1;
    }), ue(() => S.value, (P) => {
      y.value = P, m && n("activeChange", P), m = !0;
    }), ue(() => g.value, () => {
      !l.modelValue && !C.value && (C.value = !0);
    }), ue(() => w.value, () => {
      Ne(() => {
        var P, L, U;
        (P = d.value) == null || P.update(), (L = f.value) == null || L.update(), (U = h.value) == null || U.update();
      });
    }), tt(Ou, {
      currentColor: S
    }), t({
      color: g
    }), (P, L) => (E(), q(s(Wt), {
      ref_key: "popper",
      ref: v,
      visible: w.value,
      "show-arrow": !1,
      "fallback-placements": ["bottom", "top", "right", "left"],
      offset: 0,
      "gpu-acceleration": !1,
      "popper-class": [s(a).be("picker", "panel"), s(a).b("dropdown"), P.popperClass],
      "stop-popper-mouse-event": !1,
      effect: "light",
      trigger: "click",
      transition: `${s(a).namespace.value}-zoom-in-top`,
      persistent: ""
    }, {
      content: K(() => [
        qe((E(), _("div", null, [
          H("div", {
            class: $(s(a).be("dropdown", "main-wrapper"))
          }, [
            x(og, {
              ref_key: "hue",
              ref: d,
              class: "hue-slider",
              color: s(g),
              vertical: ""
            }, null, 8, ["color"]),
            x(yg, {
              ref: "svPanel",
              color: s(g)
            }, null, 8, ["color"])
          ], 2),
          P.showAlpha ? (E(), q(tg, {
            key: 0,
            ref_key: "alpha",
            ref: h,
            color: s(g)
          }, null, 8, ["color"])) : W("v-if", !0),
          P.predefine ? (E(), q(pg, {
            key: 1,
            ref: "predefine",
            color: s(g),
            colors: P.predefine
          }, null, 8, ["color", "colors"])) : W("v-if", !0),
          H("div", {
            class: $(s(a).be("dropdown", "btns"))
          }, [
            H("span", {
              class: $(s(a).be("dropdown", "value"))
            }, [
              x(s(Jn), {
                modelValue: y.value,
                "onUpdate:modelValue": L[0] || (L[0] = (U) => y.value = U),
                "validate-event": !1,
                size: "small",
                onKeyup: ut(J, ["enter"]),
                onBlur: J
              }, null, 8, ["modelValue", "onKeyup"])
            ], 2),
            x(s(Kt), {
              class: $(s(a).be("dropdown", "link-btn")),
              text: "",
              size: "small",
              onClick: M
            }, {
              default: K(() => [
                st(ce(s(o)("el.colorpicker.clear")), 1)
              ]),
              _: 1
            }, 8, ["class"]),
            x(s(Kt), {
              plain: "",
              size: "small",
              class: $(s(a).be("dropdown", "btn")),
              onClick: V
            }, {
              default: K(() => [
                st(ce(s(o)("el.colorpicker.confirm")), 1)
              ]),
              _: 1
            }, 8, ["class"])
          ], 2)
        ])), [
          [s(Wo), A]
        ])
      ]),
      default: K(() => [
        H("div", {
          id: s(c),
          class: $(s(I)),
          role: "button",
          "aria-label": s(T),
          "aria-labelledby": s(O),
          "aria-description": s(o)("el.colorpicker.description", { color: P.modelValue || "" }),
          tabindex: P.tabindex,
          onKeydown: ut(Z, ["enter"])
        }, [
          s(u) ? (E(), _("div", {
            key: 0,
            class: $(s(a).be("picker", "mask"))
          }, null, 2)) : W("v-if", !0),
          H("div", {
            class: $(s(a).be("picker", "trigger")),
            onClick: Z
          }, [
            H("span", {
              class: $([s(a).be("picker", "color"), s(a).is("alpha", P.showAlpha)])
            }, [
              H("span", {
                class: $(s(a).be("picker", "color-inner")),
                style: ye({
                  backgroundColor: s(b)
                })
              }, [
                qe(x(s(Se), {
                  class: $([s(a).be("picker", "icon"), s(a).is("icon-arrow-down")])
                }, {
                  default: K(() => [
                    x(s(Zl))
                  ]),
                  _: 1
                }, 8, ["class"]), [
                  [at, P.modelValue || C.value]
                ]),
                !P.modelValue && !C.value ? (E(), q(s(Se), {
                  key: 0,
                  class: $([s(a).be("picker", "empty"), s(a).is("icon-close")])
                }, {
                  default: K(() => [
                    x(s(Sl))
                  ]),
                  _: 1
                }, 8, ["class"])) : W("v-if", !0)
              ], 6)
            ], 2)
          ], 2)
        ], 42, bg)
      ]),
      _: 1
    }, 8, ["visible", "popper-class", "transition"]));
  }
});
var kg = /* @__PURE__ */ de(wg, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/color-picker.vue"]]);
const Sg = xe(kg), Eg = F({
  name: "ElContainer"
}), $g = /* @__PURE__ */ F({
  ...Eg,
  props: {
    direction: {
      type: String
    }
  },
  setup(e) {
    const t = e, n = kn(), l = se("container"), o = k(() => t.direction === "vertical" ? !0 : t.direction === "horizontal" ? !1 : n && n.default ? n.default().some((r) => {
      const i = r.type.name;
      return i === "ElHeader" || i === "ElFooter";
    }) : !1);
    return (a, r) => (E(), _("section", {
      class: $([s(l).b(), s(l).is("vertical", s(o))])
    }, [
      ne(a.$slots, "default")
    ], 2));
  }
});
var Tg = /* @__PURE__ */ de($g, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/container.vue"]]);
const Ng = F({
  name: "ElAside"
}), Ig = /* @__PURE__ */ F({
  ...Ng,
  props: {
    width: {
      type: String,
      default: null
    }
  },
  setup(e) {
    const t = e, n = se("aside"), l = k(() => t.width ? n.cssVarBlock({ width: t.width }) : {});
    return (o, a) => (E(), _("aside", {
      class: $(s(n).b()),
      style: ye(s(l))
    }, [
      ne(o.$slots, "default")
    ], 6));
  }
});
var Pu = /* @__PURE__ */ de(Ig, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/aside.vue"]]);
const Mg = F({
  name: "ElFooter"
}), Rg = /* @__PURE__ */ F({
  ...Mg,
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(e) {
    const t = e, n = se("footer"), l = k(() => t.height ? n.cssVarBlock({ height: t.height }) : {});
    return (o, a) => (E(), _("footer", {
      class: $(s(n).b()),
      style: ye(s(l))
    }, [
      ne(o.$slots, "default")
    ], 6));
  }
});
var Au = /* @__PURE__ */ de(Rg, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/footer.vue"]]);
const Og = F({
  name: "ElHeader"
}), Pg = /* @__PURE__ */ F({
  ...Og,
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(e) {
    const t = e, n = se("header"), l = k(() => t.height ? n.cssVarBlock({
      height: t.height
    }) : {});
    return (o, a) => (E(), _("header", {
      class: $(s(n).b()),
      style: ye(s(l))
    }, [
      ne(o.$slots, "default")
    ], 6));
  }
});
var _u = /* @__PURE__ */ de(Pg, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/header.vue"]]);
const Ag = F({
  name: "ElMain"
}), _g = /* @__PURE__ */ F({
  ...Ag,
  setup(e) {
    const t = se("main");
    return (n, l) => (E(), _("main", {
      class: $(s(t).b())
    }, [
      ne(n.$slots, "default")
    ], 2));
  }
});
var Lu = /* @__PURE__ */ de(_g, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/main.vue"]]);
const Lg = xe(Tg, {
  Aside: Pu,
  Footer: Au,
  Header: _u,
  Main: Lu
}), Vg = Rt(Pu), Bg = Rt(Au), Dg = Rt(_u), xg = Rt(Lu), Ea = Symbol("elDescriptions");
var Nl = F({
  name: "ElDescriptionsCell",
  props: {
    cell: {
      type: Object
    },
    tag: {
      type: String
    },
    type: {
      type: String
    }
  },
  setup() {
    return {
      descriptions: Oe(Ea, {})
    };
  },
  render() {
    var e, t, n, l, o, a;
    const r = gd(this.cell), { border: i, direction: u } = this.descriptions, c = u === "vertical", p = ((n = (t = (e = this.cell) == null ? void 0 : e.children) == null ? void 0 : t.label) == null ? void 0 : n.call(t)) || r.label, d = (a = (o = (l = this.cell) == null ? void 0 : l.children) == null ? void 0 : o.default) == null ? void 0 : a.call(o), f = r.span, h = r.align ? `is-${r.align}` : "", v = r.labelAlign ? `is-${r.labelAlign}` : h, m = r.className, g = r.labelClassName, w = {
      width: It(r.width),
      minWidth: It(r.minWidth)
    }, C = se("descriptions");
    switch (this.type) {
      case "label":
        return fe(this.tag, {
          style: w,
          class: [
            C.e("cell"),
            C.e("label"),
            C.is("bordered-label", i),
            C.is("vertical-label", c),
            v,
            g
          ],
          colSpan: c ? f : 1
        }, p);
      case "content":
        return fe(this.tag, {
          style: w,
          class: [
            C.e("cell"),
            C.e("content"),
            C.is("bordered-content", i),
            C.is("vertical-content", c),
            h,
            m
          ],
          colSpan: c ? f : f * 2 - 1
        }, d);
      default:
        return fe("td", {
          style: w,
          class: [C.e("cell"), h],
          colSpan: f
        }, [
          un(p) ? void 0 : fe("span", {
            class: [C.e("label"), g]
          }, p),
          fe("span", {
            class: [C.e("content"), m]
          }, d)
        ]);
    }
  }
});
const Fg = he({
  row: {
    type: Array,
    default: () => []
  }
}), Hg = { key: 1 }, zg = F({
  name: "ElDescriptionsRow"
}), Kg = /* @__PURE__ */ F({
  ...zg,
  props: Fg,
  setup(e) {
    const t = Oe(Ea, {});
    return (n, l) => s(t).direction === "vertical" ? (E(), _(Re, { key: 0 }, [
      H("tr", null, [
        (E(!0), _(Re, null, Xe(n.row, (o, a) => (E(), q(s(Nl), {
          key: `tr1-${a}`,
          cell: o,
          tag: "th",
          type: "label"
        }, null, 8, ["cell"]))), 128))
      ]),
      H("tr", null, [
        (E(!0), _(Re, null, Xe(n.row, (o, a) => (E(), q(s(Nl), {
          key: `tr2-${a}`,
          cell: o,
          tag: "td",
          type: "content"
        }, null, 8, ["cell"]))), 128))
      ])
    ], 64)) : (E(), _("tr", Hg, [
      (E(!0), _(Re, null, Xe(n.row, (o, a) => (E(), _(Re, {
        key: `tr3-${a}`
      }, [
        s(t).border ? (E(), _(Re, { key: 0 }, [
          x(s(Nl), {
            cell: o,
            tag: "td",
            type: "label"
          }, null, 8, ["cell"]),
          x(s(Nl), {
            cell: o,
            tag: "td",
            type: "content"
          }, null, 8, ["cell"])
        ], 64)) : (E(), q(s(Nl), {
          key: 1,
          cell: o,
          tag: "td",
          type: "both"
        }, null, 8, ["cell"]))
      ], 64))), 128))
    ]));
  }
});
var Wg = /* @__PURE__ */ de(Kg, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/descriptions-row.vue"]]);
const jg = he({
  border: {
    type: Boolean,
    default: !1
  },
  column: {
    type: Number,
    default: 3
  },
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  size: Cn,
  title: {
    type: String,
    default: ""
  },
  extra: {
    type: String,
    default: ""
  }
}), Ug = F({
  name: "ElDescriptions"
}), qg = /* @__PURE__ */ F({
  ...Ug,
  props: jg,
  setup(e) {
    const t = e, n = se("descriptions"), l = dn(), o = kn();
    tt(Ea, t);
    const a = k(() => [n.b(), n.m(l.value)]), r = (u, c, p, d = !1) => (u.props || (u.props = {}), c > p && (u.props.span = p), d && (u.props.span = c), u), i = () => {
      var u;
      const c = bi((u = o.default) == null ? void 0 : u.call(o)).filter((v) => {
        var m;
        return ((m = v == null ? void 0 : v.type) == null ? void 0 : m.name) === "ElDescriptionsItem";
      }), p = [];
      let d = [], f = t.column, h = 0;
      return c.forEach((v, m) => {
        var g;
        const w = ((g = v.props) == null ? void 0 : g.span) || 1;
        if (m < c.length - 1 && (h += w > f ? f : w), m === c.length - 1) {
          const C = t.column - h % t.column;
          d.push(r(v, C, f, !0)), p.push(d);
          return;
        }
        w < f ? (f -= w, d.push(v)) : (d.push(r(v, w, f)), p.push(d), f = t.column, d = []);
      }), p;
    };
    return (u, c) => (E(), _("div", {
      class: $(s(a))
    }, [
      u.title || u.extra || u.$slots.title || u.$slots.extra ? (E(), _("div", {
        key: 0,
        class: $(s(n).e("header"))
      }, [
        H("div", {
          class: $(s(n).e("title"))
        }, [
          ne(u.$slots, "title", {}, () => [
            st(ce(u.title), 1)
          ])
        ], 2),
        H("div", {
          class: $(s(n).e("extra"))
        }, [
          ne(u.$slots, "extra", {}, () => [
            st(ce(u.extra), 1)
          ])
        ], 2)
      ], 2)) : W("v-if", !0),
      H("div", {
        class: $(s(n).e("body"))
      }, [
        H("table", {
          class: $([s(n).e("table"), s(n).is("bordered", u.border)])
        }, [
          H("tbody", null, [
            (E(!0), _(Re, null, Xe(i(), (p, d) => (E(), q(Wg, {
              key: d,
              row: p
            }, null, 8, ["row"]))), 128))
          ])
        ], 2)
      ], 2)
    ], 2));
  }
});
var Gg = /* @__PURE__ */ de(qg, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/description.vue"]]), Vu = F({
  name: "ElDescriptionsItem",
  props: {
    label: {
      type: String,
      default: ""
    },
    span: {
      type: Number,
      default: 1
    },
    width: {
      type: [String, Number],
      default: ""
    },
    minWidth: {
      type: [String, Number],
      default: ""
    },
    align: {
      type: String,
      default: "left"
    },
    labelAlign: {
      type: String,
      default: ""
    },
    className: {
      type: String,
      default: ""
    },
    labelClassName: {
      type: String,
      default: ""
    }
  }
});
const Yg = xe(Gg, {
  DescriptionsItem: Vu
}), Xg = Rt(Vu), Zg = he({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  contentPosition: {
    type: String,
    values: ["left", "center", "right"],
    default: "center"
  },
  borderStyle: {
    type: j(String),
    default: "solid"
  }
}), Jg = F({
  name: "ElDivider"
}), Qg = /* @__PURE__ */ F({
  ...Jg,
  props: Zg,
  setup(e) {
    const t = e, n = se("divider"), l = k(() => n.cssVar({
      "border-style": t.borderStyle
    }));
    return (o, a) => (E(), _("div", {
      class: $([s(n).b(), s(n).m(o.direction)]),
      style: ye(s(l)),
      role: "separator"
    }, [
      o.$slots.default && o.direction !== "vertical" ? (E(), _("div", {
        key: 0,
        class: $([s(n).e("text"), s(n).is(o.contentPosition)])
      }, [
        ne(o.$slots, "default")
      ], 2)) : W("v-if", !0)
    ], 6));
  }
});
var ey = /* @__PURE__ */ de(Qg, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/divider/src/divider.vue"]]);
const Bu = xe(ey), ty = he({
  ...yd,
  direction: {
    type: String,
    default: "rtl",
    values: ["ltr", "rtl", "ttb", "btt"]
  },
  size: {
    type: [String, Number],
    default: "30%"
  },
  withHeader: {
    type: Boolean,
    default: !0
  },
  modalFade: {
    type: Boolean,
    default: !0
  }
}), ny = bd, ly = F({
  name: "ElDrawer",
  components: {
    ElOverlay: Ci,
    ElFocusTrap: wi,
    ElIcon: Se,
    Close: Sl
  },
  inheritAttrs: !1,
  props: ty,
  emits: ny,
  setup(e, { slots: t }) {
    Ll({
      scope: "el-drawer",
      from: "the title slot",
      replacement: "the header slot",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/drawer.html#slots"
    }, k(() => !!t.title)), Ll({
      scope: "el-drawer",
      from: "custom-class",
      replacement: "class",
      version: "2.3.0",
      ref: "https://element-plus.org/en-US/component/drawer.html#attributes",
      type: "Attribute"
    }, k(() => !!e.customClass));
    const n = N(), l = N(), o = se("drawer"), { t: a } = ot(), r = k(() => e.direction === "rtl" || e.direction === "ltr"), i = k(() => It(e.size));
    return {
      ...Cd(e, n),
      drawerRef: n,
      focusStartRef: l,
      isHorizontal: r,
      drawerSize: i,
      ns: o,
      t: a
    };
  }
}), oy = ["aria-label", "aria-labelledby", "aria-describedby"], sy = ["id"], ay = ["aria-label"], ry = ["id"];
function iy(e, t, n, l, o, a) {
  const r = $e("close"), i = $e("el-icon"), u = $e("el-focus-trap"), c = $e("el-overlay");
  return E(), q(Go, {
    to: "body",
    disabled: !e.appendToBody
  }, [
    x(jt, {
      name: e.ns.b("fade"),
      onAfterEnter: e.afterEnter,
      onAfterLeave: e.afterLeave,
      onBeforeLeave: e.beforeLeave,
      persisted: ""
    }, {
      default: K(() => [
        qe(x(c, {
          mask: e.modal,
          "overlay-class": e.modalClass,
          "z-index": e.zIndex,
          onClick: e.onModalClick
        }, {
          default: K(() => [
            x(u, {
              loop: "",
              trapped: e.visible,
              "focus-trap-el": e.drawerRef,
              "focus-start-el": e.focusStartRef,
              onReleaseRequested: e.onCloseRequested
            }, {
              default: K(() => [
                H("div", Be({
                  ref: "drawerRef",
                  "aria-modal": "true",
                  "aria-label": e.title || void 0,
                  "aria-labelledby": e.title ? void 0 : e.titleId,
                  "aria-describedby": e.bodyId
                }, e.$attrs, {
                  class: [e.ns.b(), e.direction, e.visible && "open", e.customClass],
                  style: e.isHorizontal ? "width: " + e.drawerSize : "height: " + e.drawerSize,
                  role: "dialog",
                  onClick: t[1] || (t[1] = Ae(() => {
                  }, ["stop"]))
                }), [
                  H("span", {
                    ref: "focusStartRef",
                    class: $(e.ns.e("sr-focus")),
                    tabindex: "-1"
                  }, null, 2),
                  e.withHeader ? (E(), _("header", {
                    key: 0,
                    class: $(e.ns.e("header"))
                  }, [
                    e.$slots.title ? ne(e.$slots, "title", { key: 1 }, () => [
                      W(" DEPRECATED SLOT ")
                    ]) : ne(e.$slots, "header", {
                      key: 0,
                      close: e.handleClose,
                      titleId: e.titleId,
                      titleClass: e.ns.e("title")
                    }, () => [
                      e.$slots.title ? W("v-if", !0) : (E(), _("span", {
                        key: 0,
                        id: e.titleId,
                        role: "heading",
                        class: $(e.ns.e("title"))
                      }, ce(e.title), 11, sy))
                    ]),
                    e.showClose ? (E(), _("button", {
                      key: 2,
                      "aria-label": e.t("el.drawer.close"),
                      class: $(e.ns.e("close-btn")),
                      type: "button",
                      onClick: t[0] || (t[0] = (...p) => e.handleClose && e.handleClose(...p))
                    }, [
                      x(i, {
                        class: $(e.ns.e("close"))
                      }, {
                        default: K(() => [
                          x(r)
                        ]),
                        _: 1
                      }, 8, ["class"])
                    ], 10, ay)) : W("v-if", !0)
                  ], 2)) : W("v-if", !0),
                  e.rendered ? (E(), _("div", {
                    key: 1,
                    id: e.bodyId,
                    class: $(e.ns.e("body"))
                  }, [
                    ne(e.$slots, "default")
                  ], 10, ry)) : W("v-if", !0),
                  e.$slots.footer ? (E(), _("div", {
                    key: 2,
                    class: $(e.ns.e("footer"))
                  }, [
                    ne(e.$slots, "footer")
                  ], 2)) : W("v-if", !0)
                ], 16, oy)
              ]),
              _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
          ]),
          _: 3
        }, 8, ["mask", "overlay-class", "z-index", "onClick"]), [
          [at, e.visible]
        ])
      ]),
      _: 3
    }, 8, ["name", "onAfterEnter", "onAfterLeave", "onBeforeLeave"])
  ], 8, ["disabled"]);
}
var uy = /* @__PURE__ */ de(ly, [["render", iy], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/drawer/src/drawer.vue"]]);
const cy = xe(uy), dy = /* @__PURE__ */ F({
  inheritAttrs: !1
});
function fy(e, t, n, l, o, a) {
  return ne(e.$slots, "default");
}
var py = /* @__PURE__ */ de(dy, [["render", fy], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);
const hy = /* @__PURE__ */ F({
  name: "ElCollectionItem",
  inheritAttrs: !1
});
function vy(e, t, n, l, o, a) {
  return ne(e.$slots, "default");
}
var my = /* @__PURE__ */ de(hy, [["render", vy], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);
const Du = "data-el-collection-item", xu = (e) => {
  const t = `El${e}Collection`, n = `${t}Item`, l = Symbol(t), o = Symbol(n), a = {
    ...py,
    name: t,
    setup() {
      const i = N(null), u = /* @__PURE__ */ new Map();
      tt(l, {
        itemMap: u,
        getItems: () => {
          const p = s(i);
          if (!p)
            return [];
          const d = Array.from(p.querySelectorAll(`[${Du}]`));
          return [...u.values()].sort((h, v) => d.indexOf(h.ref) - d.indexOf(v.ref));
        },
        collectionRef: i
      });
    }
  }, r = {
    ...my,
    name: n,
    setup(i, { attrs: u }) {
      const c = N(null), p = Oe(l, void 0);
      tt(o, {
        collectionItemRef: c
      }), We(() => {
        const d = s(c);
        d && p.itemMap.set(d, {
          ref: d,
          ...u
        });
      }), Dt(() => {
        const d = s(c);
        p.itemMap.delete(d);
      });
    }
  };
  return {
    COLLECTION_INJECTION_KEY: l,
    COLLECTION_ITEM_INJECTION_KEY: o,
    ElCollection: a,
    ElCollectionItem: r
  };
}, gy = he({
  style: { type: j([String, Array, Object]) },
  currentTabId: {
    type: j(String)
  },
  defaultCurrentTabId: String,
  loop: Boolean,
  dir: {
    type: String,
    values: ["ltr", "rtl"],
    default: "ltr"
  },
  orientation: {
    type: j(String)
  },
  onBlur: Function,
  onFocus: Function,
  onMousedown: Function
}), {
  ElCollection: yy,
  ElCollectionItem: by,
  COLLECTION_INJECTION_KEY: $a,
  COLLECTION_ITEM_INJECTION_KEY: Cy
} = xu("RovingFocusGroup"), Ta = Symbol("elRovingFocusGroup"), Fu = Symbol("elRovingFocusGroupItem"), wy = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
}, ky = (e, t) => {
  if (t !== "rtl")
    return e;
  switch (e) {
    case Ce.right:
      return Ce.left;
    case Ce.left:
      return Ce.right;
    default:
      return e;
  }
}, Sy = (e, t, n) => {
  const l = ky(e.key, n);
  if (!(t === "vertical" && [Ce.left, Ce.right].includes(l)) && !(t === "horizontal" && [Ce.up, Ce.down].includes(l)))
    return wy[l];
}, Ey = (e, t) => e.map((n, l) => e[(l + t) % e.length]), Na = (e) => {
  const { activeElement: t } = document;
  for (const n of e)
    if (n === t || (n.focus(), t !== document.activeElement))
      return;
}, Mr = "currentTabIdChange", Rr = "rovingFocusGroup.entryFocus", $y = { bubbles: !1, cancelable: !0 }, Ty = F({
  name: "ElRovingFocusGroupImpl",
  inheritAttrs: !1,
  props: gy,
  emits: [Mr, "entryFocus"],
  setup(e, { emit: t }) {
    var n;
    const l = N((n = e.currentTabId || e.defaultCurrentTabId) != null ? n : null), o = N(!1), a = N(!1), r = N(null), { getItems: i } = Oe($a, void 0), u = k(() => [
      {
        outline: "none"
      },
      e.style
    ]), c = (m) => {
      t(Mr, m);
    }, p = () => {
      o.value = !0;
    }, d = $t((m) => {
      var g;
      (g = e.onMousedown) == null || g.call(e, m);
    }, () => {
      a.value = !0;
    }), f = $t((m) => {
      var g;
      (g = e.onFocus) == null || g.call(e, m);
    }, (m) => {
      const g = !s(a), { target: w, currentTarget: C } = m;
      if (w === C && g && !s(o)) {
        const y = new Event(Rr, $y);
        if (C == null || C.dispatchEvent(y), !y.defaultPrevented) {
          const b = i().filter((R) => R.focusable), S = b.find((R) => R.active), T = b.find((R) => R.id === s(l)), I = [S, T, ...b].filter(Boolean).map((R) => R.ref);
          Na(I);
        }
      }
      a.value = !1;
    }), h = $t((m) => {
      var g;
      (g = e.onBlur) == null || g.call(e, m);
    }, () => {
      o.value = !1;
    }), v = (...m) => {
      t("entryFocus", ...m);
    };
    tt(Ta, {
      currentTabbedId: Ef(l),
      loop: tn(e, "loop"),
      tabIndex: k(() => s(o) ? -1 : 0),
      rovingFocusGroupRef: r,
      rovingFocusGroupRootStyle: u,
      orientation: tn(e, "orientation"),
      dir: tn(e, "dir"),
      onItemFocus: c,
      onItemShiftTab: p,
      onBlur: h,
      onFocus: f,
      onMousedown: d
    }), ue(() => e.currentTabId, (m) => {
      l.value = m != null ? m : null;
    }), Nt(r, Rr, v);
  }
});
function Ny(e, t, n, l, o, a) {
  return ne(e.$slots, "default");
}
var Iy = /* @__PURE__ */ de(Ty, [["render", Ny], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group-impl.vue"]]);
const My = F({
  name: "ElRovingFocusGroup",
  components: {
    ElFocusGroupCollection: yy,
    ElRovingFocusGroupImpl: Iy
  }
});
function Ry(e, t, n, l, o, a) {
  const r = $e("el-roving-focus-group-impl"), i = $e("el-focus-group-collection");
  return E(), q(i, null, {
    default: K(() => [
      x(r, Zt(da(e.$attrs)), {
        default: K(() => [
          ne(e.$slots, "default")
        ]),
        _: 3
      }, 16)
    ]),
    _: 3
  });
}
var Oy = /* @__PURE__ */ de(My, [["render", Ry], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group.vue"]]);
const Py = F({
  components: {
    ElRovingFocusCollectionItem: by
  },
  props: {
    focusable: {
      type: Boolean,
      default: !0
    },
    active: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["mousedown", "focus", "keydown"],
  setup(e, { emit: t }) {
    const { currentTabbedId: n, loop: l, onItemFocus: o, onItemShiftTab: a } = Oe(Ta, void 0), { getItems: r } = Oe($a, void 0), i = pl(), u = N(null), c = $t((h) => {
      t("mousedown", h);
    }, (h) => {
      e.focusable ? o(s(i)) : h.preventDefault();
    }), p = $t((h) => {
      t("focus", h);
    }, () => {
      o(s(i));
    }), d = $t((h) => {
      t("keydown", h);
    }, (h) => {
      const { key: v, shiftKey: m, target: g, currentTarget: w } = h;
      if (v === Ce.tab && m) {
        a();
        return;
      }
      if (g !== w)
        return;
      const C = Sy(h);
      if (C) {
        h.preventDefault();
        let b = r().filter((S) => S.focusable).map((S) => S.ref);
        switch (C) {
          case "last": {
            b.reverse();
            break;
          }
          case "prev":
          case "next": {
            C === "prev" && b.reverse();
            const S = b.indexOf(w);
            b = l.value ? Ey(b, S + 1) : b.slice(S + 1);
            break;
          }
        }
        Ne(() => {
          Na(b);
        });
      }
    }), f = k(() => n.value === s(i));
    return tt(Fu, {
      rovingFocusGroupItemRef: u,
      tabIndex: k(() => s(f) ? 0 : -1),
      handleMousedown: c,
      handleFocus: p,
      handleKeydown: d
    }), {
      id: i,
      handleKeydown: d,
      handleFocus: p,
      handleMousedown: c
    };
  }
});
function Ay(e, t, n, l, o, a) {
  const r = $e("el-roving-focus-collection-item");
  return E(), q(r, {
    id: e.id,
    focusable: e.focusable,
    active: e.active
  }, {
    default: K(() => [
      ne(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["id", "focusable", "active"]);
}
var _y = /* @__PURE__ */ de(Py, [["render", Ay], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-item.vue"]]);
const yo = he({
  trigger: ys.trigger,
  effect: {
    ...Pt.effect,
    default: "light"
  },
  type: {
    type: j(String)
  },
  placement: {
    type: j(String),
    default: "bottom"
  },
  popperOptions: {
    type: j(Object),
    default: () => ({})
  },
  id: String,
  size: {
    type: String,
    default: ""
  },
  splitButton: Boolean,
  hideOnClick: {
    type: Boolean,
    default: !0
  },
  loop: {
    type: Boolean,
    default: !0
  },
  showTimeout: {
    type: Number,
    default: 150
  },
  hideTimeout: {
    type: Number,
    default: 150
  },
  tabindex: {
    type: j([Number, String]),
    default: 0
  },
  maxHeight: {
    type: j([Number, String]),
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  role: {
    type: String,
    default: "menu"
  },
  buttonProps: {
    type: j(Object)
  },
  teleported: Pt.teleported
}), Hu = he({
  command: {
    type: [Object, String, Number],
    default: () => ({})
  },
  disabled: Boolean,
  divided: Boolean,
  textValue: String,
  icon: {
    type: ft
  }
}), Ly = he({
  onKeydown: { type: j(Function) }
}), Vy = [
  Ce.down,
  Ce.pageDown,
  Ce.home
], zu = [Ce.up, Ce.pageUp, Ce.end], By = [...Vy, ...zu], {
  ElCollection: Dy,
  ElCollectionItem: xy,
  COLLECTION_INJECTION_KEY: Fy,
  COLLECTION_ITEM_INJECTION_KEY: Hy
} = xu("Dropdown"), Qo = Symbol("elDropdown"), { ButtonGroup: zy } = Kt, Ky = F({
  name: "ElDropdown",
  components: {
    ElButton: Kt,
    ElButtonGroup: zy,
    ElScrollbar: Zn,
    ElDropdownCollection: Dy,
    ElTooltip: Wt,
    ElRovingFocusGroup: Oy,
    ElOnlyChild: wd,
    ElIcon: Se,
    ArrowDown: Zl
  },
  props: yo,
  emits: ["visible-change", "click", "command"],
  setup(e, { emit: t }) {
    const n = je(), l = se("dropdown"), { t: o } = ot(), a = N(), r = N(), i = N(null), u = N(null), c = N(null), p = N(null), d = N(!1), f = [Ce.enter, Ce.space, Ce.down], h = k(() => ({
      maxHeight: It(e.maxHeight)
    })), v = k(() => [l.m(b.value)]), m = pl().value, g = k(() => e.id || m);
    ue([a, tn(e, "trigger")], ([V, M], [P]) => {
      var L, U, oe;
      const le = Je(M) ? M : [M];
      (L = P == null ? void 0 : P.$el) != null && L.removeEventListener && P.$el.removeEventListener("pointerenter", T), (U = V == null ? void 0 : V.$el) != null && U.removeEventListener && V.$el.removeEventListener("pointerenter", T), ((oe = V == null ? void 0 : V.$el) == null ? void 0 : oe.addEventListener) && le.includes("hover") && V.$el.addEventListener("pointerenter", T);
    }, { immediate: !0 }), Dt(() => {
      var V, M;
      (M = (V = a.value) == null ? void 0 : V.$el) != null && M.removeEventListener && a.value.$el.removeEventListener("pointerenter", T);
    });
    function w() {
      C();
    }
    function C() {
      var V;
      (V = i.value) == null || V.onClose();
    }
    function y() {
      var V;
      (V = i.value) == null || V.onOpen();
    }
    const b = dn();
    function S(...V) {
      t("command", ...V);
    }
    function T() {
      var V, M;
      (M = (V = a.value) == null ? void 0 : V.$el) == null || M.focus();
    }
    function O() {
    }
    function I() {
      const V = s(u);
      V == null || V.focus(), p.value = null;
    }
    function R(V) {
      p.value = V;
    }
    function B(V) {
      d.value || (V.preventDefault(), V.stopImmediatePropagation());
    }
    function D() {
      t("visible-change", !0);
    }
    function A(V) {
      (V == null ? void 0 : V.type) === "keydown" && u.value.focus();
    }
    function z() {
      t("visible-change", !1);
    }
    return tt(Qo, {
      contentRef: u,
      role: k(() => e.role),
      triggerId: g,
      isUsingKeyboard: d,
      onItemEnter: O,
      onItemLeave: I
    }), tt("elDropdown", {
      instance: n,
      dropdownSize: b,
      handleClick: w,
      commandHandler: S,
      trigger: tn(e, "trigger"),
      hideOnClick: tn(e, "hideOnClick")
    }), {
      t: o,
      ns: l,
      scrollbar: c,
      wrapStyle: h,
      dropdownTriggerKls: v,
      dropdownSize: b,
      triggerId: g,
      triggerKeys: f,
      currentTabId: p,
      handleCurrentTabIdChange: R,
      handlerMainButtonClick: (V) => {
        t("click", V);
      },
      handleEntryFocus: B,
      handleClose: C,
      handleOpen: y,
      handleBeforeShowTooltip: D,
      handleShowTooltip: A,
      handleBeforeHideTooltip: z,
      onFocusAfterTrapped: (V) => {
        var M, P;
        V.preventDefault(), (P = (M = u.value) == null ? void 0 : M.focus) == null || P.call(M, {
          preventScroll: !0
        });
      },
      popperRef: i,
      contentRef: u,
      triggeringElementRef: a,
      referenceElementRef: r
    };
  }
});
function Wy(e, t, n, l, o, a) {
  var r;
  const i = $e("el-dropdown-collection"), u = $e("el-roving-focus-group"), c = $e("el-scrollbar"), p = $e("el-only-child"), d = $e("el-tooltip"), f = $e("el-button"), h = $e("arrow-down"), v = $e("el-icon"), m = $e("el-button-group");
  return E(), _("div", {
    class: $([e.ns.b(), e.ns.is("disabled", e.disabled)])
  }, [
    x(d, {
      ref: "popperRef",
      role: e.role,
      effect: e.effect,
      "fallback-placements": ["bottom", "top"],
      "popper-options": e.popperOptions,
      "gpu-acceleration": !1,
      "hide-after": e.trigger === "hover" ? e.hideTimeout : 0,
      "manual-mode": !0,
      placement: e.placement,
      "popper-class": [e.ns.e("popper"), e.popperClass],
      "reference-element": (r = e.referenceElementRef) == null ? void 0 : r.$el,
      trigger: e.trigger,
      "trigger-keys": e.triggerKeys,
      "trigger-target-el": e.contentRef,
      "show-after": e.trigger === "hover" ? e.showTimeout : 0,
      "stop-popper-mouse-event": !1,
      "virtual-ref": e.triggeringElementRef,
      "virtual-triggering": e.splitButton,
      disabled: e.disabled,
      transition: `${e.ns.namespace.value}-zoom-in-top`,
      teleported: e.teleported,
      pure: "",
      persistent: "",
      onBeforeShow: e.handleBeforeShowTooltip,
      onShow: e.handleShowTooltip,
      onBeforeHide: e.handleBeforeHideTooltip
    }, Yn({
      content: K(() => [
        x(c, {
          ref: "scrollbar",
          "wrap-style": e.wrapStyle,
          tag: "div",
          "view-class": e.ns.e("list")
        }, {
          default: K(() => [
            x(u, {
              loop: e.loop,
              "current-tab-id": e.currentTabId,
              orientation: "horizontal",
              onCurrentTabIdChange: e.handleCurrentTabIdChange,
              onEntryFocus: e.handleEntryFocus
            }, {
              default: K(() => [
                x(i, null, {
                  default: K(() => [
                    ne(e.$slots, "dropdown")
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"])
          ]),
          _: 3
        }, 8, ["wrap-style", "view-class"])
      ]),
      _: 2
    }, [
      e.splitButton ? void 0 : {
        name: "default",
        fn: K(() => [
          x(p, {
            id: e.triggerId,
            ref: "triggeringElementRef",
            role: "button",
            tabindex: e.tabindex
          }, {
            default: K(() => [
              ne(e.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "tabindex"])
        ])
      }
    ]), 1032, ["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "teleported", "onBeforeShow", "onShow", "onBeforeHide"]),
    e.splitButton ? (E(), q(m, { key: 0 }, {
      default: K(() => [
        x(f, Be({ ref: "referenceElementRef" }, e.buttonProps, {
          size: e.dropdownSize,
          type: e.type,
          disabled: e.disabled,
          tabindex: e.tabindex,
          onClick: e.handlerMainButtonClick
        }), {
          default: K(() => [
            ne(e.$slots, "default")
          ]),
          _: 3
        }, 16, ["size", "type", "disabled", "tabindex", "onClick"]),
        x(f, Be({
          id: e.triggerId,
          ref: "triggeringElementRef"
        }, e.buttonProps, {
          role: "button",
          size: e.dropdownSize,
          type: e.type,
          class: e.ns.e("caret-button"),
          disabled: e.disabled,
          tabindex: e.tabindex,
          "aria-label": e.t("el.dropdown.toggleDropdown")
        }), {
          default: K(() => [
            x(v, {
              class: $(e.ns.e("icon"))
            }, {
              default: K(() => [
                x(h)
              ]),
              _: 1
            }, 8, ["class"])
          ]),
          _: 1
        }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])
      ]),
      _: 3
    })) : W("v-if", !0)
  ], 2);
}
var jy = /* @__PURE__ */ de(Ky, [["render", Wy], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown.vue"]]);
const Uy = F({
  name: "DropdownItemImpl",
  components: {
    ElIcon: Se
  },
  props: Hu,
  emits: ["pointermove", "pointerleave", "click", "clickimpl"],
  setup(e, { emit: t }) {
    const n = se("dropdown"), { role: l } = Oe(Qo, void 0), { collectionItemRef: o } = Oe(Hy, void 0), { collectionItemRef: a } = Oe(Cy, void 0), {
      rovingFocusGroupItemRef: r,
      tabIndex: i,
      handleFocus: u,
      handleKeydown: c,
      handleMousedown: p
    } = Oe(Fu, void 0), d = aa(o, a, r), f = k(() => l.value === "menu" ? "menuitem" : l.value === "navigation" ? "link" : "button"), h = $t((v) => {
      const { code: m } = v;
      if (m === Ce.enter || m === Ce.space)
        return v.preventDefault(), v.stopImmediatePropagation(), t("clickimpl", v), !0;
    }, c);
    return {
      ns: n,
      itemRef: d,
      dataset: {
        [Du]: ""
      },
      role: f,
      tabIndex: i,
      handleFocus: u,
      handleKeydown: h,
      handleMousedown: p
    };
  }
}), qy = ["aria-disabled", "tabindex", "role"];
function Gy(e, t, n, l, o, a) {
  const r = $e("el-icon");
  return E(), _(Re, null, [
    e.divided ? (E(), _("li", Be({
      key: 0,
      role: "separator",
      class: e.ns.bem("menu", "item", "divided")
    }, e.$attrs), null, 16)) : W("v-if", !0),
    H("li", Be({ ref: e.itemRef }, { ...e.dataset, ...e.$attrs }, {
      "aria-disabled": e.disabled,
      class: [e.ns.be("menu", "item"), e.ns.is("disabled", e.disabled)],
      tabindex: e.tabIndex,
      role: e.role,
      onClick: t[0] || (t[0] = (i) => e.$emit("clickimpl", i)),
      onFocus: t[1] || (t[1] = (...i) => e.handleFocus && e.handleFocus(...i)),
      onKeydown: t[2] || (t[2] = Ae((...i) => e.handleKeydown && e.handleKeydown(...i), ["self"])),
      onMousedown: t[3] || (t[3] = (...i) => e.handleMousedown && e.handleMousedown(...i)),
      onPointermove: t[4] || (t[4] = (i) => e.$emit("pointermove", i)),
      onPointerleave: t[5] || (t[5] = (i) => e.$emit("pointerleave", i))
    }), [
      e.icon ? (E(), q(r, { key: 0 }, {
        default: K(() => [
          (E(), q(Ge(e.icon)))
        ]),
        _: 1
      })) : W("v-if", !0),
      ne(e.$slots, "default")
    ], 16, qy)
  ], 64);
}
var Yy = /* @__PURE__ */ de(Uy, [["render", Gy], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item-impl.vue"]]);
const Ku = () => {
  const e = Oe("elDropdown", {}), t = k(() => e == null ? void 0 : e.dropdownSize);
  return {
    elDropdown: e,
    _elDropdownSize: t
  };
}, Xy = F({
  name: "ElDropdownItem",
  components: {
    ElDropdownCollectionItem: xy,
    ElRovingFocusItem: _y,
    ElDropdownItemImpl: Yy
  },
  inheritAttrs: !1,
  props: Hu,
  emits: ["pointermove", "pointerleave", "click"],
  setup(e, { emit: t, attrs: n }) {
    const { elDropdown: l } = Ku(), o = je(), a = N(null), r = k(() => {
      var h, v;
      return (v = (h = s(a)) == null ? void 0 : h.textContent) != null ? v : "";
    }), { onItemEnter: i, onItemLeave: u } = Oe(Qo, void 0), c = $t((h) => (t("pointermove", h), h.defaultPrevented), Qa((h) => {
      if (e.disabled) {
        u(h);
        return;
      }
      const v = h.currentTarget;
      v === document.activeElement || v.contains(document.activeElement) || (i(h), h.defaultPrevented || v == null || v.focus());
    })), p = $t((h) => (t("pointerleave", h), h.defaultPrevented), Qa((h) => {
      u(h);
    })), d = $t((h) => {
      if (!e.disabled)
        return t("click", h), h.type !== "keydown" && h.defaultPrevented;
    }, (h) => {
      var v, m, g;
      if (e.disabled) {
        h.stopImmediatePropagation();
        return;
      }
      (v = l == null ? void 0 : l.hideOnClick) != null && v.value && ((m = l.handleClick) == null || m.call(l)), (g = l.commandHandler) == null || g.call(l, e.command, o, h);
    }), f = k(() => ({ ...e, ...n }));
    return {
      handleClick: d,
      handlePointerMove: c,
      handlePointerLeave: p,
      textContent: r,
      propsAndAttrs: f
    };
  }
});
function Zy(e, t, n, l, o, a) {
  var r;
  const i = $e("el-dropdown-item-impl"), u = $e("el-roving-focus-item"), c = $e("el-dropdown-collection-item");
  return E(), q(c, {
    disabled: e.disabled,
    "text-value": (r = e.textValue) != null ? r : e.textContent
  }, {
    default: K(() => [
      x(u, {
        focusable: !e.disabled
      }, {
        default: K(() => [
          x(i, Be(e.propsAndAttrs, {
            onPointerleave: e.handlePointerLeave,
            onPointermove: e.handlePointerMove,
            onClickimpl: e.handleClick
          }), {
            default: K(() => [
              ne(e.$slots, "default")
            ]),
            _: 3
          }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])
        ]),
        _: 3
      }, 8, ["focusable"])
    ]),
    _: 3
  }, 8, ["disabled", "text-value"]);
}
var Wu = /* @__PURE__ */ de(Xy, [["render", Zy], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item.vue"]]);
const Jy = F({
  name: "ElDropdownMenu",
  props: Ly,
  setup(e) {
    const t = se("dropdown"), { _elDropdownSize: n } = Ku(), l = n.value, { focusTrapRef: o, onKeydown: a } = Oe(kd, void 0), { contentRef: r, role: i, triggerId: u } = Oe(Qo, void 0), { collectionRef: c, getItems: p } = Oe(Fy, void 0), {
      rovingFocusGroupRef: d,
      rovingFocusGroupRootStyle: f,
      tabIndex: h,
      onBlur: v,
      onFocus: m,
      onMousedown: g
    } = Oe(Ta, void 0), { collectionRef: w } = Oe($a, void 0), C = k(() => [t.b("menu"), t.bm("menu", l == null ? void 0 : l.value)]), y = aa(r, c, o, d, w), b = $t((T) => {
      var O;
      (O = e.onKeydown) == null || O.call(e, T);
    }, (T) => {
      const { currentTarget: O, code: I, target: R } = T;
      if (O.contains(R), Ce.tab === I && T.stopImmediatePropagation(), T.preventDefault(), R !== s(r) || !By.includes(I))
        return;
      const D = p().filter((A) => !A.disabled).map((A) => A.ref);
      zu.includes(I) && D.reverse(), Na(D);
    });
    return {
      size: l,
      rovingFocusGroupRootStyle: f,
      tabIndex: h,
      dropdownKls: C,
      role: i,
      triggerId: u,
      dropdownListWrapperRef: y,
      handleKeydown: (T) => {
        b(T), a(T);
      },
      onBlur: v,
      onFocus: m,
      onMousedown: g
    };
  }
}), Qy = ["role", "aria-labelledby"];
function eb(e, t, n, l, o, a) {
  return E(), _("ul", {
    ref: e.dropdownListWrapperRef,
    class: $(e.dropdownKls),
    style: ye(e.rovingFocusGroupRootStyle),
    tabindex: -1,
    role: e.role,
    "aria-labelledby": e.triggerId,
    onBlur: t[0] || (t[0] = (...r) => e.onBlur && e.onBlur(...r)),
    onFocus: t[1] || (t[1] = (...r) => e.onFocus && e.onFocus(...r)),
    onKeydown: t[2] || (t[2] = Ae((...r) => e.handleKeydown && e.handleKeydown(...r), ["self"])),
    onMousedown: t[3] || (t[3] = Ae((...r) => e.onMousedown && e.onMousedown(...r), ["self"]))
  }, [
    ne(e.$slots, "default")
  ], 46, Qy);
}
var ju = /* @__PURE__ */ de(Jy, [["render", eb], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-menu.vue"]]);
const tb = xe(jy, {
  DropdownItem: Wu,
  DropdownMenu: ju
}), nb = Rt(Wu), lb = Rt(ju), ob = {
  viewBox: "0 0 79 86",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
}, sb = ["id"], ab = ["stop-color"], rb = ["stop-color"], ib = ["id"], ub = ["stop-color"], cb = ["stop-color"], db = ["id"], fb = {
  id: "Illustrations",
  stroke: "none",
  "stroke-width": "1",
  fill: "none",
  "fill-rule": "evenodd"
}, pb = {
  id: "B-type",
  transform: "translate(-1268.000000, -535.000000)"
}, hb = {
  id: "Group-2",
  transform: "translate(1268.000000, 535.000000)"
}, vb = ["fill"], mb = ["fill"], gb = {
  id: "Group-Copy",
  transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)"
}, yb = ["fill"], bb = ["fill"], Cb = ["fill"], wb = ["fill"], kb = ["fill"], Sb = {
  id: "Rectangle-Copy-17",
  transform: "translate(53.000000, 45.000000)"
}, Eb = ["fill", "xlink:href"], $b = ["fill", "mask"], Tb = ["fill"], Nb = F({
  name: "ImgEmpty"
}), Ib = /* @__PURE__ */ F({
  ...Nb,
  setup(e) {
    const t = se("empty"), n = pl();
    return (l, o) => (E(), _("svg", ob, [
      H("defs", null, [
        H("linearGradient", {
          id: `linearGradient-1-${s(n)}`,
          x1: "38.8503086%",
          y1: "0%",
          x2: "61.1496914%",
          y2: "100%"
        }, [
          H("stop", {
            "stop-color": `var(${s(t).cssVarBlockName("fill-color-1")})`,
            offset: "0%"
          }, null, 8, ab),
          H("stop", {
            "stop-color": `var(${s(t).cssVarBlockName("fill-color-4")})`,
            offset: "100%"
          }, null, 8, rb)
        ], 8, sb),
        H("linearGradient", {
          id: `linearGradient-2-${s(n)}`,
          x1: "0%",
          y1: "9.5%",
          x2: "100%",
          y2: "90.5%"
        }, [
          H("stop", {
            "stop-color": `var(${s(t).cssVarBlockName("fill-color-1")})`,
            offset: "0%"
          }, null, 8, ub),
          H("stop", {
            "stop-color": `var(${s(t).cssVarBlockName("fill-color-6")})`,
            offset: "100%"
          }, null, 8, cb)
        ], 8, ib),
        H("rect", {
          id: `path-3-${s(n)}`,
          x: "0",
          y: "0",
          width: "17",
          height: "36"
        }, null, 8, db)
      ]),
      H("g", fb, [
        H("g", pb, [
          H("g", hb, [
            H("path", {
              id: "Oval-Copy-2",
              d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
              fill: `var(${s(t).cssVarBlockName("fill-color-3")})`
            }, null, 8, vb),
            H("polygon", {
              id: "Rectangle-Copy-14",
              fill: `var(${s(t).cssVarBlockName("fill-color-7")})`,
              transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
              points: "13 58 53 58 42 45 2 45"
            }, null, 8, mb),
            H("g", gb, [
              H("polygon", {
                id: "Rectangle-Copy-10",
                fill: `var(${s(t).cssVarBlockName("fill-color-7")})`,
                transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
                points: "2.84078316e-14 3 18 3 23 7 5 7"
              }, null, 8, yb),
              H("polygon", {
                id: "Rectangle-Copy-11",
                fill: `var(${s(t).cssVarBlockName("fill-color-5")})`,
                points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
              }, null, 8, bb),
              H("rect", {
                id: "Rectangle-Copy-12",
                fill: `url(#linearGradient-1-${s(n)})`,
                transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
                x: "38",
                y: "7",
                width: "17",
                height: "36"
              }, null, 8, Cb),
              H("polygon", {
                id: "Rectangle-Copy-13",
                fill: `var(${s(t).cssVarBlockName("fill-color-2")})`,
                transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
                points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
              }, null, 8, wb)
            ]),
            H("rect", {
              id: "Rectangle-Copy-15",
              fill: `url(#linearGradient-2-${s(n)})`,
              x: "13",
              y: "45",
              width: "40",
              height: "36"
            }, null, 8, kb),
            H("g", Sb, [
              H("use", {
                id: "Mask",
                fill: `var(${s(t).cssVarBlockName("fill-color-8")})`,
                transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
                "xlink:href": `#path-3-${s(n)}`
              }, null, 8, Eb),
              H("polygon", {
                id: "Rectangle-Copy",
                fill: `var(${s(t).cssVarBlockName("fill-color-9")})`,
                mask: `url(#mask-4-${s(n)})`,
                transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
                points: "7 0 24 0 20 18 7 16.5"
              }, null, 8, $b)
            ]),
            H("polygon", {
              id: "Rectangle-Copy-18",
              fill: `var(${s(t).cssVarBlockName("fill-color-2")})`,
              transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
              points: "62 45 79 45 70 58 53 58"
            }, null, 8, Tb)
          ])
        ])
      ])
    ]));
  }
});
var Mb = /* @__PURE__ */ de(Ib, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/empty/src/img-empty.vue"]]);
const Rb = he({
  image: {
    type: String,
    default: ""
  },
  imageSize: Number,
  description: {
    type: String,
    default: ""
  }
}), Ob = ["src"], Pb = { key: 1 }, Ab = F({
  name: "ElEmpty"
}), _b = /* @__PURE__ */ F({
  ...Ab,
  props: Rb,
  setup(e) {
    const t = e, { t: n } = ot(), l = se("empty"), o = k(() => t.description || n("el.table.emptyText")), a = k(() => ({
      width: It(t.imageSize)
    }));
    return (r, i) => (E(), _("div", {
      class: $(s(l).b())
    }, [
      H("div", {
        class: $(s(l).e("image")),
        style: ye(s(a))
      }, [
        r.image ? (E(), _("img", {
          key: 0,
          src: r.image,
          ondragstart: "return false"
        }, null, 8, Ob)) : ne(r.$slots, "image", { key: 1 }, () => [
          x(Mb)
        ])
      ], 6),
      H("div", {
        class: $(s(l).e("description"))
      }, [
        r.$slots.description ? ne(r.$slots, "description", { key: 0 }) : (E(), _("p", Pb, ce(s(o)), 1))
      ], 2),
      r.$slots.default ? (E(), _("div", {
        key: 0,
        class: $(s(l).e("bottom"))
      }, [
        ne(r.$slots, "default")
      ], 2)) : W("v-if", !0)
    ], 2));
  }
});
var Lb = /* @__PURE__ */ de(_b, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/empty/src/empty.vue"]]);
const Uu = xe(Lb), Vb = he({
  urlList: {
    type: j(Array),
    default: () => Et([])
  },
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: !0
  },
  hideOnClickModal: {
    type: Boolean,
    default: !1
  },
  teleported: {
    type: Boolean,
    default: !1
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  zoomRate: {
    type: Number,
    default: 1.2
  }
}), Bb = {
  close: () => !0,
  switch: (e) => Pe(e)
}, Db = ["src"], xb = F({
  name: "ElImageViewer"
}), Fb = /* @__PURE__ */ F({
  ...xb,
  props: Vb,
  emits: Bb,
  setup(e, { expose: t, emit: n }) {
    const l = e, o = {
      CONTAIN: {
        name: "contain",
        icon: Rl(Sd)
      },
      ORIGINAL: {
        name: "original",
        icon: Rl(Ed)
      }
    }, { t: a } = ot(), r = se("image-viewer"), { nextZIndex: i } = Uo(), u = N(), c = N([]), p = $f(), d = N(!0), f = N(l.initialIndex), h = ht(o.CONTAIN), v = N({
      scale: 1,
      deg: 0,
      offsetX: 0,
      offsetY: 0,
      enableTransition: !1
    }), m = k(() => {
      const { urlList: M } = l;
      return M.length <= 1;
    }), g = k(() => f.value === 0), w = k(() => f.value === l.urlList.length - 1), C = k(() => l.urlList[f.value]), y = k(() => {
      const { scale: M, deg: P, offsetX: L, offsetY: U, enableTransition: oe } = v.value;
      let le = L / M, ee = U / M;
      switch (P % 360) {
        case 90:
        case -270:
          [le, ee] = [ee, -le];
          break;
        case 180:
        case -180:
          [le, ee] = [-le, -ee];
          break;
        case 270:
        case -90:
          [le, ee] = [-ee, le];
          break;
      }
      const pe = {
        transform: `scale(${M}) rotate(${P}deg) translate(${le}px, ${ee}px)`,
        transition: oe ? "transform .3s" : ""
      };
      return h.value.name === o.CONTAIN.name && (pe.maxWidth = pe.maxHeight = "100%"), pe;
    }), b = k(() => Pe(l.zIndex) ? l.zIndex : i());
    function S() {
      O(), n("close");
    }
    function T() {
      const M = Wn((L) => {
        switch (L.code) {
          case Ce.esc:
            l.closeOnPressEscape && S();
            break;
          case Ce.space:
            A();
            break;
          case Ce.left:
            Z();
            break;
          case Ce.up:
            V("zoomIn");
            break;
          case Ce.right:
            J();
            break;
          case Ce.down:
            V("zoomOut");
            break;
        }
      }), P = Wn((L) => {
        const U = L.deltaY || L.deltaX;
        V(U < 0 ? "zoomIn" : "zoomOut", {
          zoomRate: l.zoomRate,
          enableTransition: !1
        });
      });
      p.run(() => {
        Nt(document, "keydown", M), Nt(document, "wheel", P);
      });
    }
    function O() {
      p.stop();
    }
    function I() {
      d.value = !1;
    }
    function R(M) {
      d.value = !1, M.target.alt = a("el.image.error");
    }
    function B(M) {
      if (d.value || M.button !== 0 || !u.value)
        return;
      v.value.enableTransition = !1;
      const { offsetX: P, offsetY: L } = v.value, U = M.pageX, oe = M.pageY, le = Wn((pe) => {
        v.value = {
          ...v.value,
          offsetX: P + pe.pageX - U,
          offsetY: L + pe.pageY - oe
        };
      }), ee = Nt(document, "mousemove", le);
      Nt(document, "mouseup", () => {
        ee();
      }), M.preventDefault();
    }
    function D() {
      v.value = {
        scale: 1,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: !1
      };
    }
    function A() {
      if (d.value)
        return;
      const M = la(o), P = Object.values(o), L = h.value.name, oe = (P.findIndex((le) => le.name === L) + 1) % M.length;
      h.value = o[M[oe]], D();
    }
    function z(M) {
      const P = l.urlList.length;
      f.value = (M + P) % P;
    }
    function Z() {
      g.value && !l.infinite || z(f.value - 1);
    }
    function J() {
      w.value && !l.infinite || z(f.value + 1);
    }
    function V(M, P = {}) {
      if (d.value)
        return;
      const { zoomRate: L, rotateDeg: U, enableTransition: oe } = {
        zoomRate: l.zoomRate,
        rotateDeg: 90,
        enableTransition: !0,
        ...P
      };
      switch (M) {
        case "zoomOut":
          v.value.scale > 0.2 && (v.value.scale = Number.parseFloat((v.value.scale / L).toFixed(3)));
          break;
        case "zoomIn":
          v.value.scale < 7 && (v.value.scale = Number.parseFloat((v.value.scale * L).toFixed(3)));
          break;
        case "clockwise":
          v.value.deg += U;
          break;
        case "anticlockwise":
          v.value.deg -= U;
          break;
      }
      v.value.enableTransition = oe;
    }
    return ue(C, () => {
      Ne(() => {
        const M = c.value[0];
        M != null && M.complete || (d.value = !0);
      });
    }), ue(f, (M) => {
      D(), n("switch", M);
    }), We(() => {
      var M, P;
      T(), (P = (M = u.value) == null ? void 0 : M.focus) == null || P.call(M);
    }), t({
      setActiveItem: z
    }), (M, P) => (E(), q(Go, {
      to: "body",
      disabled: !M.teleported
    }, [
      x(jt, {
        name: "viewer-fade",
        appear: ""
      }, {
        default: K(() => [
          H("div", {
            ref_key: "wrapper",
            ref: u,
            tabindex: -1,
            class: $(s(r).e("wrapper")),
            style: ye({ zIndex: s(b) })
          }, [
            H("div", {
              class: $(s(r).e("mask")),
              onClick: P[0] || (P[0] = Ae((L) => M.hideOnClickModal && S(), ["self"]))
            }, null, 2),
            W(" CLOSE "),
            H("span", {
              class: $([s(r).e("btn"), s(r).e("close")]),
              onClick: S
            }, [
              x(s(Se), null, {
                default: K(() => [
                  x(s(Sl))
                ]),
                _: 1
              })
            ], 2),
            W(" ARROW "),
            s(m) ? W("v-if", !0) : (E(), _(Re, { key: 0 }, [
              H("span", {
                class: $([
                  s(r).e("btn"),
                  s(r).e("prev"),
                  s(r).is("disabled", !M.infinite && s(g))
                ]),
                onClick: Z
              }, [
                x(s(Se), null, {
                  default: K(() => [
                    x(s(zo))
                  ]),
                  _: 1
                })
              ], 2),
              H("span", {
                class: $([
                  s(r).e("btn"),
                  s(r).e("next"),
                  s(r).is("disabled", !M.infinite && s(w))
                ]),
                onClick: J
              }, [
                x(s(Se), null, {
                  default: K(() => [
                    x(s(wn))
                  ]),
                  _: 1
                })
              ], 2)
            ], 64)),
            W(" ACTIONS "),
            H("div", {
              class: $([s(r).e("btn"), s(r).e("actions")])
            }, [
              H("div", {
                class: $(s(r).e("actions__inner"))
              }, [
                x(s(Se), {
                  onClick: P[1] || (P[1] = (L) => V("zoomOut"))
                }, {
                  default: K(() => [
                    x(s($d))
                  ]),
                  _: 1
                }),
                x(s(Se), {
                  onClick: P[2] || (P[2] = (L) => V("zoomIn"))
                }, {
                  default: K(() => [
                    x(s(ki))
                  ]),
                  _: 1
                }),
                H("i", {
                  class: $(s(r).e("actions__divider"))
                }, null, 2),
                x(s(Se), { onClick: A }, {
                  default: K(() => [
                    (E(), q(Ge(s(h).icon)))
                  ]),
                  _: 1
                }),
                H("i", {
                  class: $(s(r).e("actions__divider"))
                }, null, 2),
                x(s(Se), {
                  onClick: P[3] || (P[3] = (L) => V("anticlockwise"))
                }, {
                  default: K(() => [
                    x(s(Td))
                  ]),
                  _: 1
                }),
                x(s(Se), {
                  onClick: P[4] || (P[4] = (L) => V("clockwise"))
                }, {
                  default: K(() => [
                    x(s(Nd))
                  ]),
                  _: 1
                })
              ], 2)
            ], 2),
            W(" CANVAS "),
            H("div", {
              class: $(s(r).e("canvas"))
            }, [
              (E(!0), _(Re, null, Xe(M.urlList, (L, U) => qe((E(), _("img", {
                ref_for: !0,
                ref: (oe) => c.value[U] = oe,
                key: L,
                src: L,
                style: ye(s(y)),
                class: $(s(r).e("img")),
                onLoad: I,
                onError: R,
                onMousedown: B
              }, null, 46, Db)), [
                [at, U === f.value]
              ])), 128))
            ], 2),
            ne(M.$slots, "default")
          ], 6)
        ]),
        _: 3
      })
    ], 8, ["disabled"]));
  }
});
var Hb = /* @__PURE__ */ de(Fb, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image-viewer/src/image-viewer.vue"]]);
const qu = xe(Hb), zb = he({
  hideOnClickModal: {
    type: Boolean,
    default: !1
  },
  src: {
    type: String,
    default: ""
  },
  fit: {
    type: String,
    values: ["", "contain", "cover", "fill", "none", "scale-down"],
    default: ""
  },
  loading: {
    type: String,
    values: ["eager", "lazy"]
  },
  lazy: {
    type: Boolean,
    default: !1
  },
  scrollContainer: {
    type: j([String, Object])
  },
  previewSrcList: {
    type: j(Array),
    default: () => Et([])
  },
  previewTeleported: {
    type: Boolean,
    default: !1
  },
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: !0
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  zoomRate: {
    type: Number,
    default: 1.2
  }
}), Kb = {
  load: (e) => e instanceof Event,
  error: (e) => e instanceof Event,
  switch: (e) => Pe(e),
  close: () => !0,
  show: () => !0
}, Wb = ["src", "loading"], jb = { key: 0 }, Ub = F({
  name: "ElImage",
  inheritAttrs: !1
}), qb = /* @__PURE__ */ F({
  ...Ub,
  props: zb,
  emits: Kb,
  setup(e, { emit: t }) {
    const n = e;
    let l = "";
    const { t: o } = ot(), a = se("image"), r = ca(), i = vi(), u = N(), c = N(!1), p = N(!0), d = N(!1), f = N(), h = N(), v = rt && "loading" in HTMLImageElement.prototype;
    let m, g;
    const w = k(() => r.style), C = k(() => {
      const { fit: M } = n;
      return rt && M ? { objectFit: M } : {};
    }), y = k(() => {
      const { previewSrcList: M } = n;
      return Array.isArray(M) && M.length > 0;
    }), b = k(() => {
      const { previewSrcList: M, initialIndex: P } = n;
      let L = P;
      return P > M.length - 1 && (L = 0), L;
    }), S = k(() => n.loading === "eager" ? !1 : !v && n.loading === "lazy" || n.lazy), T = () => {
      !rt || (p.value = !0, c.value = !1, u.value = n.src);
    };
    function O(M) {
      p.value = !1, c.value = !1, t("load", M);
    }
    function I(M) {
      p.value = !1, c.value = !0, t("error", M);
    }
    function R() {
      mp(f.value, h.value) && (T(), A());
    }
    const B = gi(R, 200);
    async function D() {
      var M;
      if (!rt)
        return;
      await Ne();
      const { scrollContainer: P } = n;
      hl(P) ? h.value = P : Ue(P) && P !== "" ? h.value = (M = document.querySelector(P)) != null ? M : void 0 : f.value && (h.value = oa(f.value)), h.value && (m = Nt(h, "scroll", B), setTimeout(() => R(), 100));
    }
    function A() {
      !rt || !h.value || !B || (m == null || m(), h.value = void 0);
    }
    function z(M) {
      if (!!M.ctrlKey) {
        if (M.deltaY < 0)
          return M.preventDefault(), !1;
        if (M.deltaY > 0)
          return M.preventDefault(), !1;
      }
    }
    function Z() {
      !y.value || (g = Nt("wheel", z, {
        passive: !1
      }), l = document.body.style.overflow, document.body.style.overflow = "hidden", d.value = !0, t("show"));
    }
    function J() {
      g == null || g(), document.body.style.overflow = l, d.value = !1, t("close");
    }
    function V(M) {
      t("switch", M);
    }
    return ue(() => n.src, () => {
      S.value ? (p.value = !0, c.value = !1, A(), D()) : T();
    }), We(() => {
      S.value ? D() : T();
    }), (M, P) => (E(), _("div", {
      ref_key: "container",
      ref: f,
      class: $([s(a).b(), M.$attrs.class]),
      style: ye(s(w))
    }, [
      u.value !== void 0 && !c.value ? (E(), _("img", Be({ key: 0 }, s(i), {
        src: u.value,
        loading: M.loading,
        style: s(C),
        class: [
          s(a).e("inner"),
          s(y) && s(a).e("preview"),
          p.value && s(a).is("loading")
        ],
        onClick: Z,
        onLoad: O,
        onError: I
      }), null, 16, Wb)) : W("v-if", !0),
      p.value || c.value ? (E(), _("div", {
        key: 1,
        class: $(s(a).e("wrapper"))
      }, [
        p.value ? ne(M.$slots, "placeholder", { key: 0 }, () => [
          H("div", {
            class: $(s(a).e("placeholder"))
          }, null, 2)
        ]) : c.value ? ne(M.$slots, "error", { key: 1 }, () => [
          H("div", {
            class: $(s(a).e("error"))
          }, ce(s(o)("el.image.error")), 3)
        ]) : W("v-if", !0)
      ], 2)) : W("v-if", !0),
      s(y) ? (E(), _(Re, { key: 2 }, [
        d.value ? (E(), q(s(qu), {
          key: 0,
          "z-index": M.zIndex,
          "initial-index": s(b),
          infinite: M.infinite,
          "zoom-rate": M.zoomRate,
          "url-list": M.previewSrcList,
          "hide-on-click-modal": M.hideOnClickModal,
          teleported: M.previewTeleported,
          "close-on-press-escape": M.closeOnPressEscape,
          onClose: J,
          onSwitch: V
        }, {
          default: K(() => [
            M.$slots.viewer ? (E(), _("div", jb, [
              ne(M.$slots, "viewer")
            ])) : W("v-if", !0)
          ]),
          _: 3
        }, 8, ["z-index", "initial-index", "infinite", "zoom-rate", "url-list", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : W("v-if", !0)
      ], 64)) : W("v-if", !0)
    ], 6));
  }
});
var Gb = /* @__PURE__ */ de(qb, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image/src/image.vue"]]);
const Yb = xe(Gb), Xb = he({
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger", "default"],
    default: "default"
  },
  underline: {
    type: Boolean,
    default: !0
  },
  disabled: { type: Boolean, default: !1 },
  href: { type: String, default: "" },
  icon: {
    type: ft
  }
}), Zb = {
  click: (e) => e instanceof MouseEvent
}, Jb = ["href"], Qb = F({
  name: "ElLink"
}), e0 = /* @__PURE__ */ F({
  ...Qb,
  props: Xb,
  emits: Zb,
  setup(e, { emit: t }) {
    const n = e, l = se("link"), o = k(() => [
      l.b(),
      l.m(n.type),
      l.is("disabled", n.disabled),
      l.is("underline", n.underline && !n.disabled)
    ]);
    function a(r) {
      n.disabled || t("click", r);
    }
    return (r, i) => (E(), _("a", {
      class: $(s(o)),
      href: r.disabled || !r.href ? void 0 : r.href,
      onClick: a
    }, [
      r.icon ? (E(), q(s(Se), { key: 0 }, {
        default: K(() => [
          (E(), q(Ge(r.icon)))
        ]),
        _: 1
      })) : W("v-if", !0),
      r.$slots.default ? (E(), _("span", {
        key: 1,
        class: $(s(l).e("inner"))
      }, [
        ne(r.$slots, "default")
      ], 2)) : W("v-if", !0),
      r.$slots.icon ? ne(r.$slots, "icon", { key: 2 }) : W("v-if", !0)
    ], 10, Jb));
  }
});
var t0 = /* @__PURE__ */ de(e0, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/link/src/link.vue"]]);
const n0 = xe(t0);
class l0 {
  constructor(t, n) {
    this.parent = t, this.domNode = n, this.subIndex = 0, this.subIndex = 0, this.init();
  }
  init() {
    this.subMenuItems = this.domNode.querySelectorAll("li"), this.addListeners();
  }
  gotoSubIndex(t) {
    t === this.subMenuItems.length ? t = 0 : t < 0 && (t = this.subMenuItems.length - 1), this.subMenuItems[t].focus(), this.subIndex = t;
  }
  addListeners() {
    const t = this.parent.domNode;
    Array.prototype.forEach.call(this.subMenuItems, (n) => {
      n.addEventListener("keydown", (l) => {
        let o = !1;
        switch (l.code) {
          case Ce.down: {
            this.gotoSubIndex(this.subIndex + 1), o = !0;
            break;
          }
          case Ce.up: {
            this.gotoSubIndex(this.subIndex - 1), o = !0;
            break;
          }
          case Ce.tab: {
            io(t, "mouseleave");
            break;
          }
          case Ce.enter:
          case Ce.space: {
            o = !0, l.currentTarget.click();
            break;
          }
        }
        return o && (l.preventDefault(), l.stopPropagation()), !1;
      });
    });
  }
}
class o0 {
  constructor(t, n) {
    this.domNode = t, this.submenu = null, this.submenu = null, this.init(n);
  }
  init(t) {
    this.domNode.setAttribute("tabindex", "0");
    const n = this.domNode.querySelector(`.${t}-menu`);
    n && (this.submenu = new l0(this, n)), this.addListeners();
  }
  addListeners() {
    this.domNode.addEventListener("keydown", (t) => {
      let n = !1;
      switch (t.code) {
        case Ce.down: {
          io(t.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(0), n = !0;
          break;
        }
        case Ce.up: {
          io(t.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1), n = !0;
          break;
        }
        case Ce.tab: {
          io(t.currentTarget, "mouseleave");
          break;
        }
        case Ce.enter:
        case Ce.space: {
          n = !0, t.currentTarget.click();
          break;
        }
      }
      n && t.preventDefault();
    });
  }
}
class s0 {
  constructor(t, n) {
    this.domNode = t, this.init(n);
  }
  init(t) {
    const n = this.domNode.childNodes;
    Array.from(n).forEach((l) => {
      l.nodeType === 1 && new o0(l, t);
    });
  }
}
const a0 = F({
  name: "ElMenuCollapseTransition",
  setup() {
    const e = se("menu");
    return {
      listeners: {
        onBeforeEnter: (n) => n.style.opacity = "0.2",
        onEnter(n, l) {
          yn(n, `${e.namespace.value}-opacity-transition`), n.style.opacity = "1", l();
        },
        onAfterEnter(n) {
          zt(n, `${e.namespace.value}-opacity-transition`), n.style.opacity = "";
        },
        onBeforeLeave(n) {
          n.dataset || (n.dataset = {}), Kn(n, e.m("collapse")) ? (zt(n, e.m("collapse")), n.dataset.oldOverflow = n.style.overflow, n.dataset.scrollWidth = n.clientWidth.toString(), yn(n, e.m("collapse"))) : (yn(n, e.m("collapse")), n.dataset.oldOverflow = n.style.overflow, n.dataset.scrollWidth = n.clientWidth.toString(), zt(n, e.m("collapse"))), n.style.width = `${n.scrollWidth}px`, n.style.overflow = "hidden";
        },
        onLeave(n) {
          yn(n, "horizontal-collapse-transition"), n.style.width = `${n.dataset.scrollWidth}px`;
        }
      }
    };
  }
});
function r0(e, t, n, l, o, a) {
  return E(), q(jt, Be({ mode: "out-in" }, e.listeners), {
    default: K(() => [
      ne(e.$slots, "default")
    ]),
    _: 3
  }, 16);
}
var i0 = /* @__PURE__ */ de(a0, [["render", r0], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-collapse-transition.vue"]]);
function Gu(e, t) {
  const n = k(() => {
    let o = e.parent;
    const a = [t.value];
    for (; o.type.name !== "ElMenu"; )
      o.props.index && a.unshift(o.props.index), o = o.parent;
    return a;
  });
  return {
    parentMenu: k(() => {
      let o = e.parent;
      for (; o && !["ElMenu", "ElSubMenu"].includes(o.type.name); )
        o = o.parent;
      return o;
    }),
    indexPath: n
  };
}
function u0(e) {
  return k(() => {
    const n = e.backgroundColor;
    return n ? new dp(n).shade(20).toString() : "";
  });
}
const Yu = (e, t) => {
  const n = se("menu");
  return k(() => n.cssVarBlock({
    "text-color": e.textColor || "",
    "hover-text-color": e.textColor || "",
    "bg-color": e.backgroundColor || "",
    "hover-bg-color": u0(e).value || "",
    "active-color": e.activeTextColor || "",
    level: `${t}`
  }));
}, c0 = he({
  index: {
    type: String,
    required: !0
  },
  showTimeout: {
    type: Number,
    default: 300
  },
  hideTimeout: {
    type: Number,
    default: 300
  },
  popperClass: String,
  disabled: Boolean,
  popperAppendToBody: {
    type: Boolean,
    default: void 0
  },
  teleported: {
    type: Boolean,
    default: void 0
  },
  popperOffset: {
    type: Number,
    default: 6
  },
  expandCloseIcon: {
    type: ft
  },
  expandOpenIcon: {
    type: ft
  },
  collapseCloseIcon: {
    type: ft
  },
  collapseOpenIcon: {
    type: ft
  }
}), so = "ElSubMenu";
var Ia = F({
  name: so,
  props: c0,
  setup(e, { slots: t, expose: n }) {
    Ll({
      from: "popper-append-to-body",
      replacement: "teleported",
      scope: so,
      version: "2.3.0",
      ref: "https://element-plus.org/en-US/component/menu.html#submenu-attributes"
    }, k(() => e.popperAppendToBody !== void 0));
    const l = je(), { indexPath: o, parentMenu: a } = Gu(l, k(() => e.index)), r = se("menu"), i = se("sub-menu"), u = Oe("rootMenu");
    u || wt(so, "can not inject root menu");
    const c = Oe(`subMenu:${a.value.uid}`);
    c || wt(so, "can not inject sub menu");
    const p = N({}), d = N({});
    let f;
    const h = N(!1), v = N(), m = N(null), g = k(() => D.value === "horizontal" && C.value ? "bottom-start" : "right-start"), w = k(() => D.value === "horizontal" && C.value || D.value === "vertical" && !u.props.collapse ? e.expandCloseIcon && e.expandOpenIcon ? T.value ? e.expandOpenIcon : e.expandCloseIcon : Zl : e.collapseCloseIcon && e.collapseOpenIcon ? T.value ? e.collapseOpenIcon : e.collapseCloseIcon : wn), C = k(() => c.level === 0), y = k(() => {
      var L;
      const U = (L = e.teleported) != null ? L : e.popperAppendToBody;
      return U === void 0 ? C.value : U;
    }), b = k(() => u.props.collapse ? `${r.namespace.value}-zoom-in-left` : `${r.namespace.value}-zoom-in-top`), S = k(() => D.value === "horizontal" && C.value ? [
      "bottom-start",
      "bottom-end",
      "top-start",
      "top-end",
      "right-start",
      "left-start"
    ] : [
      "right-start",
      "left-start",
      "bottom-start",
      "bottom-end",
      "top-start",
      "top-end"
    ]), T = k(() => u.openedMenus.includes(e.index)), O = k(() => {
      let L = !1;
      return Object.values(p.value).forEach((U) => {
        U.active && (L = !0);
      }), Object.values(d.value).forEach((U) => {
        U.active && (L = !0);
      }), L;
    }), I = k(() => u.props.backgroundColor || ""), R = k(() => u.props.activeTextColor || ""), B = k(() => u.props.textColor || ""), D = k(() => u.props.mode), A = ct({
      index: e.index,
      indexPath: o,
      active: O
    }), z = k(() => D.value !== "horizontal" ? {
      color: B.value
    } : {
      borderBottomColor: O.value ? u.props.activeTextColor ? R.value : "" : "transparent",
      color: O.value ? R.value : B.value
    }), Z = () => {
      var L, U, oe;
      return (oe = (U = (L = m.value) == null ? void 0 : L.popperRef) == null ? void 0 : U.popperInstanceRef) == null ? void 0 : oe.destroy();
    }, J = (L) => {
      L || Z();
    }, V = () => {
      u.props.menuTrigger === "hover" && u.props.mode === "horizontal" || u.props.collapse && u.props.mode === "vertical" || e.disabled || u.handleSubMenuClick({
        index: e.index,
        indexPath: o.value,
        active: O.value
      });
    }, M = (L, U = e.showTimeout) => {
      var oe;
      L.type !== "focus" && (u.props.menuTrigger === "click" && u.props.mode === "horizontal" || !u.props.collapse && u.props.mode === "vertical" || e.disabled || (c.mouseInChild.value = !0, f == null || f(), { stop: f } = Vl(() => {
        u.openMenu(e.index, o.value);
      }, U), y.value && ((oe = a.value.vnode.el) == null || oe.dispatchEvent(new MouseEvent("mouseenter")))));
    }, P = (L = !1) => {
      var U, oe;
      u.props.menuTrigger === "click" && u.props.mode === "horizontal" || !u.props.collapse && u.props.mode === "vertical" || (f == null || f(), c.mouseInChild.value = !1, { stop: f } = Vl(() => !h.value && u.closeMenu(e.index, o.value), e.hideTimeout), y.value && L && ((U = l.parent) == null ? void 0 : U.type.name) === "ElSubMenu" && ((oe = c.handleMouseleave) == null || oe.call(c, !0)));
    };
    ue(() => u.props.collapse, (L) => J(Boolean(L)));
    {
      const L = (oe) => {
        d.value[oe.index] = oe;
      }, U = (oe) => {
        delete d.value[oe.index];
      };
      tt(`subMenu:${l.uid}`, {
        addSubMenu: L,
        removeSubMenu: U,
        handleMouseleave: P,
        mouseInChild: h,
        level: c.level + 1
      });
    }
    return n({
      opened: T
    }), We(() => {
      u.addSubMenu(A), c.addSubMenu(A);
    }), Dt(() => {
      c.removeSubMenu(A), u.removeSubMenu(A);
    }), () => {
      var L;
      const U = [
        (L = t.title) == null ? void 0 : L.call(t),
        fe(Se, {
          class: i.e("icon-arrow"),
          style: {
            transform: T.value ? e.expandCloseIcon && e.expandOpenIcon || e.collapseCloseIcon && e.collapseOpenIcon && u.props.collapse ? "none" : "rotateZ(180deg)" : "none"
          }
        }, {
          default: () => Ue(w.value) ? fe(l.appContext.components[w.value]) : fe(w.value)
        })
      ], oe = Yu(u.props, c.level + 1), le = u.isMenuPopup ? fe(Wt, {
        ref: m,
        visible: T.value,
        effect: "light",
        pure: !0,
        offset: e.popperOffset,
        showArrow: !1,
        persistent: !0,
        popperClass: e.popperClass,
        placement: g.value,
        teleported: y.value,
        fallbackPlacements: S.value,
        transition: b.value,
        gpuAcceleration: !1
      }, {
        content: () => {
          var ee;
          return fe("div", {
            class: [
              r.m(D.value),
              r.m("popup-container"),
              e.popperClass
            ],
            onMouseenter: (pe) => M(pe, 100),
            onMouseleave: () => P(!0),
            onFocus: (pe) => M(pe, 100)
          }, [
            fe("ul", {
              class: [
                r.b(),
                r.m("popup"),
                r.m(`popup-${g.value}`)
              ],
              style: oe.value
            }, [(ee = t.default) == null ? void 0 : ee.call(t)])
          ]);
        },
        default: () => fe("div", {
          class: i.e("title"),
          style: [
            z.value,
            { backgroundColor: I.value }
          ],
          onClick: V
        }, U)
      }) : fe(Re, {}, [
        fe("div", {
          class: i.e("title"),
          style: [
            z.value,
            { backgroundColor: I.value }
          ],
          ref: v,
          onClick: V
        }, U),
        fe(Si, {}, {
          default: () => {
            var ee;
            return qe(fe("ul", {
              role: "menu",
              class: [r.b(), r.m("inline")],
              style: oe.value
            }, [(ee = t.default) == null ? void 0 : ee.call(t)]), [[at, T.value]]);
          }
        })
      ]);
      return fe("li", {
        class: [
          i.b(),
          i.is("active", O.value),
          i.is("opened", T.value),
          i.is("disabled", e.disabled)
        ],
        role: "menuitem",
        ariaHaspopup: !0,
        ariaExpanded: T.value,
        onMouseenter: M,
        onMouseleave: () => P(!0),
        onFocus: M
      }, [le]);
    };
  }
});
const d0 = he({
  mode: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "vertical"
  },
  defaultActive: {
    type: String,
    default: ""
  },
  defaultOpeneds: {
    type: j(Array),
    default: () => Et([])
  },
  uniqueOpened: Boolean,
  router: Boolean,
  menuTrigger: {
    type: String,
    values: ["hover", "click"],
    default: "hover"
  },
  collapse: Boolean,
  backgroundColor: String,
  textColor: String,
  activeTextColor: String,
  collapseTransition: {
    type: Boolean,
    default: !0
  },
  ellipsis: {
    type: Boolean,
    default: !0
  },
  popperEffect: {
    type: String,
    values: ["dark", "light"],
    default: "dark"
  }
}), rs = (e) => Array.isArray(e) && e.every((t) => Ue(t)), f0 = {
  close: (e, t) => Ue(e) && rs(t),
  open: (e, t) => Ue(e) && rs(t),
  select: (e, t, n, l) => Ue(e) && rs(t) && Ct(n) && (l === void 0 || l instanceof Promise)
};
var p0 = F({
  name: "ElMenu",
  props: d0,
  emits: f0,
  setup(e, { emit: t, slots: n, expose: l }) {
    const o = je(), a = o.appContext.config.globalProperties.$router, r = N(), i = se("menu"), u = se("sub-menu"), c = N(-1), p = N(e.defaultOpeneds && !e.collapse ? e.defaultOpeneds.slice(0) : []), d = N(e.defaultActive), f = N({}), h = N({}), v = k(() => e.mode === "horizontal" || e.mode === "vertical" && e.collapse), m = () => {
      const D = d.value && f.value[d.value];
      if (!D || e.mode === "horizontal" || e.collapse)
        return;
      D.indexPath.forEach((z) => {
        const Z = h.value[z];
        Z && g(z, Z.indexPath);
      });
    }, g = (D, A) => {
      p.value.includes(D) || (e.uniqueOpened && (p.value = p.value.filter((z) => A.includes(z))), p.value.push(D), t("open", D, A));
    }, w = (D) => {
      const A = p.value.indexOf(D);
      A !== -1 && p.value.splice(A, 1);
    }, C = (D, A) => {
      w(D), t("close", D, A);
    }, y = ({
      index: D,
      indexPath: A
    }) => {
      p.value.includes(D) ? C(D, A) : g(D, A);
    }, b = (D) => {
      (e.mode === "horizontal" || e.collapse) && (p.value = []);
      const { index: A, indexPath: z } = D;
      if (!(A === void 0 || z === void 0))
        if (e.router && a) {
          const Z = D.route || A, J = a.push(Z).then((V) => (V || (d.value = A), V));
          t("select", A, z, { index: A, indexPath: z, route: Z }, J);
        } else
          d.value = A, t("select", A, z, { index: A, indexPath: z });
    }, S = (D) => {
      const A = f.value, z = A[D] || d.value && A[d.value] || A[e.defaultActive];
      z ? d.value = z.index : d.value = D;
    }, T = () => {
      var D, A;
      if (!r.value)
        return -1;
      const z = Array.from((A = (D = r.value) == null ? void 0 : D.childNodes) != null ? A : []).filter((U) => U.nodeName !== "#text" || U.nodeValue), Z = 64, J = Number.parseInt(getComputedStyle(r.value).paddingLeft, 10), V = Number.parseInt(getComputedStyle(r.value).paddingRight, 10), M = r.value.clientWidth - J - V;
      let P = 0, L = 0;
      return z.forEach((U, oe) => {
        P += U.offsetWidth || 0, P <= M - Z && (L = oe + 1);
      }), L === z.length ? -1 : L;
    }, O = (D, A = 33.34) => {
      let z;
      return () => {
        z && clearTimeout(z), z = setTimeout(() => {
          D();
        }, A);
      };
    };
    let I = !0;
    const R = () => {
      const D = () => {
        c.value = -1, Ne(() => {
          c.value = T();
        });
      };
      I ? D() : O(D)(), I = !1;
    };
    ue(() => e.defaultActive, (D) => {
      f.value[D] || (d.value = ""), S(D);
    }), ue(() => e.collapse, (D) => {
      D && (p.value = []);
    }), ue(f.value, m);
    let B;
    en(() => {
      e.mode === "horizontal" && e.ellipsis ? B = Mn(r, R).stop : B == null || B();
    });
    {
      const D = (J) => {
        h.value[J.index] = J;
      }, A = (J) => {
        delete h.value[J.index];
      };
      tt("rootMenu", ct({
        props: e,
        openedMenus: p,
        items: f,
        subMenus: h,
        activeIndex: d,
        isMenuPopup: v,
        addMenuItem: (J) => {
          f.value[J.index] = J;
        },
        removeMenuItem: (J) => {
          delete f.value[J.index];
        },
        addSubMenu: D,
        removeSubMenu: A,
        openMenu: g,
        closeMenu: C,
        handleMenuItemClick: b,
        handleSubMenuClick: y
      })), tt(`subMenu:${o.uid}`, {
        addSubMenu: D,
        removeSubMenu: A,
        mouseInChild: N(!1),
        level: 0
      });
    }
    return We(() => {
      e.mode === "horizontal" && new s0(o.vnode.el, i.namespace.value);
    }), l({
      open: (A) => {
        const { indexPath: z } = h.value[A];
        z.forEach((Z) => g(Z, z));
      },
      close: w,
      handleResize: R
    }), () => {
      var D, A;
      let z = (A = (D = n.default) == null ? void 0 : D.call(n)) != null ? A : [];
      const Z = [];
      if (e.mode === "horizontal" && r.value) {
        const M = bi(z), P = c.value === -1 ? M : M.slice(0, c.value), L = c.value === -1 ? [] : M.slice(c.value);
        (L == null ? void 0 : L.length) && e.ellipsis && (z = P, Z.push(fe(Ia, {
          index: "sub-menu-more",
          class: u.e("hide-arrow")
        }, {
          title: () => fe(Se, {
            class: u.e("icon-more")
          }, { default: () => fe(Id) }),
          default: () => L
        })));
      }
      const J = Yu(e, 0), V = fe("ul", {
        key: String(e.collapse),
        role: "menubar",
        ref: r,
        style: J.value,
        class: {
          [i.b()]: !0,
          [i.m(e.mode)]: !0,
          [i.m("collapse")]: e.collapse
        }
      }, [...z, ...Z]);
      return e.collapseTransition && e.mode === "vertical" ? fe(i0, () => V) : V;
    };
  }
});
const h0 = he({
  index: {
    type: j([String, null]),
    default: null
  },
  route: {
    type: j([String, Object])
  },
  disabled: Boolean
}), v0 = {
  click: (e) => Ue(e.index) && Array.isArray(e.indexPath)
}, is = "ElMenuItem", m0 = F({
  name: is,
  components: {
    ElTooltip: Wt
  },
  props: h0,
  emits: v0,
  setup(e, { emit: t }) {
    const n = je(), l = Oe("rootMenu"), o = se("menu"), a = se("menu-item");
    l || wt(is, "can not inject root menu");
    const { parentMenu: r, indexPath: i } = Gu(n, tn(e, "index")), u = Oe(`subMenu:${r.value.uid}`);
    u || wt(is, "can not inject sub menu");
    const c = k(() => e.index === l.activeIndex), p = ct({
      index: e.index,
      indexPath: i,
      active: c
    }), d = () => {
      e.disabled || (l.handleMenuItemClick({
        index: e.index,
        indexPath: i.value,
        route: e.route
      }), t("click", p));
    };
    return We(() => {
      u.addSubMenu(p), l.addMenuItem(p);
    }), Dt(() => {
      u.removeSubMenu(p), l.removeMenuItem(p);
    }), {
      parentMenu: r,
      rootMenu: l,
      active: c,
      nsMenu: o,
      nsMenuItem: a,
      handleClick: d
    };
  }
});
function g0(e, t, n, l, o, a) {
  const r = $e("el-tooltip");
  return E(), _("li", {
    class: $([
      e.nsMenuItem.b(),
      e.nsMenuItem.is("active", e.active),
      e.nsMenuItem.is("disabled", e.disabled)
    ]),
    role: "menuitem",
    tabindex: "-1",
    onClick: t[0] || (t[0] = (...i) => e.handleClick && e.handleClick(...i))
  }, [
    e.parentMenu.type.name === "ElMenu" && e.rootMenu.props.collapse && e.$slots.title ? (E(), q(r, {
      key: 0,
      effect: e.rootMenu.props.popperEffect,
      placement: "right",
      "fallback-placements": ["left"],
      persistent: ""
    }, {
      content: K(() => [
        ne(e.$slots, "title")
      ]),
      default: K(() => [
        H("div", {
          class: $(e.nsMenu.be("tooltip", "trigger"))
        }, [
          ne(e.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 8, ["effect"])) : (E(), _(Re, { key: 1 }, [
      ne(e.$slots, "default"),
      ne(e.$slots, "title")
    ], 64))
  ], 2);
}
var Xu = /* @__PURE__ */ de(m0, [["render", g0], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item.vue"]]);
const y0 = {
  title: String
}, b0 = "ElMenuItemGroup", C0 = F({
  name: b0,
  props: y0,
  setup() {
    return {
      ns: se("menu-item-group")
    };
  }
});
function w0(e, t, n, l, o, a) {
  return E(), _("li", {
    class: $(e.ns.b())
  }, [
    H("div", {
      class: $(e.ns.e("title"))
    }, [
      e.$slots.title ? ne(e.$slots, "title", { key: 1 }) : (E(), _(Re, { key: 0 }, [
        st(ce(e.title), 1)
      ], 64))
    ], 2),
    H("ul", null, [
      ne(e.$slots, "default")
    ])
  ], 2);
}
var Zu = /* @__PURE__ */ de(C0, [["render", w0], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item-group.vue"]]);
const k0 = xe(p0, {
  MenuItem: Xu,
  MenuItemGroup: Zu,
  SubMenu: Ia
}), S0 = Rt(Xu), E0 = Rt(Zu), $0 = Rt(Ia), T0 = he({
  icon: {
    type: ft,
    default: () => Md
  },
  title: String,
  content: {
    type: String,
    default: ""
  }
}), N0 = {
  back: () => !0
}, I0 = ["aria-label"], M0 = F({
  name: "ElPageHeader"
}), R0 = /* @__PURE__ */ F({
  ...M0,
  props: T0,
  emits: N0,
  setup(e, { emit: t }) {
    const n = kn(), { t: l } = ot(), o = se("page-header"), a = k(() => [
      o.b(),
      {
        [o.m("has-breadcrumb")]: !!n.breadcrumb,
        [o.m("has-extra")]: !!n.extra,
        [o.is("contentful")]: !!n.default
      }
    ]);
    function r() {
      t("back");
    }
    return (i, u) => (E(), _("div", {
      class: $(s(a))
    }, [
      i.$slots.breadcrumb ? (E(), _("div", {
        key: 0,
        class: $(s(o).e("breadcrumb"))
      }, [
        ne(i.$slots, "breadcrumb")
      ], 2)) : W("v-if", !0),
      H("div", {
        class: $(s(o).e("header"))
      }, [
        H("div", {
          class: $(s(o).e("left"))
        }, [
          H("div", {
            class: $(s(o).e("back")),
            role: "button",
            tabindex: "0",
            onClick: r
          }, [
            i.icon || i.$slots.icon ? (E(), _("div", {
              key: 0,
              "aria-label": i.title || s(l)("el.pageHeader.title"),
              class: $(s(o).e("icon"))
            }, [
              ne(i.$slots, "icon", {}, () => [
                i.icon ? (E(), q(s(Se), { key: 0 }, {
                  default: K(() => [
                    (E(), q(Ge(i.icon)))
                  ]),
                  _: 1
                })) : W("v-if", !0)
              ])
            ], 10, I0)) : W("v-if", !0),
            H("div", {
              class: $(s(o).e("title"))
            }, [
              ne(i.$slots, "title", {}, () => [
                st(ce(i.title || s(l)("el.pageHeader.title")), 1)
              ])
            ], 2)
          ], 2),
          x(s(Bu), { direction: "vertical" }),
          H("div", {
            class: $(s(o).e("content"))
          }, [
            ne(i.$slots, "content", {}, () => [
              st(ce(i.content), 1)
            ])
          ], 2)
        ], 2),
        i.$slots.extra ? (E(), _("div", {
          key: 0,
          class: $(s(o).e("extra"))
        }, [
          ne(i.$slots, "extra")
        ], 2)) : W("v-if", !0)
      ], 2),
      i.$slots.default ? (E(), _("div", {
        key: 1,
        class: $(s(o).e("main"))
      }, [
        ne(i.$slots, "default")
      ], 2)) : W("v-if", !0)
    ], 2));
  }
});
var O0 = /* @__PURE__ */ de(R0, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/page-header/src/page-header.vue"]]);
const P0 = xe(O0), Ju = Symbol("elPaginationKey"), A0 = he({
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  prevText: {
    type: String
  },
  prevIcon: {
    type: ft
  }
}), _0 = {
  click: (e) => e instanceof MouseEvent
}, L0 = ["disabled", "aria-label", "aria-disabled"], V0 = { key: 0 }, B0 = F({
  name: "ElPaginationPrev"
}), D0 = /* @__PURE__ */ F({
  ...B0,
  props: A0,
  emits: _0,
  setup(e) {
    const t = e, { t: n } = ot(), l = k(() => t.disabled || t.currentPage <= 1);
    return (o, a) => (E(), _("button", {
      type: "button",
      class: "btn-prev",
      disabled: s(l),
      "aria-label": o.prevText || s(n)("el.pagination.prev"),
      "aria-disabled": s(l),
      onClick: a[0] || (a[0] = (r) => o.$emit("click", r))
    }, [
      o.prevText ? (E(), _("span", V0, ce(o.prevText), 1)) : (E(), q(s(Se), { key: 1 }, {
        default: K(() => [
          (E(), q(Ge(o.prevIcon)))
        ]),
        _: 1
      }))
    ], 8, L0));
  }
});
var x0 = /* @__PURE__ */ de(D0, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/prev.vue"]]);
const F0 = he({
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    default: 50
  },
  nextText: {
    type: String
  },
  nextIcon: {
    type: ft
  }
}), H0 = ["disabled", "aria-label", "aria-disabled"], z0 = { key: 0 }, K0 = F({
  name: "ElPaginationNext"
}), W0 = /* @__PURE__ */ F({
  ...K0,
  props: F0,
  emits: ["click"],
  setup(e) {
    const t = e, { t: n } = ot(), l = k(() => t.disabled || t.currentPage === t.pageCount || t.pageCount === 0);
    return (o, a) => (E(), _("button", {
      type: "button",
      class: "btn-next",
      disabled: s(l),
      "aria-label": o.nextText || s(n)("el.pagination.next"),
      "aria-disabled": s(l),
      onClick: a[0] || (a[0] = (r) => o.$emit("click", r))
    }, [
      o.nextText ? (E(), _("span", z0, ce(o.nextText), 1)) : (E(), q(s(Se), { key: 1 }, {
        default: K(() => [
          (E(), q(Ge(o.nextIcon)))
        ]),
        _: 1
      }))
    ], 8, H0));
  }
});
var j0 = /* @__PURE__ */ de(W0, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/next.vue"]]);
const Ma = () => Oe(Ju, {}), U0 = he({
  pageSize: {
    type: Number,
    required: !0
  },
  pageSizes: {
    type: j(Array),
    default: () => Et([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String
  },
  disabled: Boolean,
  size: {
    type: String,
    values: Yl
  }
}), q0 = F({
  name: "ElPaginationSizes"
}), G0 = /* @__PURE__ */ F({
  ...q0,
  props: U0,
  emits: ["page-size-change"],
  setup(e, { emit: t }) {
    const n = e, { t: l } = ot(), o = se("pagination"), a = Ma(), r = N(n.pageSize);
    ue(() => n.pageSizes, (c, p) => {
      if (!bn(c, p) && Array.isArray(c)) {
        const d = c.includes(n.pageSize) ? n.pageSize : n.pageSizes[0];
        t("page-size-change", d);
      }
    }), ue(() => n.pageSize, (c) => {
      r.value = c;
    });
    const i = k(() => n.pageSizes);
    function u(c) {
      var p;
      c !== r.value && (r.value = c, (p = a.handleSizeChange) == null || p.call(a, Number(c)));
    }
    return (c, p) => (E(), _("span", {
      class: $(s(o).e("sizes"))
    }, [
      x(s(Gn), {
        "model-value": r.value,
        disabled: c.disabled,
        "popper-class": c.popperClass,
        size: c.size,
        "validate-event": !1,
        onChange: u
      }, {
        default: K(() => [
          (E(!0), _(Re, null, Xe(s(i), (d) => (E(), q(s(Ro), {
            key: d,
            value: d,
            label: d + s(l)("el.pagination.pagesize")
          }, null, 8, ["value", "label"]))), 128))
        ]),
        _: 1
      }, 8, ["model-value", "disabled", "popper-class", "size"])
    ], 2));
  }
});
var Y0 = /* @__PURE__ */ de(G0, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/sizes.vue"]]);
const X0 = he({
  size: {
    type: String,
    values: Yl
  }
}), Z0 = ["disabled"], J0 = F({
  name: "ElPaginationJumper"
}), Q0 = /* @__PURE__ */ F({
  ...J0,
  props: X0,
  setup(e) {
    const { t } = ot(), n = se("pagination"), { pageCount: l, disabled: o, currentPage: a, changeEvent: r } = Ma(), i = N(), u = k(() => {
      var d;
      return (d = i.value) != null ? d : a == null ? void 0 : a.value;
    });
    function c(d) {
      i.value = d ? +d : "";
    }
    function p(d) {
      d = Math.trunc(+d), r == null || r(d), i.value = void 0;
    }
    return (d, f) => (E(), _("span", {
      class: $(s(n).e("jump")),
      disabled: s(o)
    }, [
      H("span", {
        class: $([s(n).e("goto")])
      }, ce(s(t)("el.pagination.goto")), 3),
      x(s(Jn), {
        size: d.size,
        class: $([s(n).e("editor"), s(n).is("in-pagination")]),
        min: 1,
        max: s(l),
        disabled: s(o),
        "model-value": s(u),
        "validate-event": !1,
        label: s(t)("el.pagination.page"),
        type: "number",
        "onUpdate:modelValue": c,
        onChange: p
      }, null, 8, ["size", "class", "max", "disabled", "model-value", "label"]),
      H("span", {
        class: $([s(n).e("classifier")])
      }, ce(s(t)("el.pagination.pageClassifier")), 3)
    ], 10, Z0));
  }
});
var eC = /* @__PURE__ */ de(Q0, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/jumper.vue"]]);
const tC = he({
  total: {
    type: Number,
    default: 1e3
  }
}), nC = ["disabled"], lC = F({
  name: "ElPaginationTotal"
}), oC = /* @__PURE__ */ F({
  ...lC,
  props: tC,
  setup(e) {
    const { t } = ot(), n = se("pagination"), { disabled: l } = Ma();
    return (o, a) => (E(), _("span", {
      class: $(s(n).e("total")),
      disabled: s(l)
    }, ce(s(t)("el.pagination.total", {
      total: o.total
    })), 11, nC));
  }
});
var sC = /* @__PURE__ */ de(oC, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/total.vue"]]);
const aC = he({
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    required: !0
  },
  pagerCount: {
    type: Number,
    default: 7
  },
  disabled: Boolean
}), rC = ["onKeyup"], iC = ["aria-current", "aria-label", "tabindex"], uC = ["tabindex", "aria-label"], cC = ["aria-current", "aria-label", "tabindex"], dC = ["tabindex", "aria-label"], fC = ["aria-current", "aria-label", "tabindex"], pC = F({
  name: "ElPaginationPager"
}), hC = /* @__PURE__ */ F({
  ...pC,
  props: aC,
  emits: ["change"],
  setup(e, { emit: t }) {
    const n = e, l = se("pager"), o = se("icon"), { t: a } = ot(), r = N(!1), i = N(!1), u = N(!1), c = N(!1), p = N(!1), d = N(!1), f = k(() => {
      const C = n.pagerCount, y = (C - 1) / 2, b = Number(n.currentPage), S = Number(n.pageCount);
      let T = !1, O = !1;
      S > C && (b > C - y && (T = !0), b < S - y && (O = !0));
      const I = [];
      if (T && !O) {
        const R = S - (C - 2);
        for (let B = R; B < S; B++)
          I.push(B);
      } else if (!T && O)
        for (let R = 2; R < C; R++)
          I.push(R);
      else if (T && O) {
        const R = Math.floor(C / 2) - 1;
        for (let B = b - R; B <= b + R; B++)
          I.push(B);
      } else
        for (let R = 2; R < S; R++)
          I.push(R);
      return I;
    }), h = k(() => n.disabled ? -1 : 0);
    en(() => {
      const C = (n.pagerCount - 1) / 2;
      r.value = !1, i.value = !1, n.pageCount > n.pagerCount && (n.currentPage > n.pagerCount - C && (r.value = !0), n.currentPage < n.pageCount - C && (i.value = !0));
    });
    function v(C = !1) {
      n.disabled || (C ? u.value = !0 : c.value = !0);
    }
    function m(C = !1) {
      C ? p.value = !0 : d.value = !0;
    }
    function g(C) {
      const y = C.target;
      if (y.tagName.toLowerCase() === "li" && Array.from(y.classList).includes("number")) {
        const b = Number(y.textContent);
        b !== n.currentPage && t("change", b);
      } else
        y.tagName.toLowerCase() === "li" && Array.from(y.classList).includes("more") && w(C);
    }
    function w(C) {
      const y = C.target;
      if (y.tagName.toLowerCase() === "ul" || n.disabled)
        return;
      let b = Number(y.textContent);
      const S = n.pageCount, T = n.currentPage, O = n.pagerCount - 2;
      y.className.includes("more") && (y.className.includes("quickprev") ? b = T - O : y.className.includes("quicknext") && (b = T + O)), Number.isNaN(+b) || (b < 1 && (b = 1), b > S && (b = S)), b !== T && t("change", b);
    }
    return (C, y) => (E(), _("ul", {
      class: $(s(l).b()),
      onClick: w,
      onKeyup: ut(g, ["enter"])
    }, [
      C.pageCount > 0 ? (E(), _("li", {
        key: 0,
        class: $([[
          s(l).is("active", C.currentPage === 1),
          s(l).is("disabled", C.disabled)
        ], "number"]),
        "aria-current": C.currentPage === 1,
        "aria-label": s(a)("el.pagination.currentPage", { pager: 1 }),
        tabindex: s(h)
      }, " 1 ", 10, iC)) : W("v-if", !0),
      r.value ? (E(), _("li", {
        key: 1,
        class: $([
          "more",
          "btn-quickprev",
          s(o).b(),
          s(l).is("disabled", C.disabled)
        ]),
        tabindex: s(h),
        "aria-label": s(a)("el.pagination.prevPages", { pager: C.pagerCount - 2 }),
        onMouseenter: y[0] || (y[0] = (b) => v(!0)),
        onMouseleave: y[1] || (y[1] = (b) => u.value = !1),
        onFocus: y[2] || (y[2] = (b) => m(!0)),
        onBlur: y[3] || (y[3] = (b) => p.value = !1)
      }, [
        (u.value || p.value) && !C.disabled ? (E(), q(s(Rd), { key: 0 })) : (E(), q(s(er), { key: 1 }))
      ], 42, uC)) : W("v-if", !0),
      (E(!0), _(Re, null, Xe(s(f), (b) => (E(), _("li", {
        key: b,
        class: $([[
          s(l).is("active", C.currentPage === b),
          s(l).is("disabled", C.disabled)
        ], "number"]),
        "aria-current": C.currentPage === b,
        "aria-label": s(a)("el.pagination.currentPage", { pager: b }),
        tabindex: s(h)
      }, ce(b), 11, cC))), 128)),
      i.value ? (E(), _("li", {
        key: 2,
        class: $([
          "more",
          "btn-quicknext",
          s(o).b(),
          s(l).is("disabled", C.disabled)
        ]),
        tabindex: s(h),
        "aria-label": s(a)("el.pagination.nextPages", { pager: C.pagerCount - 2 }),
        onMouseenter: y[4] || (y[4] = (b) => v()),
        onMouseleave: y[5] || (y[5] = (b) => c.value = !1),
        onFocus: y[6] || (y[6] = (b) => m()),
        onBlur: y[7] || (y[7] = (b) => d.value = !1)
      }, [
        (c.value || d.value) && !C.disabled ? (E(), q(s(Od), { key: 0 })) : (E(), q(s(er), { key: 1 }))
      ], 42, dC)) : W("v-if", !0),
      C.pageCount > 1 ? (E(), _("li", {
        key: 3,
        class: $([[
          s(l).is("active", C.currentPage === C.pageCount),
          s(l).is("disabled", C.disabled)
        ], "number"]),
        "aria-current": C.currentPage === C.pageCount,
        "aria-label": s(a)("el.pagination.currentPage", { pager: C.pageCount }),
        tabindex: s(h)
      }, ce(C.pageCount), 11, fC)) : W("v-if", !0)
    ], 42, rC));
  }
});
var vC = /* @__PURE__ */ de(hC, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/pager.vue"]]);
const Ot = (e) => typeof e != "number", mC = he({
  total: Number,
  pageSize: Number,
  defaultPageSize: Number,
  currentPage: Number,
  defaultCurrentPage: Number,
  pageCount: Number,
  pagerCount: {
    type: Number,
    validator: (e) => Pe(e) && Math.trunc(e) === e && e > 4 && e < 22 && e % 2 === 1,
    default: 7
  },
  layout: {
    type: String,
    default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
  },
  pageSizes: {
    type: j(Array),
    default: () => Et([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String,
    default: ""
  },
  prevText: {
    type: String,
    default: ""
  },
  prevIcon: {
    type: ft,
    default: () => zo
  },
  nextText: {
    type: String,
    default: ""
  },
  nextIcon: {
    type: ft,
    default: () => wn
  },
  small: Boolean,
  background: Boolean,
  disabled: Boolean,
  hideOnSinglePage: Boolean
}), gC = {
  "update:current-page": (e) => Pe(e),
  "update:page-size": (e) => Pe(e),
  "size-change": (e) => Pe(e),
  "current-change": (e) => Pe(e),
  "prev-click": (e) => Pe(e),
  "next-click": (e) => Pe(e)
}, Or = "ElPagination";
var yC = F({
  name: Or,
  props: mC,
  emits: gC,
  setup(e, { emit: t, slots: n }) {
    const { t: l } = ot(), o = se("pagination"), a = je().vnode.props || {}, r = "onUpdate:currentPage" in a || "onUpdate:current-page" in a || "onCurrentChange" in a, i = "onUpdate:pageSize" in a || "onUpdate:page-size" in a || "onSizeChange" in a, u = k(() => {
      if (Ot(e.total) && Ot(e.pageCount) || !Ot(e.currentPage) && !r)
        return !1;
      if (e.layout.includes("sizes")) {
        if (Ot(e.pageCount)) {
          if (!Ot(e.total) && !Ot(e.pageSize) && !i)
            return !1;
        } else if (!i)
          return !1;
      }
      return !0;
    }), c = N(Ot(e.defaultPageSize) ? 10 : e.defaultPageSize), p = N(Ot(e.defaultCurrentPage) ? 1 : e.defaultCurrentPage), d = k({
      get() {
        return Ot(e.pageSize) ? c.value : e.pageSize;
      },
      set(y) {
        Ot(e.pageSize) && (c.value = y), i && (t("update:page-size", y), t("size-change", y));
      }
    }), f = k(() => {
      let y = 0;
      return Ot(e.pageCount) ? Ot(e.total) || (y = Math.max(1, Math.ceil(e.total / d.value))) : y = e.pageCount, y;
    }), h = k({
      get() {
        return Ot(e.currentPage) ? p.value : e.currentPage;
      },
      set(y) {
        let b = y;
        y < 1 ? b = 1 : y > f.value && (b = f.value), Ot(e.currentPage) && (p.value = b), r && (t("update:current-page", b), t("current-change", b));
      }
    });
    ue(f, (y) => {
      h.value > y && (h.value = y);
    });
    function v(y) {
      h.value = y;
    }
    function m(y) {
      d.value = y;
      const b = f.value;
      h.value > b && (h.value = b);
    }
    function g() {
      e.disabled || (h.value -= 1, t("prev-click", h.value));
    }
    function w() {
      e.disabled || (h.value += 1, t("next-click", h.value));
    }
    function C(y, b) {
      y && (y.props || (y.props = {}), y.props.class = [y.props.class, b].join(" "));
    }
    return tt(Ju, {
      pageCount: f,
      disabled: k(() => e.disabled),
      currentPage: h,
      changeEvent: v,
      handleSizeChange: m
    }), () => {
      var y, b;
      if (!u.value)
        return pt(Or, l("el.pagination.deprecationWarning")), null;
      if (!e.layout || e.hideOnSinglePage && f.value <= 1)
        return null;
      const S = [], T = [], O = fe("div", { class: o.e("rightwrapper") }, T), I = {
        prev: fe(x0, {
          disabled: e.disabled,
          currentPage: h.value,
          prevText: e.prevText,
          prevIcon: e.prevIcon,
          onClick: g
        }),
        jumper: fe(eC, {
          size: e.small ? "small" : "default"
        }),
        pager: fe(vC, {
          currentPage: h.value,
          pageCount: f.value,
          pagerCount: e.pagerCount,
          onChange: v,
          disabled: e.disabled
        }),
        next: fe(j0, {
          disabled: e.disabled,
          currentPage: h.value,
          pageCount: f.value,
          nextText: e.nextText,
          nextIcon: e.nextIcon,
          onClick: w
        }),
        sizes: fe(Y0, {
          pageSize: d.value,
          pageSizes: e.pageSizes,
          popperClass: e.popperClass,
          disabled: e.disabled,
          size: e.small ? "small" : "default"
        }),
        slot: (b = (y = n == null ? void 0 : n.default) == null ? void 0 : y.call(n)) != null ? b : null,
        total: fe(sC, { total: Ot(e.total) ? 0 : e.total })
      }, R = e.layout.split(",").map((D) => D.trim());
      let B = !1;
      return R.forEach((D) => {
        if (D === "->") {
          B = !0;
          return;
        }
        B ? T.push(I[D]) : S.push(I[D]);
      }), C(S[0], o.is("first")), C(S[S.length - 1], o.is("last")), B && T.length > 0 && (C(T[0], o.is("first")), C(T[T.length - 1], o.is("last")), S.push(O)), fe("div", {
        class: [
          o.b(),
          o.is("background", e.background),
          {
            [o.m("small")]: e.small
          }
        ]
      }, S);
    };
  }
});
const bC = xe(yC), CC = he({
  title: String,
  confirmButtonText: String,
  cancelButtonText: String,
  confirmButtonType: {
    type: String,
    values: lr,
    default: "primary"
  },
  cancelButtonType: {
    type: String,
    values: lr,
    default: "text"
  },
  icon: {
    type: ft,
    default: () => Pd
  },
  iconColor: {
    type: String,
    default: "#f90"
  },
  hideIcon: {
    type: Boolean,
    default: !1
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  teleported: Pt.teleported,
  persistent: Pt.persistent,
  width: {
    type: [String, Number],
    default: 150
  }
}), wC = {
  confirm: (e) => e instanceof MouseEvent,
  cancel: (e) => e instanceof MouseEvent
}, kC = F({
  name: "ElPopconfirm"
}), SC = /* @__PURE__ */ F({
  ...kC,
  props: CC,
  emits: wC,
  setup(e, { emit: t }) {
    const n = e, { t: l } = ot(), o = se("popconfirm"), a = N(), r = () => {
      var f, h;
      (h = (f = a.value) == null ? void 0 : f.onClose) == null || h.call(f);
    }, i = k(() => ({
      width: It(n.width)
    })), u = (f) => {
      t("confirm", f), r();
    }, c = (f) => {
      t("cancel", f), r();
    }, p = k(() => n.confirmButtonText || l("el.popconfirm.confirmButtonText")), d = k(() => n.cancelButtonText || l("el.popconfirm.cancelButtonText"));
    return (f, h) => (E(), q(s(Wt), Be({
      ref_key: "tooltipRef",
      ref: a,
      trigger: "click",
      effect: "light"
    }, f.$attrs, {
      "popper-class": `${s(o).namespace.value}-popover`,
      "popper-style": s(i),
      teleported: f.teleported,
      "fallback-placements": ["bottom", "top", "right", "left"],
      "hide-after": f.hideAfter,
      persistent: f.persistent
    }), {
      content: K(() => [
        H("div", {
          class: $(s(o).b())
        }, [
          H("div", {
            class: $(s(o).e("main"))
          }, [
            !f.hideIcon && f.icon ? (E(), q(s(Se), {
              key: 0,
              class: $(s(o).e("icon")),
              style: ye({ color: f.iconColor })
            }, {
              default: K(() => [
                (E(), q(Ge(f.icon)))
              ]),
              _: 1
            }, 8, ["class", "style"])) : W("v-if", !0),
            st(" " + ce(f.title), 1)
          ], 2),
          H("div", {
            class: $(s(o).e("action"))
          }, [
            x(s(Kt), {
              size: "small",
              type: f.cancelButtonType === "text" ? "" : f.cancelButtonType,
              text: f.cancelButtonType === "text",
              onClick: c
            }, {
              default: K(() => [
                st(ce(s(d)), 1)
              ]),
              _: 1
            }, 8, ["type", "text"]),
            x(s(Kt), {
              size: "small",
              type: f.confirmButtonType === "text" ? "" : f.confirmButtonType,
              text: f.confirmButtonType === "text",
              onClick: u
            }, {
              default: K(() => [
                st(ce(s(p)), 1)
              ]),
              _: 1
            }, 8, ["type", "text"])
          ], 2)
        ], 2)
      ]),
      default: K(() => [
        f.$slots.reference ? ne(f.$slots, "reference", { key: 0 }) : W("v-if", !0)
      ]),
      _: 3
    }, 16, ["popper-class", "popper-style", "teleported", "hide-after", "persistent"]));
  }
});
var EC = /* @__PURE__ */ de(SC, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popconfirm/src/popconfirm.vue"]]);
const $C = xe(EC), TC = he({
  trigger: ys.trigger,
  placement: yo.placement,
  disabled: ys.disabled,
  visible: Pt.visible,
  transition: Pt.transition,
  popperOptions: yo.popperOptions,
  tabindex: yo.tabindex,
  content: Pt.content,
  popperStyle: Pt.popperStyle,
  popperClass: Pt.popperClass,
  enterable: {
    ...Pt.enterable,
    default: !0
  },
  effect: {
    ...Pt.effect,
    default: "light"
  },
  teleported: Pt.teleported,
  title: String,
  width: {
    type: [String, Number],
    default: 150
  },
  offset: {
    type: Number,
    default: void 0
  },
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: !0
  },
  persistent: {
    type: Boolean,
    default: !0
  },
  "onUpdate:visible": {
    type: Function
  }
}), NC = {
  "update:visible": (e) => Qt(e),
  "before-enter": () => !0,
  "before-leave": () => !0,
  "after-enter": () => !0,
  "after-leave": () => !0
}, IC = "onUpdate:visible", MC = F({
  name: "ElPopover"
}), RC = /* @__PURE__ */ F({
  ...MC,
  props: TC,
  emits: NC,
  setup(e, { expose: t, emit: n }) {
    const l = e, o = k(() => l[IC]), a = se("popover"), r = N(), i = k(() => {
      var g;
      return (g = s(r)) == null ? void 0 : g.popperRef;
    }), u = k(() => [
      {
        width: It(l.width)
      },
      l.popperStyle
    ]), c = k(() => [a.b(), l.popperClass, { [a.m("plain")]: !!l.content }]), p = k(() => l.transition === `${a.namespace.value}-fade-in-linear`), d = () => {
      var g;
      (g = r.value) == null || g.hide();
    }, f = () => {
      n("before-enter");
    }, h = () => {
      n("before-leave");
    }, v = () => {
      n("after-enter");
    }, m = () => {
      n("update:visible", !1), n("after-leave");
    };
    return t({
      popperRef: i,
      hide: d
    }), (g, w) => (E(), q(s(Wt), Be({
      ref_key: "tooltipRef",
      ref: r
    }, g.$attrs, {
      trigger: g.trigger,
      placement: g.placement,
      disabled: g.disabled,
      visible: g.visible,
      transition: g.transition,
      "popper-options": g.popperOptions,
      tabindex: g.tabindex,
      content: g.content,
      offset: g.offset,
      "show-after": g.showAfter,
      "hide-after": g.hideAfter,
      "auto-close": g.autoClose,
      "show-arrow": g.showArrow,
      "aria-label": g.title,
      effect: g.effect,
      enterable: g.enterable,
      "popper-class": s(c),
      "popper-style": s(u),
      teleported: g.teleported,
      persistent: g.persistent,
      "gpu-acceleration": s(p),
      "onUpdate:visible": s(o),
      onBeforeShow: f,
      onBeforeHide: h,
      onShow: v,
      onHide: m
    }), {
      content: K(() => [
        g.title ? (E(), _("div", {
          key: 0,
          class: $(s(a).e("title")),
          role: "title"
        }, ce(g.title), 3)) : W("v-if", !0),
        ne(g.$slots, "default", {}, () => [
          st(ce(g.content), 1)
        ])
      ]),
      default: K(() => [
        g.$slots.reference ? ne(g.$slots, "reference", { key: 0 }) : W("v-if", !0)
      ]),
      _: 3
    }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onUpdate:visible"]));
  }
});
var OC = /* @__PURE__ */ de(RC, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/popover.vue"]]);
const Pr = (e, t) => {
  const n = t.arg || t.value, l = n == null ? void 0 : n.popperRef;
  l && (l.triggerRef = e);
};
var PC = {
  mounted(e, t) {
    Pr(e, t);
  },
  updated(e, t) {
    Pr(e, t);
  }
};
const AC = "popover", Qu = Ad(PC, AC), _C = xe(OC, {
  directive: Qu
}), LC = he({
  type: {
    type: String,
    default: "line",
    values: ["line", "circle", "dashboard"]
  },
  percentage: {
    type: Number,
    default: 0,
    validator: (e) => e >= 0 && e <= 100
  },
  status: {
    type: String,
    default: "",
    values: ["", "success", "exception", "warning"]
  },
  indeterminate: {
    type: Boolean,
    default: !1
  },
  duration: {
    type: Number,
    default: 3
  },
  strokeWidth: {
    type: Number,
    default: 6
  },
  strokeLinecap: {
    type: j(String),
    default: "round"
  },
  textInside: {
    type: Boolean,
    default: !1
  },
  width: {
    type: Number,
    default: 126
  },
  showText: {
    type: Boolean,
    default: !0
  },
  color: {
    type: j([
      String,
      Array,
      Function
    ]),
    default: ""
  },
  format: {
    type: j(Function),
    default: (e) => `${e}%`
  }
}), VC = ["aria-valuenow"], BC = { viewBox: "0 0 100 100" }, DC = ["d", "stroke", "stroke-width"], xC = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"], FC = { key: 0 }, HC = F({
  name: "ElProgress"
}), zC = /* @__PURE__ */ F({
  ...HC,
  props: LC,
  setup(e) {
    const t = e, n = {
      success: "#13ce66",
      exception: "#ff4949",
      warning: "#e6a23c",
      default: "#20a0ff"
    }, l = se("progress"), o = k(() => ({
      width: `${t.percentage}%`,
      animationDuration: `${t.duration}s`,
      backgroundColor: C(t.percentage)
    })), a = k(() => (t.strokeWidth / t.width * 100).toFixed(1)), r = k(() => ["circle", "dashboard"].includes(t.type) ? Number.parseInt(`${50 - Number.parseFloat(a.value) / 2}`, 10) : 0), i = k(() => {
      const y = r.value, b = t.type === "dashboard";
      return `
          M 50 50
          m 0 ${b ? "" : "-"}${y}
          a ${y} ${y} 0 1 1 0 ${b ? "-" : ""}${y * 2}
          a ${y} ${y} 0 1 1 0 ${b ? "" : "-"}${y * 2}
          `;
    }), u = k(() => 2 * Math.PI * r.value), c = k(() => t.type === "dashboard" ? 0.75 : 1), p = k(() => `${-1 * u.value * (1 - c.value) / 2}px`), d = k(() => ({
      strokeDasharray: `${u.value * c.value}px, ${u.value}px`,
      strokeDashoffset: p.value
    })), f = k(() => ({
      strokeDasharray: `${u.value * c.value * (t.percentage / 100)}px, ${u.value}px`,
      strokeDashoffset: p.value,
      transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
    })), h = k(() => {
      let y;
      return t.color ? y = C(t.percentage) : y = n[t.status] || n.default, y;
    }), v = k(() => t.status === "warning" ? Ei : t.type === "line" ? t.status === "success" ? $i : Ko : t.status === "success" ? Xl : Sl), m = k(() => t.type === "line" ? 12 + t.strokeWidth * 0.4 : t.width * 0.111111 + 2), g = k(() => t.format(t.percentage));
    function w(y) {
      const b = 100 / y.length;
      return y.map((T, O) => Ue(T) ? {
        color: T,
        percentage: (O + 1) * b
      } : T).sort((T, O) => T.percentage - O.percentage);
    }
    const C = (y) => {
      var b;
      const { color: S } = t;
      if (mt(S))
        return S(y);
      if (Ue(S))
        return S;
      {
        const T = w(S);
        for (const O of T)
          if (O.percentage > y)
            return O.color;
        return (b = T[T.length - 1]) == null ? void 0 : b.color;
      }
    };
    return (y, b) => (E(), _("div", {
      class: $([
        s(l).b(),
        s(l).m(y.type),
        s(l).is(y.status),
        {
          [s(l).m("without-text")]: !y.showText,
          [s(l).m("text-inside")]: y.textInside
        }
      ]),
      role: "progressbar",
      "aria-valuenow": y.percentage,
      "aria-valuemin": "0",
      "aria-valuemax": "100"
    }, [
      y.type === "line" ? (E(), _("div", {
        key: 0,
        class: $(s(l).b("bar"))
      }, [
        H("div", {
          class: $(s(l).be("bar", "outer")),
          style: ye({ height: `${y.strokeWidth}px` })
        }, [
          H("div", {
            class: $([
              s(l).be("bar", "inner"),
              { [s(l).bem("bar", "inner", "indeterminate")]: y.indeterminate }
            ]),
            style: ye(s(o))
          }, [
            (y.showText || y.$slots.default) && y.textInside ? (E(), _("div", {
              key: 0,
              class: $(s(l).be("bar", "innerText"))
            }, [
              ne(y.$slots, "default", { percentage: y.percentage }, () => [
                H("span", null, ce(s(g)), 1)
              ])
            ], 2)) : W("v-if", !0)
          ], 6)
        ], 6)
      ], 2)) : (E(), _("div", {
        key: 1,
        class: $(s(l).b("circle")),
        style: ye({ height: `${y.width}px`, width: `${y.width}px` })
      }, [
        (E(), _("svg", BC, [
          H("path", {
            class: $(s(l).be("circle", "track")),
            d: s(i),
            stroke: `var(${s(l).cssVarName("fill-color-light")}, #e5e9f2)`,
            "stroke-width": s(a),
            fill: "none",
            style: ye(s(d))
          }, null, 14, DC),
          H("path", {
            class: $(s(l).be("circle", "path")),
            d: s(i),
            stroke: s(h),
            fill: "none",
            opacity: y.percentage ? 1 : 0,
            "stroke-linecap": y.strokeLinecap,
            "stroke-width": s(a),
            style: ye(s(f))
          }, null, 14, xC)
        ]))
      ], 6)),
      (y.showText || y.$slots.default) && !y.textInside ? (E(), _("div", {
        key: 2,
        class: $(s(l).e("text")),
        style: ye({ fontSize: `${s(m)}px` })
      }, [
        ne(y.$slots, "default", { percentage: y.percentage }, () => [
          y.status ? (E(), q(s(Se), { key: 1 }, {
            default: K(() => [
              (E(), q(Ge(s(v))))
            ]),
            _: 1
          })) : (E(), _("span", FC, ce(s(g)), 1))
        ])
      ], 6)) : W("v-if", !0)
    ], 10, VC));
  }
});
var KC = /* @__PURE__ */ de(zC, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]);
const ec = xe(KC), WC = he({
  modelValue: {
    type: Number,
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  lowThreshold: {
    type: Number,
    default: 2
  },
  highThreshold: {
    type: Number,
    default: 4
  },
  max: {
    type: Number,
    default: 5
  },
  colors: {
    type: j([Array, Object]),
    default: () => Et(["", "", ""])
  },
  voidColor: {
    type: String,
    default: ""
  },
  disabledVoidColor: {
    type: String,
    default: ""
  },
  icons: {
    type: j([Array, Object]),
    default: () => [no, no, no]
  },
  voidIcon: {
    type: ft,
    default: () => _d
  },
  disabledVoidIcon: {
    type: ft,
    default: () => no
  },
  disabled: Boolean,
  allowHalf: Boolean,
  showText: Boolean,
  showScore: Boolean,
  textColor: {
    type: String,
    default: ""
  },
  texts: {
    type: j(Array),
    default: () => Et([
      "Extremely bad",
      "Disappointed",
      "Fair",
      "Satisfied",
      "Surprise"
    ])
  },
  scoreTemplate: {
    type: String,
    default: "{value}"
  },
  size: Cn,
  label: {
    type: String,
    default: void 0
  },
  clearable: {
    type: Boolean,
    default: !1
  }
}), jC = {
  [vt]: (e) => Pe(e),
  [et]: (e) => Pe(e)
}, UC = ["id", "aria-label", "aria-labelledby", "aria-valuenow", "aria-valuetext", "aria-valuemax"], qC = ["onMousemove", "onClick"], GC = F({
  name: "ElRate"
}), YC = /* @__PURE__ */ F({
  ...GC,
  props: WC,
  emits: jC,
  setup(e, { expose: t, emit: n }) {
    const l = e;
    function o(V, M) {
      const P = (oe) => Ct(oe), L = Object.keys(M).map((oe) => +oe).filter((oe) => {
        const le = M[oe];
        return (P(le) ? le.excluded : !1) ? V < oe : V <= oe;
      }).sort((oe, le) => oe - le), U = M[L[0]];
      return P(U) && U.value || U;
    }
    const a = Oe(Ld, void 0), r = Oe(ra, void 0), i = dn(), u = se("rate"), { inputId: c, isLabeledByFormItem: p } = jo(l, {
      formItemContext: r
    }), d = N(l.modelValue), f = N(-1), h = N(!0), v = k(() => [u.b(), u.m(i.value)]), m = k(() => l.disabled || (a == null ? void 0 : a.disabled)), g = k(() => u.cssVarBlock({
      "void-color": l.voidColor,
      "disabled-void-color": l.disabledVoidColor,
      "fill-color": b.value
    })), w = k(() => {
      let V = "";
      return l.showScore ? V = l.scoreTemplate.replace(/\{\s*value\s*\}/, m.value ? `${l.modelValue}` : `${d.value}`) : l.showText && (V = l.texts[Math.ceil(d.value) - 1]), V;
    }), C = k(() => l.modelValue * 100 - Math.floor(l.modelValue) * 100), y = k(() => Je(l.colors) ? {
      [l.lowThreshold]: l.colors[0],
      [l.highThreshold]: { value: l.colors[1], excluded: !0 },
      [l.max]: l.colors[2]
    } : l.colors), b = k(() => {
      const V = o(d.value, y.value);
      return Ct(V) ? "" : V;
    }), S = k(() => {
      let V = "";
      return m.value ? V = `${C.value}%` : l.allowHalf && (V = "50%"), {
        color: b.value,
        width: V
      };
    }), T = k(() => {
      let V = Je(l.icons) ? [...l.icons] : { ...l.icons };
      return V = Rl(V), Je(V) ? {
        [l.lowThreshold]: V[0],
        [l.highThreshold]: {
          value: V[1],
          excluded: !0
        },
        [l.max]: V[2]
      } : V;
    }), O = k(() => o(l.modelValue, T.value)), I = k(() => m.value ? Ue(l.disabledVoidIcon) ? l.disabledVoidIcon : Rl(l.disabledVoidIcon) : Ue(l.voidIcon) ? l.voidIcon : Rl(l.voidIcon)), R = k(() => o(d.value, T.value));
    function B(V) {
      const M = m.value && C.value > 0 && V - 1 < l.modelValue && V > l.modelValue, P = l.allowHalf && h.value && V - 0.5 <= d.value && V > d.value;
      return M || P;
    }
    function D(V) {
      l.clearable && V === l.modelValue && (V = 0), n(et, V), l.modelValue !== V && n("change", V);
    }
    function A(V) {
      m.value || (l.allowHalf && h.value ? D(d.value) : D(V));
    }
    function z(V) {
      if (m.value)
        return;
      let M = d.value;
      const P = V.code;
      return P === Ce.up || P === Ce.right ? (l.allowHalf ? M += 0.5 : M += 1, V.stopPropagation(), V.preventDefault()) : (P === Ce.left || P === Ce.down) && (l.allowHalf ? M -= 0.5 : M -= 1, V.stopPropagation(), V.preventDefault()), M = M < 0 ? 0 : M, M = M > l.max ? l.max : M, n(et, M), n("change", M), M;
    }
    function Z(V, M) {
      if (!m.value) {
        if (l.allowHalf && M) {
          let P = M.target;
          Kn(P, u.e("item")) && (P = P.querySelector(`.${u.e("icon")}`)), (P.clientWidth === 0 || Kn(P, u.e("decimal"))) && (P = P.parentNode), h.value = M.offsetX * 2 <= P.clientWidth, d.value = h.value ? V - 0.5 : V;
        } else
          d.value = V;
        f.value = V;
      }
    }
    function J() {
      m.value || (l.allowHalf && (h.value = l.modelValue !== Math.floor(l.modelValue)), d.value = l.modelValue, f.value = -1);
    }
    return ue(() => l.modelValue, (V) => {
      d.value = V, h.value = l.modelValue !== Math.floor(l.modelValue);
    }), l.modelValue || n(et, 0), t({
      setCurrentValue: Z,
      resetCurrentValue: J
    }), (V, M) => {
      var P;
      return E(), _("div", {
        id: s(c),
        class: $([s(v), s(u).is("disabled", s(m))]),
        role: "slider",
        "aria-label": s(p) ? void 0 : V.label || "rating",
        "aria-labelledby": s(p) ? (P = s(r)) == null ? void 0 : P.labelId : void 0,
        "aria-valuenow": d.value,
        "aria-valuetext": s(w) || void 0,
        "aria-valuemin": "0",
        "aria-valuemax": V.max,
        tabindex: "0",
        style: ye(s(g)),
        onKeydown: z
      }, [
        (E(!0), _(Re, null, Xe(V.max, (L, U) => (E(), _("span", {
          key: U,
          class: $(s(u).e("item")),
          onMousemove: (oe) => Z(L, oe),
          onMouseleave: J,
          onClick: (oe) => A(L)
        }, [
          x(s(Se), {
            class: $([
              s(u).e("icon"),
              { hover: f.value === L },
              s(u).is("active", L <= d.value)
            ])
          }, {
            default: K(() => [
              B(L) ? W("v-if", !0) : (E(), _(Re, { key: 0 }, [
                qe((E(), q(Ge(s(R)), null, null, 512)), [
                  [at, L <= d.value]
                ]),
                qe((E(), q(Ge(s(I)), null, null, 512)), [
                  [at, !(L <= d.value)]
                ])
              ], 64)),
              B(L) ? (E(), q(s(Se), {
                key: 1,
                style: ye(s(S)),
                class: $([s(u).e("icon"), s(u).e("decimal")])
              }, {
                default: K(() => [
                  (E(), q(Ge(s(O))))
                ]),
                _: 1
              }, 8, ["style", "class"])) : W("v-if", !0)
            ]),
            _: 2
          }, 1032, ["class"])
        ], 42, qC))), 128)),
        V.showText || V.showScore ? (E(), _("span", {
          key: 0,
          class: $(s(u).e("text"))
        }, ce(s(w)), 3)) : W("v-if", !0)
      ], 46, UC);
    };
  }
});
var XC = /* @__PURE__ */ de(YC, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/rate/src/rate.vue"]]);
const ZC = xe(XC), ol = {
  success: "icon-success",
  warning: "icon-warning",
  error: "icon-error",
  info: "icon-info"
}, Ar = {
  [ol.success]: Vd,
  [ol.warning]: Ei,
  [ol.error]: Bd,
  [ol.info]: Dd
}, JC = he({
  title: {
    type: String,
    default: ""
  },
  subTitle: {
    type: String,
    default: ""
  },
  icon: {
    type: String,
    values: ["success", "warning", "info", "error"],
    default: "info"
  }
}), QC = F({
  name: "ElResult"
}), ew = /* @__PURE__ */ F({
  ...QC,
  props: JC,
  setup(e) {
    const t = e, n = se("result"), l = k(() => {
      const o = t.icon, a = o && ol[o] ? ol[o] : "icon-info", r = Ar[a] || Ar["icon-info"];
      return {
        class: a,
        component: r
      };
    });
    return (o, a) => (E(), _("div", {
      class: $(s(n).b())
    }, [
      H("div", {
        class: $(s(n).e("icon"))
      }, [
        ne(o.$slots, "icon", {}, () => [
          s(l).component ? (E(), q(Ge(s(l).component), {
            key: 0,
            class: $(s(l).class)
          }, null, 8, ["class"])) : W("v-if", !0)
        ])
      ], 2),
      o.title || o.$slots.title ? (E(), _("div", {
        key: 0,
        class: $(s(n).e("title"))
      }, [
        ne(o.$slots, "title", {}, () => [
          H("p", null, ce(o.title), 1)
        ])
      ], 2)) : W("v-if", !0),
      o.subTitle || o.$slots["sub-title"] ? (E(), _("div", {
        key: 1,
        class: $(s(n).e("subtitle"))
      }, [
        ne(o.$slots, "sub-title", {}, () => [
          H("p", null, ce(o.subTitle), 1)
        ])
      ], 2)) : W("v-if", !0),
      o.$slots.extra ? (E(), _("div", {
        key: 2,
        class: $(s(n).e("extra"))
      }, [
        ne(o.$slots, "extra")
      ], 2)) : W("v-if", !0)
    ], 2));
  }
});
var tw = /* @__PURE__ */ de(ew, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/result/src/result.vue"]]);
const nw = xe(tw);
var _r = Number.isNaN || function(t) {
  return typeof t == "number" && t !== t;
};
function lw(e, t) {
  return !!(e === t || _r(e) && _r(t));
}
function ow(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++)
    if (!lw(e[n], t[n]))
      return !1;
  return !0;
}
function sw(e, t) {
  t === void 0 && (t = ow);
  var n = null;
  function l() {
    for (var o = [], a = 0; a < arguments.length; a++)
      o[a] = arguments[a];
    if (n && n.lastThis === this && t(o, n.lastArgs))
      return n.lastResult;
    var r = e.apply(this, o);
    return n = {
      lastResult: r,
      lastArgs: o,
      lastThis: this
    }, r;
  }
  return l.clear = function() {
    n = null;
  }, l;
}
const tc = () => {
  const t = je().proxy.$props;
  return k(() => {
    const n = (l, o, a) => ({});
    return t.perfMode ? jf(n) : sw(n);
  });
}, _s = 50, Ao = "itemRendered", _o = "scroll", sl = "forward", Lo = "backward", qt = "auto", es = "smart", Hl = "start", rn = "center", zl = "end", gl = "horizontal", Ra = "vertical", aw = "ltr", dl = "rtl", Kl = "negative", Oa = "positive-ascending", Pa = "positive-descending", rw = {
  [gl]: "left",
  [Ra]: "top"
}, iw = 20, uw = {
  [gl]: "deltaX",
  [Ra]: "deltaY"
}, cw = ({ atEndEdge: e, atStartEdge: t, layout: n }, l) => {
  let o, a = 0;
  const r = (u) => u < 0 && t.value || u > 0 && e.value;
  return {
    hasReachedEdge: r,
    onWheel: (u) => {
      Xo(o);
      const c = u[uw[n.value]];
      r(a) && r(a + c) || (a += c, xd() || u.preventDefault(), o = Bl(() => {
        l(a), a = 0;
      }));
    }
  };
}, Ls = Qn({
  type: j([Number, Function]),
  required: !0
}), Vs = Qn({
  type: Number
}), Bs = Qn({
  type: Number,
  default: 2
}), dw = Qn({
  type: String,
  values: ["ltr", "rtl"],
  default: "ltr"
}), Ds = Qn({
  type: Number,
  default: 0
}), Vo = Qn({
  type: Number,
  required: !0
}), nc = Qn({
  type: String,
  values: ["horizontal", "vertical"],
  default: Ra
}), lc = he({
  className: {
    type: String,
    default: ""
  },
  containerElement: {
    type: j([String, Object]),
    default: "div"
  },
  data: {
    type: j(Array),
    default: () => Et([])
  },
  direction: dw,
  height: {
    type: [String, Number],
    required: !0
  },
  innerElement: {
    type: [String, Object],
    default: "div"
  },
  style: {
    type: j([Object, String, Array])
  },
  useIsScrolling: {
    type: Boolean,
    default: !1
  },
  width: {
    type: [Number, String],
    required: !1
  },
  perfMode: {
    type: Boolean,
    default: !0
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: !1
  }
}), oc = he({
  cache: Bs,
  estimatedItemSize: Vs,
  layout: nc,
  initScrollOffset: Ds,
  total: Vo,
  itemSize: Ls,
  ...lc
}), xs = {
  type: Number,
  default: 6
}, sc = { type: Number, default: 0 }, ac = { type: Number, default: 2 }, jn = he({
  columnCache: Bs,
  columnWidth: Ls,
  estimatedColumnWidth: Vs,
  estimatedRowHeight: Vs,
  initScrollLeft: Ds,
  initScrollTop: Ds,
  itemKey: {
    type: j(Function),
    default: ({
      columnIndex: e,
      rowIndex: t
    }) => `${t}:${e}`
  },
  rowCache: Bs,
  rowHeight: Ls,
  totalColumn: Vo,
  totalRow: Vo,
  hScrollbarSize: xs,
  vScrollbarSize: xs,
  scrollbarStartGap: sc,
  scrollbarEndGap: ac,
  role: String,
  ...lc
}), rc = he({
  alwaysOn: Boolean,
  class: String,
  layout: nc,
  total: Vo,
  ratio: {
    type: Number,
    required: !0
  },
  clientSize: {
    type: Number,
    required: !0
  },
  scrollFrom: {
    type: Number,
    required: !0
  },
  scrollbarSize: xs,
  startGap: sc,
  endGap: ac,
  visible: Boolean
}), Fn = (e, t) => e < t ? sl : Lo, Wl = (e) => e === aw || e === dl || e === gl, Lr = (e) => e === dl;
let el = null;
function Bo(e = !1) {
  if (el === null || e) {
    const t = document.createElement("div"), n = t.style;
    n.width = "50px", n.height = "50px", n.overflow = "scroll", n.direction = "rtl";
    const l = document.createElement("div"), o = l.style;
    return o.width = "100px", o.height = "100px", t.appendChild(l), document.body.appendChild(t), t.scrollLeft > 0 ? el = Pa : (t.scrollLeft = 1, t.scrollLeft === 0 ? el = Kl : el = Oa), document.body.removeChild(t), el;
  }
  return el;
}
function fw({ move: e, size: t, bar: n }, l) {
  const o = {}, a = `translate${n.axis}(${e}px)`;
  return o[n.size] = t, o.transform = a, o.msTransform = a, o.webkitTransform = a, l === "horizontal" ? o.height = "100%" : o.width = "100%", o;
}
const Fs = F({
  name: "ElVirtualScrollBar",
  props: rc,
  emits: ["scroll", "start-move", "stop-move"],
  setup(e, { emit: t }) {
    const n = k(() => e.startGap + e.endGap), l = se("virtual-scrollbar"), o = se("scrollbar"), a = N(), r = N();
    let i = null, u = null;
    const c = ct({
      isDragging: !1,
      traveled: 0
    }), p = k(() => Fd[e.layout]), d = k(() => e.clientSize - s(n)), f = k(() => ({
      position: "absolute",
      width: `${gl === e.layout ? d.value : e.scrollbarSize}px`,
      height: `${gl === e.layout ? e.scrollbarSize : d.value}px`,
      [rw[e.layout]]: "2px",
      right: "2px",
      bottom: "2px",
      borderRadius: "4px"
    })), h = k(() => {
      const T = e.ratio, O = e.clientSize;
      if (T >= 100)
        return Number.POSITIVE_INFINITY;
      if (T >= 50)
        return T * O / 100;
      const I = O / 3;
      return Math.floor(Math.min(Math.max(T * O, iw), I));
    }), v = k(() => {
      if (!Number.isFinite(h.value))
        return {
          display: "none"
        };
      const T = `${h.value}px`;
      return fw({
        bar: p.value,
        size: T,
        move: c.traveled
      }, e.layout);
    }), m = k(() => Math.floor(e.clientSize - h.value - s(n))), g = () => {
      window.addEventListener("mousemove", b), window.addEventListener("mouseup", y);
      const T = s(r);
      !T || (u = document.onselectstart, document.onselectstart = () => !1, T.addEventListener("touchmove", b), T.addEventListener("touchend", y));
    }, w = () => {
      window.removeEventListener("mousemove", b), window.removeEventListener("mouseup", y), document.onselectstart = u, u = null;
      const T = s(r);
      !T || (T.removeEventListener("touchmove", b), T.removeEventListener("touchend", y));
    }, C = (T) => {
      T.stopImmediatePropagation(), !(T.ctrlKey || [1, 2].includes(T.button)) && (c.isDragging = !0, c[p.value.axis] = T.currentTarget[p.value.offset] - (T[p.value.client] - T.currentTarget.getBoundingClientRect()[p.value.direction]), t("start-move"), g());
    }, y = () => {
      c.isDragging = !1, c[p.value.axis] = 0, t("stop-move"), w();
    }, b = (T) => {
      const { isDragging: O } = c;
      if (!O || !r.value || !a.value)
        return;
      const I = c[p.value.axis];
      if (!I)
        return;
      Xo(i);
      const R = (a.value.getBoundingClientRect()[p.value.direction] - T[p.value.client]) * -1, B = r.value[p.value.offset] - I, D = R - B;
      i = Bl(() => {
        c.traveled = Math.max(e.startGap, Math.min(D, m.value)), t("scroll", D, m.value);
      });
    }, S = (T) => {
      const O = Math.abs(T.target.getBoundingClientRect()[p.value.direction] - T[p.value.client]), I = r.value[p.value.offset] / 2, R = O - I;
      c.traveled = Math.max(0, Math.min(R, m.value)), t("scroll", R, m.value);
    };
    return ue(() => e.scrollFrom, (T) => {
      c.isDragging || (c.traveled = Math.ceil(T * m.value));
    }), Dt(() => {
      w();
    }), () => fe("div", {
      role: "presentation",
      ref: a,
      class: [
        l.b(),
        e.class,
        (e.alwaysOn || c.isDragging) && "always-on"
      ],
      style: f.value,
      onMousedown: Ae(S, ["stop", "prevent"]),
      onTouchstartPrevent: C
    }, fe("div", {
      ref: r,
      class: o.e("thumb"),
      style: v.value,
      onMousedown: C
    }, []));
  }
}), ic = ({
  name: e,
  getOffset: t,
  getItemSize: n,
  getItemOffset: l,
  getEstimatedTotalSize: o,
  getStartIndexForOffset: a,
  getStopIndexForStartIndex: r,
  initCache: i,
  clearCache: u,
  validateProps: c
}) => F({
  name: e != null ? e : "ElVirtualList",
  props: oc,
  emits: [Ao, _o],
  setup(p, { emit: d, expose: f }) {
    c(p);
    const h = je(), v = se("vl"), m = N(i(p, h)), g = tc(), w = N(), C = N(), y = N(), b = N({
      isScrolling: !1,
      scrollDir: "forward",
      scrollOffset: Pe(p.initScrollOffset) ? p.initScrollOffset : 0,
      updateRequested: !1,
      isScrollbarDragging: !1,
      scrollbarAlwaysOn: p.scrollbarAlwaysOn
    }), S = k(() => {
      const { total: ee, cache: pe } = p, { isScrolling: ge, scrollDir: te, scrollOffset: ve } = s(b);
      if (ee === 0)
        return [0, 0, 0, 0];
      const G = a(p, ve, s(m)), Q = r(p, G, ve, s(m)), ie = !ge || te === Lo ? Math.max(1, pe) : 1, Ee = !ge || te === sl ? Math.max(1, pe) : 1;
      return [
        Math.max(0, G - ie),
        Math.max(0, Math.min(ee - 1, Q + Ee)),
        G,
        Q
      ];
    }), T = k(() => o(p, s(m))), O = k(() => Wl(p.layout)), I = k(() => [
      {
        position: "relative",
        [`overflow-${O.value ? "x" : "y"}`]: "scroll",
        WebkitOverflowScrolling: "touch",
        willChange: "transform"
      },
      {
        direction: p.direction,
        height: Pe(p.height) ? `${p.height}px` : p.height,
        width: Pe(p.width) ? `${p.width}px` : p.width
      },
      p.style
    ]), R = k(() => {
      const ee = s(T), pe = s(O);
      return {
        height: pe ? "100%" : `${ee}px`,
        pointerEvents: s(b).isScrolling ? "none" : void 0,
        width: pe ? `${ee}px` : "100%"
      };
    }), B = k(() => O.value ? p.width : p.height), { onWheel: D } = cw({
      atStartEdge: k(() => b.value.scrollOffset <= 0),
      atEndEdge: k(() => b.value.scrollOffset >= T.value),
      layout: k(() => p.layout)
    }, (ee) => {
      var pe, ge;
      (ge = (pe = y.value).onMouseUp) == null || ge.call(pe), M(Math.min(b.value.scrollOffset + ee, T.value - B.value));
    }), A = () => {
      const { total: ee } = p;
      if (ee > 0) {
        const [ve, G, Q, ie] = s(S);
        d(Ao, ve, G, Q, ie);
      }
      const { scrollDir: pe, scrollOffset: ge, updateRequested: te } = s(b);
      d(_o, pe, ge, te);
    }, z = (ee) => {
      const { clientHeight: pe, scrollHeight: ge, scrollTop: te } = ee.currentTarget, ve = s(b);
      if (ve.scrollOffset === te)
        return;
      const G = Math.max(0, Math.min(te, ge - pe));
      b.value = {
        ...ve,
        isScrolling: !0,
        scrollDir: Fn(ve.scrollOffset, G),
        scrollOffset: G,
        updateRequested: !1
      }, Ne(U);
    }, Z = (ee) => {
      const { clientWidth: pe, scrollLeft: ge, scrollWidth: te } = ee.currentTarget, ve = s(b);
      if (ve.scrollOffset === ge)
        return;
      const { direction: G } = p;
      let Q = ge;
      if (G === dl)
        switch (Bo()) {
          case Kl: {
            Q = -ge;
            break;
          }
          case Pa: {
            Q = te - pe - ge;
            break;
          }
        }
      Q = Math.max(0, Math.min(Q, te - pe)), b.value = {
        ...ve,
        isScrolling: !0,
        scrollDir: Fn(ve.scrollOffset, Q),
        scrollOffset: Q,
        updateRequested: !1
      }, Ne(U);
    }, J = (ee) => {
      s(O) ? Z(ee) : z(ee), A();
    }, V = (ee, pe) => {
      const ge = (T.value - B.value) / pe * ee;
      M(Math.min(T.value - B.value, ge));
    }, M = (ee) => {
      ee = Math.max(ee, 0), ee !== s(b).scrollOffset && (b.value = {
        ...s(b),
        scrollOffset: ee,
        scrollDir: Fn(s(b).scrollOffset, ee),
        updateRequested: !0
      }, Ne(U));
    }, P = (ee, pe = qt) => {
      const { scrollOffset: ge } = s(b);
      ee = Math.max(0, Math.min(ee, p.total - 1)), M(t(p, ee, pe, ge, s(m)));
    }, L = (ee) => {
      const { direction: pe, itemSize: ge, layout: te } = p, ve = g.value(u && ge, u && te, u && pe);
      let G;
      if (Bt(ve, String(ee)))
        G = ve[ee];
      else {
        const Q = l(p, ee, s(m)), ie = n(p, ee, s(m)), Ee = s(O), De = pe === dl, Ve = Ee ? Q : 0;
        ve[ee] = G = {
          position: "absolute",
          left: De ? void 0 : `${Ve}px`,
          right: De ? `${Ve}px` : void 0,
          top: Ee ? 0 : `${Q}px`,
          height: Ee ? "100%" : `${ie}px`,
          width: Ee ? `${ie}px` : "100%"
        };
      }
      return G;
    }, U = () => {
      b.value.isScrolling = !1, Ne(() => {
        g.value(-1, null, null);
      });
    }, oe = () => {
      const ee = w.value;
      ee && (ee.scrollTop = 0);
    };
    We(() => {
      if (!rt)
        return;
      const { initScrollOffset: ee } = p, pe = s(w);
      Pe(ee) && pe && (s(O) ? pe.scrollLeft = ee : pe.scrollTop = ee), A();
    }), fa(() => {
      const { direction: ee, layout: pe } = p, { scrollOffset: ge, updateRequested: te } = s(b), ve = s(w);
      if (te && ve)
        if (pe === gl)
          if (ee === dl)
            switch (Bo()) {
              case Kl: {
                ve.scrollLeft = -ge;
                break;
              }
              case Oa: {
                ve.scrollLeft = ge;
                break;
              }
              default: {
                const { clientWidth: G, scrollWidth: Q } = ve;
                ve.scrollLeft = Q - G - ge;
                break;
              }
            }
          else
            ve.scrollLeft = ge;
        else
          ve.scrollTop = ge;
    });
    const le = {
      ns: v,
      clientSize: B,
      estimatedTotalSize: T,
      windowStyle: I,
      windowRef: w,
      innerRef: C,
      innerStyle: R,
      itemsToRender: S,
      scrollbarRef: y,
      states: b,
      getItemStyle: L,
      onScroll: J,
      onScrollbarScroll: V,
      onWheel: D,
      scrollTo: M,
      scrollToItem: P,
      resetScrollTop: oe
    };
    return f({
      windowRef: w,
      innerRef: C,
      getItemStyleCache: g,
      scrollTo: M,
      scrollToItem: P,
      resetScrollTop: oe,
      states: b
    }), le;
  },
  render(p) {
    var d;
    const {
      $slots: f,
      className: h,
      clientSize: v,
      containerElement: m,
      data: g,
      getItemStyle: w,
      innerElement: C,
      itemsToRender: y,
      innerStyle: b,
      layout: S,
      total: T,
      onScroll: O,
      onScrollbarScroll: I,
      onWheel: R,
      states: B,
      useIsScrolling: D,
      windowStyle: A,
      ns: z
    } = p, [Z, J] = y, V = Ge(m), M = Ge(C), P = [];
    if (T > 0)
      for (let le = Z; le <= J; le++)
        P.push((d = f.default) == null ? void 0 : d.call(f, {
          data: g,
          key: le,
          index: le,
          isScrolling: D ? B.isScrolling : void 0,
          style: w(le)
        }));
    const L = [
      fe(M, {
        style: b,
        ref: "innerRef"
      }, Ue(M) ? P : {
        default: () => P
      })
    ], U = fe(Fs, {
      ref: "scrollbarRef",
      clientSize: v,
      layout: S,
      onScroll: I,
      ratio: v * 100 / this.estimatedTotalSize,
      scrollFrom: B.scrollOffset / (this.estimatedTotalSize - v),
      total: T
    }), oe = fe(V, {
      class: [z.e("window"), h],
      style: A,
      onScroll: O,
      onWheel: R,
      ref: "windowRef",
      key: 0
    }, Ue(V) ? [L] : { default: () => [L] });
    return fe("div", {
      key: 0,
      class: [z.e("wrapper"), B.scrollbarAlwaysOn ? "always-on" : ""]
    }, [oe, U]);
  }
}), uc = ic({
  name: "ElFixedSizeList",
  getItemOffset: ({ itemSize: e }, t) => t * e,
  getItemSize: ({ itemSize: e }) => e,
  getEstimatedTotalSize: ({ total: e, itemSize: t }) => t * e,
  getOffset: ({ height: e, total: t, itemSize: n, layout: l, width: o }, a, r, i) => {
    const u = Wl(l) ? o : e;
    process.env.NODE_ENV !== "production" && Ue(u) && wt("[ElVirtualList]", `
        You should set
          width/height
        to number when your layout is
          horizontal/vertical
      `);
    const c = Math.max(0, t * n - u), p = Math.min(c, a * n), d = Math.max(0, (a + 1) * n - u);
    switch (r === es && (i >= d - u && i <= p + u ? r = qt : r = rn), r) {
      case Hl:
        return p;
      case zl:
        return d;
      case rn: {
        const f = Math.round(d + (p - d) / 2);
        return f < Math.ceil(u / 2) ? 0 : f > c + Math.floor(u / 2) ? c : f;
      }
      case qt:
      default:
        return i >= d && i <= p ? i : i < d ? d : p;
    }
  },
  getStartIndexForOffset: ({ total: e, itemSize: t }, n) => Math.max(0, Math.min(e - 1, Math.floor(n / t))),
  getStopIndexForStartIndex: ({ height: e, total: t, itemSize: n, layout: l, width: o }, a, r) => {
    const i = a * n, u = Wl(l) ? o : e, c = Math.ceil((u + r - i) / n);
    return Math.max(0, Math.min(t - 1, a + c - 1));
  },
  initCache() {
  },
  clearCache: !0,
  validateProps() {
  }
}), pw = "ElDynamicSizeList", al = (e, t, n) => {
  const { itemSize: l } = e, { items: o, lastVisitedIndex: a } = n;
  if (t > a) {
    let r = 0;
    if (a >= 0) {
      const i = o[a];
      r = i.offset + i.size;
    }
    for (let i = a + 1; i <= t; i++) {
      const u = l(i);
      o[i] = {
        offset: r,
        size: u
      }, r += u;
    }
    n.lastVisitedIndex = t;
  }
  return o[t];
}, hw = (e, t, n) => {
  const { items: l, lastVisitedIndex: o } = t;
  return (o > 0 ? l[o].offset : 0) >= n ? cc(e, t, 0, o, n) : vw(e, t, Math.max(0, o), n);
}, cc = (e, t, n, l, o) => {
  for (; n <= l; ) {
    const a = n + Math.floor((l - n) / 2), r = al(e, a, t).offset;
    if (r === o)
      return a;
    r < o ? n = a + 1 : r > o && (l = a - 1);
  }
  return Math.max(0, n - 1);
}, vw = (e, t, n, l) => {
  const { total: o } = e;
  let a = 1;
  for (; n < o && al(e, n, t).offset < l; )
    n += a, a *= 2;
  return cc(e, t, Math.floor(n / 2), Math.min(n, o - 1), l);
}, Vr = ({ total: e }, { items: t, estimatedItemSize: n, lastVisitedIndex: l }) => {
  let o = 0;
  if (l >= e && (l = e - 1), l >= 0) {
    const i = t[l];
    o = i.offset + i.size;
  }
  const r = (e - l - 1) * n;
  return o + r;
}, mw = ic({
  name: "ElDynamicSizeList",
  getItemOffset: (e, t, n) => al(e, t, n).offset,
  getItemSize: (e, t, { items: n }) => n[t].size,
  getEstimatedTotalSize: Vr,
  getOffset: (e, t, n, l, o) => {
    const { height: a, layout: r, width: i } = e, u = Wl(r) ? i : a, c = al(e, t, o), p = Vr(e, o), d = Math.max(0, Math.min(p - u, c.offset)), f = Math.max(0, c.offset - u + c.size);
    switch (n === es && (l >= f - u && l <= d + u ? n = qt : n = rn), n) {
      case Hl:
        return d;
      case zl:
        return f;
      case rn:
        return Math.round(f + (d - f) / 2);
      case qt:
      default:
        return l >= f && l <= d ? l : l < f ? f : d;
    }
  },
  getStartIndexForOffset: (e, t, n) => hw(e, n, t),
  getStopIndexForStartIndex: (e, t, n, l) => {
    const { height: o, total: a, layout: r, width: i } = e, u = Wl(r) ? i : o, c = al(e, t, l), p = n + u;
    let d = c.offset + c.size, f = t;
    for (; f < a - 1 && d < p; )
      f++, d += al(e, f, l).size;
    return f;
  },
  initCache({ estimatedItemSize: e = _s }, t) {
    const n = {
      items: {},
      estimatedItemSize: e,
      lastVisitedIndex: -1
    };
    return n.clearCacheAfterIndex = (l, o = !0) => {
      var a, r;
      n.lastVisitedIndex = Math.min(n.lastVisitedIndex, l - 1), (a = t.exposed) == null || a.getItemStyleCache(-1), o && ((r = t.proxy) == null || r.$forceUpdate());
    }, n;
  },
  clearCache: !1,
  validateProps: ({ itemSize: e }) => {
    process.env.NODE_ENV !== "production" && typeof e != "function" && wt(pw, `
          itemSize is required as function, but the given value was ${typeof e}
        `);
  }
}), gw = ({ atXEndEdge: e, atXStartEdge: t, atYEndEdge: n, atYStartEdge: l }, o) => {
  let a = null, r = 0, i = 0;
  const u = (p, d) => {
    const f = p <= 0 && t.value || p >= 0 && e.value, h = d <= 0 && l.value || d >= 0 && n.value;
    return f && h;
  };
  return {
    hasReachedEdge: u,
    onWheel: (p) => {
      Xo(a);
      let d = p.deltaX, f = p.deltaY;
      Math.abs(d) > Math.abs(f) ? f = 0 : d = 0, p.shiftKey && f !== 0 && (d = f, f = 0), !(u(r, i) && u(r + d, i + f)) && (r += d, i += f, p.preventDefault(), a = Bl(() => {
        o(r, i), r = 0, i = 0;
      }));
    }
  };
}, dc = ({
  name: e,
  clearCache: t,
  getColumnPosition: n,
  getColumnStartIndexForOffset: l,
  getColumnStopIndexForStartIndex: o,
  getEstimatedTotalHeight: a,
  getEstimatedTotalWidth: r,
  getColumnOffset: i,
  getRowOffset: u,
  getRowPosition: c,
  getRowStartIndexForOffset: p,
  getRowStopIndexForStartIndex: d,
  initCache: f,
  injectToInstance: h,
  validateProps: v
}) => F({
  name: e != null ? e : "ElVirtualList",
  props: jn,
  emits: [Ao, _o],
  setup(m, { emit: g, expose: w, slots: C }) {
    const y = se("vl");
    v(m);
    const b = je(), S = N(f(m, b));
    h == null || h(b, S);
    const T = N(), O = N(), I = N(), R = N(null), B = N({
      isScrolling: !1,
      scrollLeft: Pe(m.initScrollLeft) ? m.initScrollLeft : 0,
      scrollTop: Pe(m.initScrollTop) ? m.initScrollTop : 0,
      updateRequested: !1,
      xAxisScrollDir: sl,
      yAxisScrollDir: sl
    }), D = tc(), A = k(() => Number.parseInt(`${m.height}`, 10)), z = k(() => Number.parseInt(`${m.width}`, 10)), Z = k(() => {
      const { totalColumn: be, totalRow: Te, columnCache: we } = m, { isScrolling: _e, xAxisScrollDir: Ie, scrollLeft: Le } = s(B);
      if (be === 0 || Te === 0)
        return [0, 0, 0, 0];
      const Ke = l(m, Le, s(S)), Ye = o(m, Ke, Le, s(S)), nt = !_e || Ie === Lo ? Math.max(1, we) : 1, gt = !_e || Ie === sl ? Math.max(1, we) : 1;
      return [
        Math.max(0, Ke - nt),
        Math.max(0, Math.min(be - 1, Ye + gt)),
        Ke,
        Ye
      ];
    }), J = k(() => {
      const { totalColumn: be, totalRow: Te, rowCache: we } = m, { isScrolling: _e, yAxisScrollDir: Ie, scrollTop: Le } = s(B);
      if (be === 0 || Te === 0)
        return [0, 0, 0, 0];
      const Ke = p(m, Le, s(S)), Ye = d(m, Ke, Le, s(S)), nt = !_e || Ie === Lo ? Math.max(1, we) : 1, gt = !_e || Ie === sl ? Math.max(1, we) : 1;
      return [
        Math.max(0, Ke - nt),
        Math.max(0, Math.min(Te - 1, Ye + gt)),
        Ke,
        Ye
      ];
    }), V = k(() => a(m, s(S))), M = k(() => r(m, s(S))), P = k(() => {
      var be;
      return [
        {
          position: "relative",
          overflow: "hidden",
          WebkitOverflowScrolling: "touch",
          willChange: "transform"
        },
        {
          direction: m.direction,
          height: Pe(m.height) ? `${m.height}px` : m.height,
          width: Pe(m.width) ? `${m.width}px` : m.width
        },
        (be = m.style) != null ? be : {}
      ];
    }), L = k(() => {
      const be = `${s(M)}px`;
      return {
        height: `${s(V)}px`,
        pointerEvents: s(B).isScrolling ? "none" : void 0,
        width: be
      };
    }), U = () => {
      const { totalColumn: be, totalRow: Te } = m;
      if (be > 0 && Te > 0) {
        const [
          Ye,
          nt,
          gt,
          kt
        ] = s(Z), [St, yt, ke, Y] = s(J);
        g(Ao, {
          columnCacheStart: Ye,
          columnCacheEnd: nt,
          rowCacheStart: St,
          rowCacheEnd: yt,
          columnVisibleStart: gt,
          columnVisibleEnd: kt,
          rowVisibleStart: ke,
          rowVisibleEnd: Y
        });
      }
      const {
        scrollLeft: we,
        scrollTop: _e,
        updateRequested: Ie,
        xAxisScrollDir: Le,
        yAxisScrollDir: Ke
      } = s(B);
      g(_o, {
        xAxisScrollDir: Le,
        scrollLeft: we,
        yAxisScrollDir: Ke,
        scrollTop: _e,
        updateRequested: Ie
      });
    }, oe = (be) => {
      const {
        clientHeight: Te,
        clientWidth: we,
        scrollHeight: _e,
        scrollLeft: Ie,
        scrollTop: Le,
        scrollWidth: Ke
      } = be.currentTarget, Ye = s(B);
      if (Ye.scrollTop === Le && Ye.scrollLeft === Ie)
        return;
      let nt = Ie;
      if (Lr(m.direction))
        switch (Bo()) {
          case Kl:
            nt = -Ie;
            break;
          case Pa:
            nt = Ke - we - Ie;
            break;
        }
      B.value = {
        ...Ye,
        isScrolling: !0,
        scrollLeft: nt,
        scrollTop: Math.max(0, Math.min(Le, _e - Te)),
        updateRequested: !0,
        xAxisScrollDir: Fn(Ye.scrollLeft, nt),
        yAxisScrollDir: Fn(Ye.scrollTop, Le)
      }, Ne(() => G()), Q(), U();
    }, le = (be, Te) => {
      const we = s(A), _e = (V.value - we) / Te * be;
      ge({
        scrollTop: Math.min(V.value - we, _e)
      });
    }, ee = (be, Te) => {
      const we = s(z), _e = (M.value - we) / Te * be;
      ge({
        scrollLeft: Math.min(M.value - we, _e)
      });
    }, { onWheel: pe } = gw({
      atXStartEdge: k(() => B.value.scrollLeft <= 0),
      atXEndEdge: k(() => B.value.scrollLeft >= M.value - s(z)),
      atYStartEdge: k(() => B.value.scrollTop <= 0),
      atYEndEdge: k(() => B.value.scrollTop >= V.value - s(A))
    }, (be, Te) => {
      var we, _e, Ie, Le;
      (_e = (we = O.value) == null ? void 0 : we.onMouseUp) == null || _e.call(we), (Le = (Ie = O.value) == null ? void 0 : Ie.onMouseUp) == null || Le.call(Ie);
      const Ke = s(z), Ye = s(A);
      ge({
        scrollLeft: Math.min(B.value.scrollLeft + be, M.value - Ke),
        scrollTop: Math.min(B.value.scrollTop + Te, V.value - Ye)
      });
    }), ge = ({
      scrollLeft: be = B.value.scrollLeft,
      scrollTop: Te = B.value.scrollTop
    }) => {
      be = Math.max(be, 0), Te = Math.max(Te, 0);
      const we = s(B);
      Te === we.scrollTop && be === we.scrollLeft || (B.value = {
        ...we,
        xAxisScrollDir: Fn(we.scrollLeft, be),
        yAxisScrollDir: Fn(we.scrollTop, Te),
        scrollLeft: be,
        scrollTop: Te,
        updateRequested: !0
      }, Ne(() => G()), Q(), U());
    }, te = (be = 0, Te = 0, we = qt) => {
      const _e = s(B);
      Te = Math.max(0, Math.min(Te, m.totalColumn - 1)), be = Math.max(0, Math.min(be, m.totalRow - 1));
      const Ie = Hd(y.namespace.value), Le = s(S), Ke = a(m, Le), Ye = r(m, Le);
      ge({
        scrollLeft: i(m, Te, we, _e.scrollLeft, Le, Ye > m.width ? Ie : 0),
        scrollTop: u(m, be, we, _e.scrollTop, Le, Ke > m.height ? Ie : 0)
      });
    }, ve = (be, Te) => {
      const { columnWidth: we, direction: _e, rowHeight: Ie } = m, Le = D.value(t && we, t && Ie, t && _e), Ke = `${be},${Te}`;
      if (Bt(Le, Ke))
        return Le[Ke];
      {
        const [, Ye] = n(m, Te, s(S)), nt = s(S), gt = Lr(_e), [kt, St] = c(m, be, nt), [yt] = n(m, Te, nt);
        return Le[Ke] = {
          position: "absolute",
          left: gt ? void 0 : `${Ye}px`,
          right: gt ? `${Ye}px` : void 0,
          top: `${St}px`,
          height: `${kt}px`,
          width: `${yt}px`
        }, Le[Ke];
      }
    }, G = () => {
      B.value.isScrolling = !1, Ne(() => {
        D.value(-1, null, null);
      });
    };
    We(() => {
      if (!rt)
        return;
      const { initScrollLeft: be, initScrollTop: Te } = m, we = s(T);
      we && (Pe(be) && (we.scrollLeft = be), Pe(Te) && (we.scrollTop = Te)), U();
    });
    const Q = () => {
      const { direction: be } = m, { scrollLeft: Te, scrollTop: we, updateRequested: _e } = s(B), Ie = s(T);
      if (_e && Ie) {
        if (be === dl)
          switch (Bo()) {
            case Kl: {
              Ie.scrollLeft = -Te;
              break;
            }
            case Oa: {
              Ie.scrollLeft = Te;
              break;
            }
            default: {
              const { clientWidth: Le, scrollWidth: Ke } = Ie;
              Ie.scrollLeft = Ke - Le - Te;
              break;
            }
          }
        else
          Ie.scrollLeft = Math.max(0, Te);
        Ie.scrollTop = Math.max(0, we);
      }
    }, { resetAfterColumnIndex: ie, resetAfterRowIndex: Ee, resetAfter: De } = b.proxy;
    w({
      windowRef: T,
      innerRef: R,
      getItemStyleCache: D,
      scrollTo: ge,
      scrollToItem: te,
      states: B,
      resetAfterColumnIndex: ie,
      resetAfterRowIndex: Ee,
      resetAfter: De
    });
    const Ve = () => {
      const {
        scrollbarAlwaysOn: be,
        scrollbarStartGap: Te,
        scrollbarEndGap: we,
        totalColumn: _e,
        totalRow: Ie
      } = m, Le = s(z), Ke = s(A), Ye = s(M), nt = s(V), { scrollLeft: gt, scrollTop: kt } = s(B), St = fe(Fs, {
        ref: O,
        alwaysOn: be,
        startGap: Te,
        endGap: we,
        class: y.e("horizontal"),
        clientSize: Le,
        layout: "horizontal",
        onScroll: ee,
        ratio: Le * 100 / Ye,
        scrollFrom: gt / (Ye - Le),
        total: Ie,
        visible: !0
      }), yt = fe(Fs, {
        ref: I,
        alwaysOn: be,
        startGap: Te,
        endGap: we,
        class: y.e("vertical"),
        clientSize: Ke,
        layout: "vertical",
        onScroll: le,
        ratio: Ke * 100 / nt,
        scrollFrom: kt / (nt - Ke),
        total: _e,
        visible: !0
      });
      return {
        horizontalScrollbar: St,
        verticalScrollbar: yt
      };
    }, Fe = () => {
      var be;
      const [Te, we] = s(Z), [_e, Ie] = s(J), { data: Le, totalColumn: Ke, totalRow: Ye, useIsScrolling: nt, itemKey: gt } = m, kt = [];
      if (Ye > 0 && Ke > 0)
        for (let St = _e; St <= Ie; St++)
          for (let yt = Te; yt <= we; yt++)
            kt.push((be = C.default) == null ? void 0 : be.call(C, {
              columnIndex: yt,
              data: Le,
              key: gt({ columnIndex: yt, data: Le, rowIndex: St }),
              isScrolling: nt ? s(B).isScrolling : void 0,
              style: ve(St, yt),
              rowIndex: St
            }));
      return kt;
    }, ze = () => {
      const be = Ge(m.innerElement), Te = Fe();
      return [
        fe(be, {
          style: s(L),
          ref: R
        }, Ue(be) ? Te : {
          default: () => Te
        })
      ];
    };
    return () => {
      const be = Ge(m.containerElement), { horizontalScrollbar: Te, verticalScrollbar: we } = Ve(), _e = ze();
      return fe("div", {
        key: 0,
        class: y.e("wrapper"),
        role: m.role
      }, [
        fe(be, {
          class: m.className,
          style: s(P),
          onScroll: oe,
          onWheel: pe,
          ref: T
        }, Ue(be) ? _e : { default: () => _e }),
        Te,
        we
      ]);
    };
  }
}), Br = "ElFixedSizeGrid", yw = dc({
  name: "ElFixedSizeGrid",
  getColumnPosition: ({ columnWidth: e }, t) => [
    e,
    t * e
  ],
  getRowPosition: ({ rowHeight: e }, t) => [
    e,
    t * e
  ],
  getEstimatedTotalHeight: ({ totalRow: e, rowHeight: t }) => t * e,
  getEstimatedTotalWidth: ({ totalColumn: e, columnWidth: t }) => t * e,
  getColumnOffset: ({ totalColumn: e, columnWidth: t, width: n }, l, o, a, r, i) => {
    n = Number(n);
    const u = Math.max(0, e * t - n), c = Math.min(u, l * t), p = Math.max(0, l * t - n + i + t);
    switch (o === "smart" && (a >= p - n && a <= c + n ? o = qt : o = rn), o) {
      case Hl:
        return c;
      case zl:
        return p;
      case rn: {
        const d = Math.round(p + (c - p) / 2);
        return d < Math.ceil(n / 2) ? 0 : d > u + Math.floor(n / 2) ? u : d;
      }
      case qt:
      default:
        return a >= p && a <= c ? a : p > c || a < p ? p : c;
    }
  },
  getRowOffset: ({ rowHeight: e, height: t, totalRow: n }, l, o, a, r, i) => {
    t = Number(t);
    const u = Math.max(0, n * e - t), c = Math.min(u, l * e), p = Math.max(0, l * e - t + i + e);
    switch (o === es && (a >= p - t && a <= c + t ? o = qt : o = rn), o) {
      case Hl:
        return c;
      case zl:
        return p;
      case rn: {
        const d = Math.round(p + (c - p) / 2);
        return d < Math.ceil(t / 2) ? 0 : d > u + Math.floor(t / 2) ? u : d;
      }
      case qt:
      default:
        return a >= p && a <= c ? a : p > c || a < p ? p : c;
    }
  },
  getColumnStartIndexForOffset: ({ columnWidth: e, totalColumn: t }, n) => Math.max(0, Math.min(t - 1, Math.floor(n / e))),
  getColumnStopIndexForStartIndex: ({ columnWidth: e, totalColumn: t, width: n }, l, o) => {
    const a = l * e, r = Math.ceil((n + o - a) / e);
    return Math.max(0, Math.min(t - 1, l + r - 1));
  },
  getRowStartIndexForOffset: ({ rowHeight: e, totalRow: t }, n) => Math.max(0, Math.min(t - 1, Math.floor(n / e))),
  getRowStopIndexForStartIndex: ({ rowHeight: e, totalRow: t, height: n }, l, o) => {
    const a = l * e, r = Math.ceil((n + o - a) / e);
    return Math.max(0, Math.min(t - 1, l + r - 1));
  },
  initCache: () => {
  },
  clearCache: !0,
  validateProps: ({ columnWidth: e, rowHeight: t }) => {
    process.env.NODE_ENV !== "production" && (Pe(e) || wt(Br, `
          "columnWidth" must be passed as number,
            instead ${typeof e} was given.
        `), Pe(t) || wt(Br, `
          "columnWidth" must be passed as number,
            instead ${typeof t} was given.
        `));
  }
}), { max: Do, min: fc, floor: pc } = Math, Dr = "ElDynamicSizeGrid", bw = {
  column: "columnWidth",
  row: "rowHeight"
}, Hs = {
  column: "lastVisitedColumnIndex",
  row: "lastVisitedRowIndex"
}, mn = (e, t, n, l) => {
  const [o, a, r] = [
    n[l],
    e[bw[l]],
    n[Hs[l]]
  ];
  if (t > r) {
    let i = 0;
    if (r >= 0) {
      const u = o[r];
      i = u.offset + u.size;
    }
    for (let u = r + 1; u <= t; u++) {
      const c = a(u);
      o[u] = {
        offset: i,
        size: c
      }, i += c;
    }
    n[Hs[l]] = t;
  }
  return o[t];
}, hc = (e, t, n, l, o, a) => {
  for (; n <= l; ) {
    const r = n + pc((l - n) / 2), i = mn(e, r, t, a).offset;
    if (i === o)
      return r;
    i < o ? n = r + 1 : l = r - 1;
  }
  return Do(0, n - 1);
}, Cw = (e, t, n, l, o) => {
  const a = o === "column" ? e.totalColumn : e.totalRow;
  let r = 1;
  for (; n < a && mn(e, n, t, o).offset < l; )
    n += r, r *= 2;
  return hc(e, t, pc(n / 2), fc(n, a - 1), l, o);
}, xr = (e, t, n, l) => {
  const [o, a] = [
    t[l],
    t[Hs[l]]
  ];
  return (a > 0 ? o[a].offset : 0) >= n ? hc(e, t, 0, a, n, l) : Cw(e, t, Do(0, a), n, l);
}, vc = ({ totalRow: e }, { estimatedRowHeight: t, lastVisitedRowIndex: n, row: l }) => {
  let o = 0;
  if (n >= e && (n = e - 1), n >= 0) {
    const i = l[n];
    o = i.offset + i.size;
  }
  const r = (e - n - 1) * t;
  return o + r;
}, mc = ({ totalColumn: e }, { column: t, estimatedColumnWidth: n, lastVisitedColumnIndex: l }) => {
  let o = 0;
  if (l > e && (l = e - 1), l >= 0) {
    const i = t[l];
    o = i.offset + i.size;
  }
  const r = (e - l - 1) * n;
  return o + r;
}, ww = {
  column: mc,
  row: vc
}, Fr = (e, t, n, l, o, a, r) => {
  const [i, u] = [
    a === "row" ? e.height : e.width,
    ww[a]
  ], c = mn(e, t, o, a), p = u(e, o), d = Do(0, fc(p - i, c.offset)), f = Do(0, c.offset - i + r + c.size);
  switch (n === es && (l >= f - i && l <= d + i ? n = qt : n = rn), n) {
    case Hl:
      return d;
    case zl:
      return f;
    case rn:
      return Math.round(f + (d - f) / 2);
    case qt:
    default:
      return l >= f && l <= d ? l : f > d || l < f ? f : d;
  }
}, kw = dc({
  name: "ElDynamicSizeGrid",
  getColumnPosition: (e, t, n) => {
    const l = mn(e, t, n, "column");
    return [l.size, l.offset];
  },
  getRowPosition: (e, t, n) => {
    const l = mn(e, t, n, "row");
    return [l.size, l.offset];
  },
  getColumnOffset: (e, t, n, l, o, a) => Fr(e, t, n, l, o, "column", a),
  getRowOffset: (e, t, n, l, o, a) => Fr(e, t, n, l, o, "row", a),
  getColumnStartIndexForOffset: (e, t, n) => xr(e, n, t, "column"),
  getColumnStopIndexForStartIndex: (e, t, n, l) => {
    const o = mn(e, t, l, "column"), a = n + e.width;
    let r = o.offset + o.size, i = t;
    for (; i < e.totalColumn - 1 && r < a; )
      i++, r += mn(e, t, l, "column").size;
    return i;
  },
  getEstimatedTotalHeight: vc,
  getEstimatedTotalWidth: mc,
  getRowStartIndexForOffset: (e, t, n) => xr(e, n, t, "row"),
  getRowStopIndexForStartIndex: (e, t, n, l) => {
    const { totalRow: o, height: a } = e, r = mn(e, t, l, "row"), i = n + a;
    let u = r.size + r.offset, c = t;
    for (; c < o - 1 && u < i; )
      c++, u += mn(e, c, l, "row").size;
    return c;
  },
  injectToInstance: (e, t) => {
    const n = ({ columnIndex: a, rowIndex: r }, i) => {
      var u, c;
      i = qn(i) ? !0 : i, Pe(a) && (t.value.lastVisitedColumnIndex = Math.min(t.value.lastVisitedColumnIndex, a - 1)), Pe(r) && (t.value.lastVisitedRowIndex = Math.min(t.value.lastVisitedRowIndex, r - 1)), (u = e.exposed) == null || u.getItemStyleCache.value(-1, null, null), i && ((c = e.proxy) == null || c.$forceUpdate());
    }, l = (a, r) => {
      n({
        columnIndex: a
      }, r);
    }, o = (a, r) => {
      n({
        rowIndex: a
      }, r);
    };
    Object.assign(e.proxy, {
      resetAfterColumnIndex: l,
      resetAfterRowIndex: o,
      resetAfter: n
    });
  },
  initCache: ({
    estimatedColumnWidth: e = _s,
    estimatedRowHeight: t = _s
  }) => ({
    column: {},
    estimatedColumnWidth: e,
    estimatedRowHeight: t,
    lastVisitedColumnIndex: -1,
    lastVisitedRowIndex: -1,
    row: {}
  }),
  clearCache: !1,
  validateProps: ({ columnWidth: e, rowHeight: t }) => {
    process.env.NODE_ENV !== "production" && (mt(e) || wt(Dr, `
          "columnWidth" must be passed as function,
            instead ${typeof e} was given.
        `), mt(t) || wt(Dr, `
          "rowHeight" must be passed as function,
            instead ${typeof t} was given.
        `));
  }
}), Sw = F({
  props: {
    item: {
      type: Object,
      required: !0
    },
    style: Object,
    height: Number
  },
  setup() {
    return {
      ns: se("select")
    };
  }
});
function Ew(e, t, n, l, o, a) {
  return e.item.isTitle ? (E(), _("div", {
    key: 0,
    class: $(e.ns.be("group", "title")),
    style: ye([e.style, { lineHeight: `${e.height}px` }])
  }, ce(e.item.label), 7)) : (E(), _("div", {
    key: 1,
    class: $(e.ns.be("group", "split")),
    style: ye(e.style)
  }, [
    H("span", {
      class: $(e.ns.be("group", "split-dash")),
      style: ye({ top: `${e.height / 2}px` })
    }, null, 6)
  ], 6));
}
var $w = /* @__PURE__ */ de(Sw, [["render", Ew], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/group-item.vue"]]);
function Tw(e, { emit: t }) {
  return {
    hoverItem: () => {
      e.disabled || t("hover", e.index);
    },
    selectOptionClick: () => {
      e.disabled || t("select", e.item, e.index);
    }
  };
}
const Nw = {
  allowCreate: Boolean,
  autocomplete: {
    type: String,
    default: "none"
  },
  automaticDropdown: Boolean,
  clearable: Boolean,
  clearIcon: {
    type: [String, Object],
    default: Ko
  },
  effect: {
    type: String,
    default: "light"
  },
  collapseTags: Boolean,
  collapseTagsTooltip: {
    type: Boolean,
    default: !1
  },
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  defaultFirstOption: Boolean,
  disabled: Boolean,
  estimatedOptionHeight: {
    type: Number,
    default: void 0
  },
  filterable: Boolean,
  filterMethod: Function,
  height: {
    type: Number,
    default: 170
  },
  itemHeight: {
    type: Number,
    default: 34
  },
  id: String,
  loading: Boolean,
  loadingText: String,
  label: String,
  modelValue: [Array, String, Number, Boolean, Object],
  multiple: Boolean,
  multipleLimit: {
    type: Number,
    default: 0
  },
  name: String,
  noDataText: String,
  noMatchText: String,
  remoteMethod: Function,
  reserveKeyword: {
    type: Boolean,
    default: !0
  },
  options: {
    type: Array,
    required: !0
  },
  placeholder: {
    type: String
  },
  teleported: Pt.teleported,
  persistent: {
    type: Boolean,
    default: !0
  },
  popperClass: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: Object,
    default: () => ({})
  },
  remote: Boolean,
  size: {
    type: String,
    validator: ia
  },
  valueKey: {
    type: String,
    default: "value"
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: !1
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  placement: {
    type: j(String),
    values: ua,
    default: "bottom-start"
  }
}, Iw = {
  data: Array,
  disabled: Boolean,
  hovering: Boolean,
  item: Object,
  index: Number,
  style: Object,
  selected: Boolean,
  created: Boolean
}, Mw = F({
  props: Iw,
  emits: ["select", "hover"],
  setup(e, { emit: t }) {
    const n = se("select"), { hoverItem: l, selectOptionClick: o } = Tw(e, { emit: t });
    return {
      ns: n,
      hoverItem: l,
      selectOptionClick: o
    };
  }
}), Rw = ["aria-selected"];
function Ow(e, t, n, l, o, a) {
  return E(), _("li", {
    "aria-selected": e.selected,
    style: ye(e.style),
    class: $([
      e.ns.be("dropdown", "option-item"),
      e.ns.is("selected", e.selected),
      e.ns.is("disabled", e.disabled),
      e.ns.is("created", e.created),
      { hover: e.hovering }
    ]),
    onMouseenter: t[0] || (t[0] = (...r) => e.hoverItem && e.hoverItem(...r)),
    onClick: t[1] || (t[1] = Ae((...r) => e.selectOptionClick && e.selectOptionClick(...r), ["stop"]))
  }, [
    ne(e.$slots, "default", {
      item: e.item,
      index: e.index,
      disabled: e.disabled
    }, () => [
      H("span", null, ce(e.item.label), 1)
    ])
  ], 46, Rw);
}
var Pw = /* @__PURE__ */ de(Mw, [["render", Ow], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/option-item.vue"]]);
const gc = Symbol("ElSelectV2Injection");
var Aw = F({
  name: "ElSelectDropdown",
  props: {
    data: {
      type: Array,
      required: !0
    },
    hoveringIndex: Number,
    width: Number
  },
  setup(e, {
    slots: t,
    expose: n
  }) {
    const l = Oe(gc), o = se("select"), a = N([]), r = N(), i = k(() => e.data.length);
    ue(() => i.value, () => {
      var I, R;
      (R = (I = l.popper.value).updatePopper) == null || R.call(I);
    });
    const u = k(() => qn(l.props.estimatedOptionHeight)), c = k(() => u.value ? {
      itemSize: l.props.itemHeight
    } : {
      estimatedSize: l.props.estimatedOptionHeight,
      itemSize: (I) => a.value[I]
    }), p = (I = [], R) => {
      const {
        props: {
          valueKey: B
        }
      } = l;
      return Ct(R) ? I && I.some((D) => Lt(D, B) === Lt(R, B)) : I.includes(R);
    }, d = (I, R) => {
      if (Ct(R)) {
        const {
          valueKey: B
        } = l.props;
        return Lt(I, B) === Lt(R, B);
      } else
        return I === R;
    }, f = (I, R) => {
      const {
        valueKey: B
      } = l.props;
      return l.props.multiple ? p(I, Lt(R, B)) : d(I, Lt(R, B));
    }, h = (I, R) => {
      const {
        disabled: B,
        multiple: D,
        multipleLimit: A
      } = l.props;
      return B || !R && (D ? A > 0 && I.length >= A : !1);
    }, v = (I) => e.hoveringIndex === I;
    n({
      listRef: r,
      isSized: u,
      isItemDisabled: h,
      isItemHovering: v,
      isItemSelected: f,
      scrollToItem: (I) => {
        const R = r.value;
        R && R.scrollToItem(I);
      },
      resetScrollTop: () => {
        const I = r.value;
        I && I.resetScrollTop();
      }
    });
    const w = (I) => {
      const {
        index: R,
        data: B,
        style: D
      } = I, A = s(u), {
        itemSize: z,
        estimatedSize: Z
      } = s(c), {
        modelValue: J
      } = l.props, {
        onSelect: V,
        onHover: M
      } = l, P = B[R];
      if (P.type === "Group")
        return x($w, {
          item: P,
          style: D,
          height: A ? z : Z
        }, null);
      const L = f(J, P), U = h(J, L), oe = v(R);
      return x(Pw, Be(I, {
        selected: L,
        disabled: P.disabled || U,
        created: !!P.created,
        hovering: oe,
        item: P,
        onSelect: V,
        onHover: M
      }), {
        default: (le) => {
          var ee;
          return ((ee = t.default) == null ? void 0 : ee.call(t, le)) || x("span", null, [P.label]);
        }
      });
    }, {
      onKeyboardNavigate: C,
      onKeyboardSelect: y
    } = l, b = () => {
      C("forward");
    }, S = () => {
      C("backward");
    }, T = () => {
      l.expanded = !1;
    }, O = (I) => {
      const {
        code: R
      } = I, {
        tab: B,
        esc: D,
        down: A,
        up: z,
        enter: Z
      } = Ce;
      switch (R !== B && (I.preventDefault(), I.stopPropagation()), R) {
        case B:
        case D: {
          T();
          break;
        }
        case A: {
          b();
          break;
        }
        case z: {
          S();
          break;
        }
        case Z: {
          y();
          break;
        }
      }
    };
    return () => {
      var I;
      const {
        data: R,
        width: B
      } = e, {
        height: D,
        multiple: A,
        scrollbarAlwaysOn: z
      } = l.props;
      if (R.length === 0)
        return x("div", {
          class: o.b("dropdown"),
          style: {
            width: `${B}px`
          }
        }, [(I = t.empty) == null ? void 0 : I.call(t)]);
      const Z = s(u) ? uc : mw;
      return x("div", {
        class: [o.b("dropdown"), o.is("multiple", A)]
      }, [x(Z, Be({
        ref: r
      }, s(c), {
        className: o.be("dropdown", "list"),
        scrollbarAlwaysOn: z,
        data: R,
        height: D,
        width: B,
        total: R.length,
        onKeydown: O
      }), {
        default: (J) => x(w, J, null)
      })]);
    };
  }
});
function _w(e, t) {
  const n = N(0), l = N(null), o = k(() => e.allowCreate && e.filterable);
  function a(p) {
    const d = (f) => f.value === p;
    return e.options && e.options.some(d) || t.createdOptions.some(d);
  }
  function r(p) {
    !o.value || (e.multiple && p.created ? n.value++ : l.value = p);
  }
  function i(p) {
    if (o.value)
      if (p && p.length > 0 && !a(p)) {
        const d = {
          value: p,
          label: p,
          created: !0,
          disabled: !1
        };
        t.createdOptions.length >= n.value ? t.createdOptions[n.value] = d : t.createdOptions.push(d);
      } else if (e.multiple)
        t.createdOptions.length = n.value;
      else {
        const d = l.value;
        t.createdOptions.length = 0, d && d.created && t.createdOptions.push(d);
      }
  }
  function u(p) {
    if (!o.value || !p || !p.created || p.created && e.reserveKeyword && t.inputValue === p.label)
      return;
    const d = t.createdOptions.findIndex((f) => f.value === p.value);
    ~d && (t.createdOptions.splice(d, 1), n.value--);
  }
  function c() {
    o.value && (t.createdOptions.length = 0, n.value = 0);
  }
  return {
    createNewOption: i,
    removeNewOption: u,
    selectNewOption: r,
    clearAllNewOption: c
  };
}
const Lw = (e) => {
  const t = [];
  return e.forEach((n) => {
    Je(n.options) ? (t.push({
      label: n.label,
      isTitle: !0,
      type: "Group"
    }), n.options.forEach((l) => {
      t.push(l);
    }), t.push({
      type: "Group"
    })) : t.push(n);
  }), t;
};
function Vw(e) {
  const t = N(!1);
  return {
    handleCompositionStart: () => {
      t.value = !0;
    },
    handleCompositionUpdate: (a) => {
      const r = a.target.value, i = r[r.length - 1] || "";
      t.value = !yi(i);
    },
    handleCompositionEnd: (a) => {
      t.value && (t.value = !1, mt(e) && e(a));
    }
  };
}
const Hr = "", zr = 11, Bw = {
  larget: 51,
  default: 42,
  small: 33
}, Dw = (e, t) => {
  const { t: n } = ot(), l = se("select-v2"), o = se("input"), { form: a, formItem: r } = kl(), i = ct({
    inputValue: Hr,
    displayInputValue: Hr,
    calculatedWidth: 0,
    cachedPlaceholder: "",
    cachedOptions: [],
    createdOptions: [],
    createdLabel: "",
    createdSelected: !1,
    currentPlaceholder: "",
    hoveringIndex: -1,
    comboBoxHovering: !1,
    isOnComposition: !1,
    isSilentBlur: !1,
    isComposing: !1,
    inputLength: 20,
    selectWidth: 200,
    initialInputHeight: 0,
    previousQuery: null,
    previousValue: void 0,
    query: "",
    selectedLabel: "",
    softFocus: !1,
    tagInMultiLine: !1
  }), u = N(-1), c = N(-1), p = N(null), d = N(null), f = N(null), h = N(null), v = N(null), m = N(null), g = N(null), w = N(!1), C = k(() => e.disabled || (a == null ? void 0 : a.disabled)), y = k(() => {
    const X = A.value.length * 34;
    return X > e.height ? e.height : X;
  }), b = k(() => !un(e.modelValue)), S = k(() => {
    const X = e.multiple ? Array.isArray(e.modelValue) && e.modelValue.length > 0 : b.value;
    return e.clearable && !C.value && i.comboBoxHovering && X;
  }), T = k(() => e.remote && e.filterable ? "" : Ti), O = k(() => T.value && l.is("reverse", w.value)), I = k(() => (r == null ? void 0 : r.validateState) || ""), R = k(() => zd[I.value]), B = k(() => e.remote ? 300 : 0), D = k(() => {
    const X = A.value;
    return e.loading ? e.loadingText || n("el.select.loading") : e.remote && i.inputValue === "" && X.length === 0 ? !1 : e.filterable && i.inputValue && X.length > 0 ? e.noMatchText || n("el.select.noMatch") : X.length === 0 ? e.noDataText || n("el.select.noData") : null;
  }), A = k(() => {
    const X = (me) => {
      const He = i.inputValue, lt = new RegExp(Kd(He), "i");
      return He ? lt.test(me.label || "") : !0;
    };
    return e.loading ? [] : Lw(e.options.concat(i.createdOptions).map((me) => {
      if (Je(me.options)) {
        const He = me.options.filter(X);
        if (He.length > 0)
          return {
            ...me,
            options: He
          };
      } else if (e.remote || X(me))
        return me;
      return null;
    }).filter((me) => me !== null));
  }), z = k(() => A.value.every((X) => X.disabled)), Z = dn(), J = k(() => Z.value === "small" ? "small" : "default"), V = k(() => {
    const X = m.value, me = J.value || "default", He = X ? Number.parseInt(getComputedStyle(X).paddingLeft) : 0, lt = X ? Number.parseInt(getComputedStyle(X).paddingRight) : 0;
    return i.selectWidth - lt - He - Bw[me];
  }), M = () => {
    var X;
    c.value = ((X = v.value) == null ? void 0 : X.offsetWidth) || 200;
  }, P = k(() => ({
    width: `${i.calculatedWidth === 0 ? zr : Math.ceil(i.calculatedWidth) + zr}px`
  })), L = k(() => Je(e.modelValue) ? e.modelValue.length === 0 && !i.displayInputValue : e.filterable ? i.displayInputValue.length === 0 : !0), U = k(() => {
    const X = e.placeholder || n("el.select.placeholder");
    return e.multiple || un(e.modelValue) ? X : i.selectedLabel;
  }), oe = k(() => {
    var X, me;
    return (me = (X = h.value) == null ? void 0 : X.popperRef) == null ? void 0 : me.contentRef;
  }), le = k(() => {
    if (e.multiple) {
      const X = e.modelValue.length;
      if (e.modelValue.length > 0)
        return A.value.findIndex((me) => me.value === e.modelValue[X - 1]);
    } else if (e.modelValue)
      return A.value.findIndex((X) => X.value === e.modelValue);
    return -1;
  }), ee = k({
    get() {
      return w.value && D.value !== !1;
    },
    set(X) {
      w.value = X;
    }
  }), pe = k(() => i.cachedOptions.slice(0, e.maxCollapseTags)), ge = k(() => i.cachedOptions.slice(e.maxCollapseTags)), {
    createNewOption: te,
    removeNewOption: ve,
    selectNewOption: G,
    clearAllNewOption: Q
  } = _w(e, i), {
    handleCompositionStart: ie,
    handleCompositionUpdate: Ee,
    handleCompositionEnd: De
  } = Vw((X) => _n(X)), Ve = () => {
    var X, me, He;
    (me = (X = d.value) == null ? void 0 : X.focus) == null || me.call(X), (He = h.value) == null || He.updatePopper();
  }, Fe = () => {
    if (!e.automaticDropdown && !C.value)
      return i.isComposing && (i.softFocus = !0), Ne(() => {
        var X, me;
        w.value = !w.value, (me = (X = d.value) == null ? void 0 : X.focus) == null || me.call(X);
      });
  }, ze = () => (e.filterable && i.inputValue !== i.selectedLabel && (i.query = i.selectedLabel), be(i.inputValue), Ne(() => {
    te(i.inputValue);
  })), it = Gt(ze, B.value), be = (X) => {
    i.previousQuery !== X && (i.previousQuery = X, e.filterable && mt(e.filterMethod) ? e.filterMethod(X) : e.filterable && e.remote && mt(e.remoteMethod) && e.remoteMethod(X));
  }, Te = (X) => {
    bn(e.modelValue, X) || t(vt, X);
  }, we = (X) => {
    t(et, X), Te(X), i.previousValue = X == null ? void 0 : X.toString();
  }, _e = (X = [], me) => {
    if (!Ct(me))
      return X.indexOf(me);
    const He = e.valueKey;
    let lt = -1;
    return X.some((on, sn) => Lt(on, He) === Lt(me, He) ? (lt = sn, !0) : !1), lt;
  }, Ie = (X) => Ct(X) ? Lt(X, e.valueKey) : X, Le = (X) => Ct(X) ? X.label : X, Ke = () => Ne(() => {
    var X, me;
    if (!d.value)
      return;
    const He = m.value;
    v.value.height = He.offsetHeight, w.value && D.value !== !1 && ((me = (X = h.value) == null ? void 0 : X.updatePopper) == null || me.call(X));
  }), Ye = () => {
    var X, me;
    if (nt(), M(), (me = (X = h.value) == null ? void 0 : X.updatePopper) == null || me.call(X), e.multiple)
      return Ke();
  }, nt = () => {
    const X = m.value;
    X && (i.selectWidth = X.getBoundingClientRect().width);
  }, gt = (X, me, He = !0) => {
    var lt, on;
    if (e.multiple) {
      let sn = e.modelValue.slice();
      const to = _e(sn, Ie(X));
      to > -1 ? (sn = [
        ...sn.slice(0, to),
        ...sn.slice(to + 1)
      ], i.cachedOptions.splice(to, 1), ve(X)) : (e.multipleLimit <= 0 || sn.length < e.multipleLimit) && (sn = [...sn, Ie(X)], i.cachedOptions.push(X), G(X), Qe(me)), we(sn), X.created && (i.query = "", be(""), i.inputLength = 20), e.filterable && !e.reserveKeyword && ((on = (lt = d.value).focus) == null || on.call(lt), re("")), e.filterable && (i.calculatedWidth = g.value.getBoundingClientRect().width), Ke(), xt();
    } else
      u.value = me, i.selectedLabel = X.label, we(Ie(X)), w.value = !1, i.isComposing = !1, i.isSilentBlur = He, G(X), X.created || Q(), Qe(me);
  }, kt = (X, me) => {
    const { valueKey: He } = e, lt = e.modelValue.indexOf(Lt(me, He));
    if (lt > -1 && !C.value) {
      const on = [
        ...e.modelValue.slice(0, lt),
        ...e.modelValue.slice(lt + 1)
      ];
      return i.cachedOptions.splice(lt, 1), we(on), t("remove-tag", Lt(me, He)), i.softFocus = !0, ve(me), Ne(Ve);
    }
    X.stopPropagation();
  }, St = (X) => {
    const me = i.isComposing;
    i.isComposing = !0, i.softFocus ? i.softFocus = !1 : me || t("focus", X);
  }, yt = (X) => (i.softFocus = !1, Ne(() => {
    var me, He;
    (He = (me = d.value) == null ? void 0 : me.blur) == null || He.call(me), g.value && (i.calculatedWidth = g.value.getBoundingClientRect().width), i.isSilentBlur ? i.isSilentBlur = !1 : i.isComposing && t("blur", X), i.isComposing = !1;
  })), ke = () => {
    i.displayInputValue.length > 0 ? re("") : w.value = !1;
  }, Y = (X) => {
    if (i.displayInputValue.length === 0) {
      X.preventDefault();
      const me = e.modelValue.slice();
      me.pop(), ve(i.cachedOptions.pop()), we(me);
    }
  }, ae = () => {
    let X;
    return Je(e.modelValue) ? X = [] : X = void 0, i.softFocus = !0, e.multiple ? i.cachedOptions = [] : i.selectedLabel = "", w.value = !1, we(X), t("clear"), Q(), Ne(Ve);
  }, re = (X) => {
    i.displayInputValue = X, i.inputValue = X;
  }, Me = (X, me = void 0) => {
    const He = A.value;
    if (!["forward", "backward"].includes(X) || C.value || He.length <= 0 || z.value)
      return;
    if (!w.value)
      return Fe();
    me === void 0 && (me = i.hoveringIndex);
    let lt = -1;
    X === "forward" ? (lt = me + 1, lt >= He.length && (lt = 0)) : X === "backward" && (lt = me - 1, (lt < 0 || lt >= He.length) && (lt = He.length - 1));
    const on = He[lt];
    if (on.disabled || on.type === "Group")
      return Me(X, lt);
    Qe(lt), pn(lt);
  }, Ze = () => {
    if (w.value)
      ~i.hoveringIndex && A.value[i.hoveringIndex] && gt(A.value[i.hoveringIndex], i.hoveringIndex, !1);
    else
      return Fe();
  }, Qe = (X) => {
    i.hoveringIndex = X;
  }, dt = () => {
    i.hoveringIndex = -1;
  }, xt = () => {
    var X;
    const me = d.value;
    me && ((X = me.focus) == null || X.call(me));
  }, _n = (X) => {
    const me = X.target.value;
    if (re(me), i.displayInputValue.length > 0 && !w.value && (w.value = !0), i.calculatedWidth = g.value.getBoundingClientRect().width, e.multiple && Ke(), e.remote)
      it();
    else
      return ze();
  }, Ft = () => (w.value = !1, yt()), $l = () => (i.inputValue = i.displayInputValue, Ne(() => {
    ~le.value && (Qe(le.value), pn(i.hoveringIndex));
  })), pn = (X) => {
    f.value.scrollToItem(X);
  }, hn = () => {
    if (dt(), e.multiple)
      if (e.modelValue.length > 0) {
        let X = !1;
        i.cachedOptions.length = 0, i.previousValue = e.modelValue.toString(), e.modelValue.forEach((me) => {
          const He = A.value.findIndex((lt) => Ie(lt) === me);
          ~He && (i.cachedOptions.push(A.value[He]), X || Qe(He), X = !0);
        });
      } else
        i.cachedOptions = [], i.previousValue = void 0;
    else if (b.value) {
      i.previousValue = e.modelValue;
      const X = A.value, me = X.findIndex((He) => Ie(He) === Ie(e.modelValue));
      ~me ? (i.selectedLabel = X[me].label, Qe(me)) : i.selectedLabel = `${e.modelValue}`;
    } else
      i.selectedLabel = "", i.previousValue = void 0;
    Q(), M();
  };
  return ue(w, (X) => {
    var me, He;
    t("visible-change", X), X ? (He = (me = h.value).update) == null || He.call(me) : (i.displayInputValue = "", i.previousQuery = null, te(""));
  }), ue(() => e.modelValue, (X, me) => {
    var He;
    (!X || X.toString() !== i.previousValue) && hn(), !bn(X, me) && e.validateEvent && ((He = r == null ? void 0 : r.validate) == null || He.call(r, "change").catch((lt) => pt(lt)));
  }, {
    deep: !0
  }), ue(() => e.options, () => {
    const X = d.value;
    (!X || X && document.activeElement !== X) && hn();
  }, {
    deep: !0
  }), ue(A, () => Ne(f.value.resetScrollTop)), ue(() => ee.value, (X) => {
    X || dt();
  }), We(() => {
    hn();
  }), Mn(v, Ye), {
    collapseTagSize: J,
    currentPlaceholder: U,
    expanded: w,
    emptyText: D,
    popupHeight: y,
    debounce: B,
    filteredOptions: A,
    iconComponent: T,
    iconReverse: O,
    inputWrapperStyle: P,
    popperSize: c,
    dropdownMenuVisible: ee,
    hasModelValue: b,
    shouldShowPlaceholder: L,
    selectDisabled: C,
    selectSize: Z,
    showClearBtn: S,
    states: i,
    tagMaxWidth: V,
    nsSelectV2: l,
    nsInput: o,
    calculatorRef: g,
    controlRef: p,
    inputRef: d,
    menuRef: f,
    popper: h,
    selectRef: v,
    selectionRef: m,
    popperRef: oe,
    validateState: I,
    validateIcon: R,
    showTagList: pe,
    collapseTagList: ge,
    debouncedOnInputChange: it,
    deleteTag: kt,
    getLabel: Le,
    getValueKey: Ie,
    handleBlur: yt,
    handleClear: ae,
    handleClickOutside: Ft,
    handleDel: Y,
    handleEsc: ke,
    handleFocus: St,
    handleMenuEnter: $l,
    handleResize: Ye,
    toggleMenu: Fe,
    scrollTo: pn,
    onInput: _n,
    onKeyboardNavigate: Me,
    onKeyboardSelect: Ze,
    onSelect: gt,
    onHover: Qe,
    onUpdateInputValue: re,
    handleCompositionStart: ie,
    handleCompositionEnd: De,
    handleCompositionUpdate: Ee
  };
}, xw = F({
  name: "ElSelectV2",
  components: {
    ElSelectMenu: Aw,
    ElTag: Mo,
    ElTooltip: Wt,
    ElIcon: Se
  },
  directives: { ClickOutside: Wo, ModelText: Ri },
  props: Nw,
  emits: [
    et,
    vt,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur"
  ],
  setup(e, { emit: t }) {
    const n = k(() => {
      const { modelValue: o, multiple: a } = e, r = a ? [] : void 0;
      return Je(o) ? a ? o : r : a ? r : o;
    }), l = Dw(ct({
      ...Ut(e),
      modelValue: n
    }), t);
    return tt(gc, {
      props: ct({
        ...Ut(e),
        height: l.popupHeight,
        modelValue: n
      }),
      popper: l.popper,
      onSelect: l.onSelect,
      onHover: l.onHover,
      onKeyboardNavigate: l.onKeyboardNavigate,
      onKeyboardSelect: l.onKeyboardSelect
    }), {
      ...l,
      modelValue: n
    };
  }
}), Fw = { key: 0 }, Hw = ["id", "autocomplete", "aria-expanded", "aria-labelledby", "disabled", "readonly", "name", "unselectable"], zw = ["textContent"], Kw = ["id", "aria-labelledby", "aria-expanded", "autocomplete", "disabled", "name", "readonly", "unselectable"], Ww = ["textContent"];
function jw(e, t, n, l, o, a) {
  const r = $e("el-tag"), i = $e("el-tooltip"), u = $e("el-icon"), c = $e("el-select-menu"), p = Oo("model-text"), d = Oo("click-outside");
  return qe((E(), _("div", {
    ref: "selectRef",
    class: $([e.nsSelectV2.b(), e.nsSelectV2.m(e.selectSize)]),
    onClick: t[24] || (t[24] = Ae((...f) => e.toggleMenu && e.toggleMenu(...f), ["stop"])),
    onMouseenter: t[25] || (t[25] = (f) => e.states.comboBoxHovering = !0),
    onMouseleave: t[26] || (t[26] = (f) => e.states.comboBoxHovering = !1)
  }, [
    x(i, {
      ref: "popper",
      visible: e.dropdownMenuVisible,
      teleported: e.teleported,
      "popper-class": [e.nsSelectV2.e("popper"), e.popperClass],
      "gpu-acceleration": !1,
      "stop-popper-mouse-event": !1,
      "popper-options": e.popperOptions,
      "fallback-placements": ["bottom-start", "top-start", "right", "left"],
      effect: e.effect,
      placement: e.placement,
      pure: "",
      transition: `${e.nsSelectV2.namespace.value}-zoom-in-top`,
      trigger: "click",
      persistent: e.persistent,
      onBeforeShow: e.handleMenuEnter,
      onHide: t[23] || (t[23] = (f) => e.states.inputValue = e.states.displayInputValue)
    }, {
      default: K(() => [
        H("div", {
          ref: "selectionRef",
          class: $([
            e.nsSelectV2.e("wrapper"),
            e.nsSelectV2.is("focused", e.states.isComposing || e.expanded),
            e.nsSelectV2.is("hovering", e.states.comboBoxHovering),
            e.nsSelectV2.is("filterable", e.filterable),
            e.nsSelectV2.is("disabled", e.selectDisabled)
          ])
        }, [
          e.$slots.prefix ? (E(), _("div", Fw, [
            ne(e.$slots, "prefix")
          ])) : W("v-if", !0),
          e.multiple ? (E(), _("div", {
            key: 1,
            class: $(e.nsSelectV2.e("selection"))
          }, [
            e.collapseTags && e.modelValue.length > 0 ? (E(), _(Re, { key: 0 }, [
              (E(!0), _(Re, null, Xe(e.showTagList, (f) => (E(), _("div", {
                key: e.getValueKey(f),
                class: $(e.nsSelectV2.e("selected-item"))
              }, [
                x(r, {
                  closable: !e.selectDisabled && !(f != null && f.disable),
                  size: e.collapseTagSize,
                  type: "info",
                  "disable-transitions": "",
                  onClose: (h) => e.deleteTag(h, f)
                }, {
                  default: K(() => [
                    H("span", {
                      class: $(e.nsSelectV2.e("tags-text")),
                      style: ye({
                        maxWidth: `${e.tagMaxWidth}px`
                      })
                    }, ce(f == null ? void 0 : f.label), 7)
                  ]),
                  _: 2
                }, 1032, ["closable", "size", "onClose"])
              ], 2))), 128)),
              H("div", {
                class: $(e.nsSelectV2.e("selected-item"))
              }, [
                e.modelValue.length > e.maxCollapseTags ? (E(), q(r, {
                  key: 0,
                  closable: !1,
                  size: e.collapseTagSize,
                  type: "info",
                  "disable-transitions": ""
                }, {
                  default: K(() => [
                    e.collapseTagsTooltip ? (E(), q(i, {
                      key: 0,
                      disabled: e.dropdownMenuVisible,
                      "fallback-placements": ["bottom", "top", "right", "left"],
                      effect: e.effect,
                      placement: "bottom",
                      teleported: !1
                    }, {
                      default: K(() => [
                        H("span", {
                          class: $(e.nsSelectV2.e("tags-text")),
                          style: ye({
                            maxWidth: `${e.tagMaxWidth}px`
                          })
                        }, "+ " + ce(e.modelValue.length - e.maxCollapseTags), 7)
                      ]),
                      content: K(() => [
                        H("div", {
                          class: $(e.nsSelectV2.e("selection"))
                        }, [
                          (E(!0), _(Re, null, Xe(e.collapseTagList, (f) => (E(), _("div", {
                            key: e.getValueKey(f),
                            class: $(e.nsSelectV2.e("selected-item"))
                          }, [
                            x(r, {
                              closable: !e.selectDisabled && !f.disabled,
                              size: e.collapseTagSize,
                              class: "in-tooltip",
                              type: "info",
                              "disable-transitions": "",
                              onClose: (h) => e.deleteTag(h, f)
                            }, {
                              default: K(() => [
                                H("span", {
                                  class: $(e.nsSelectV2.e("tags-text")),
                                  style: ye({
                                    maxWidth: `${e.tagMaxWidth}px`
                                  })
                                }, ce(e.getLabel(f)), 7)
                              ]),
                              _: 2
                            }, 1032, ["closable", "size", "onClose"])
                          ], 2))), 128))
                        ], 2)
                      ]),
                      _: 1
                    }, 8, ["disabled", "effect"])) : (E(), _("span", {
                      key: 1,
                      class: $(e.nsSelectV2.e("tags-text")),
                      style: ye({
                        maxWidth: `${e.tagMaxWidth}px`
                      })
                    }, "+ " + ce(e.modelValue.length - e.maxCollapseTags), 7))
                  ]),
                  _: 1
                }, 8, ["size"])) : W("v-if", !0)
              ], 2)
            ], 64)) : (E(!0), _(Re, { key: 1 }, Xe(e.states.cachedOptions, (f) => (E(), _("div", {
              key: e.getValueKey(f),
              class: $(e.nsSelectV2.e("selected-item"))
            }, [
              x(r, {
                closable: !e.selectDisabled && !f.disabled,
                size: e.collapseTagSize,
                type: "info",
                "disable-transitions": "",
                onClose: (h) => e.deleteTag(h, f)
              }, {
                default: K(() => [
                  H("span", {
                    class: $(e.nsSelectV2.e("tags-text")),
                    style: ye({
                      maxWidth: `${e.tagMaxWidth}px`
                    })
                  }, ce(e.getLabel(f)), 7)
                ]),
                _: 2
              }, 1032, ["closable", "size", "onClose"])
            ], 2))), 128)),
            H("div", {
              class: $([
                e.nsSelectV2.e("selected-item"),
                e.nsSelectV2.e("input-wrapper")
              ]),
              style: ye(e.inputWrapperStyle)
            }, [
              qe(H("input", {
                id: e.id,
                ref: "inputRef",
                autocomplete: e.autocomplete,
                "aria-autocomplete": "list",
                "aria-haspopup": "listbox",
                autocapitalize: "off",
                "aria-expanded": e.expanded,
                "aria-labelledby": e.label,
                class: $([
                  e.nsSelectV2.is(e.selectSize),
                  e.nsSelectV2.e("combobox-input")
                ]),
                disabled: e.disabled,
                role: "combobox",
                readonly: !e.filterable,
                spellcheck: "false",
                type: "text",
                name: e.name,
                unselectable: e.expanded ? "on" : void 0,
                "onUpdate:modelValue": t[0] || (t[0] = (...f) => e.onUpdateInputValue && e.onUpdateInputValue(...f)),
                onFocus: t[1] || (t[1] = (...f) => e.handleFocus && e.handleFocus(...f)),
                onBlur: t[2] || (t[2] = (...f) => e.handleBlur && e.handleBlur(...f)),
                onInput: t[3] || (t[3] = (...f) => e.onInput && e.onInput(...f)),
                onCompositionstart: t[4] || (t[4] = (...f) => e.handleCompositionStart && e.handleCompositionStart(...f)),
                onCompositionupdate: t[5] || (t[5] = (...f) => e.handleCompositionUpdate && e.handleCompositionUpdate(...f)),
                onCompositionend: t[6] || (t[6] = (...f) => e.handleCompositionEnd && e.handleCompositionEnd(...f)),
                onKeydown: [
                  t[7] || (t[7] = ut(Ae((f) => e.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                  t[8] || (t[8] = ut(Ae((f) => e.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                  t[9] || (t[9] = ut(Ae((...f) => e.onKeyboardSelect && e.onKeyboardSelect(...f), ["stop", "prevent"]), ["enter"])),
                  t[10] || (t[10] = ut(Ae((...f) => e.handleEsc && e.handleEsc(...f), ["stop", "prevent"]), ["esc"])),
                  t[11] || (t[11] = ut(Ae((...f) => e.handleDel && e.handleDel(...f), ["stop"]), ["delete"]))
                ]
              }, null, 42, Hw), [
                [p, e.states.displayInputValue]
              ]),
              e.filterable ? (E(), _("span", {
                key: 0,
                ref: "calculatorRef",
                "aria-hidden": "true",
                class: $(e.nsSelectV2.e("input-calculator")),
                textContent: ce(e.states.displayInputValue)
              }, null, 10, zw)) : W("v-if", !0)
            ], 6)
          ], 2)) : (E(), _(Re, { key: 2 }, [
            H("div", {
              class: $([
                e.nsSelectV2.e("selected-item"),
                e.nsSelectV2.e("input-wrapper")
              ])
            }, [
              qe(H("input", {
                id: e.id,
                ref: "inputRef",
                "aria-autocomplete": "list",
                "aria-haspopup": "listbox",
                "aria-labelledby": e.label,
                "aria-expanded": e.expanded,
                autocapitalize: "off",
                autocomplete: e.autocomplete,
                class: $(e.nsSelectV2.e("combobox-input")),
                disabled: e.disabled,
                name: e.name,
                role: "combobox",
                readonly: !e.filterable,
                spellcheck: "false",
                type: "text",
                unselectable: e.expanded ? "on" : void 0,
                onCompositionstart: t[12] || (t[12] = (...f) => e.handleCompositionStart && e.handleCompositionStart(...f)),
                onCompositionupdate: t[13] || (t[13] = (...f) => e.handleCompositionUpdate && e.handleCompositionUpdate(...f)),
                onCompositionend: t[14] || (t[14] = (...f) => e.handleCompositionEnd && e.handleCompositionEnd(...f)),
                onFocus: t[15] || (t[15] = (...f) => e.handleFocus && e.handleFocus(...f)),
                onBlur: t[16] || (t[16] = (...f) => e.handleBlur && e.handleBlur(...f)),
                onInput: t[17] || (t[17] = (...f) => e.onInput && e.onInput(...f)),
                onKeydown: [
                  t[18] || (t[18] = ut(Ae((f) => e.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                  t[19] || (t[19] = ut(Ae((f) => e.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                  t[20] || (t[20] = ut(Ae((...f) => e.onKeyboardSelect && e.onKeyboardSelect(...f), ["stop", "prevent"]), ["enter"])),
                  t[21] || (t[21] = ut(Ae((...f) => e.handleEsc && e.handleEsc(...f), ["stop", "prevent"]), ["esc"]))
                ],
                "onUpdate:modelValue": t[22] || (t[22] = (...f) => e.onUpdateInputValue && e.onUpdateInputValue(...f))
              }, null, 42, Kw), [
                [p, e.states.displayInputValue]
              ])
            ], 2),
            e.filterable ? (E(), _("span", {
              key: 0,
              ref: "calculatorRef",
              "aria-hidden": "true",
              class: $([
                e.nsSelectV2.e("selected-item"),
                e.nsSelectV2.e("input-calculator")
              ]),
              textContent: ce(e.states.displayInputValue)
            }, null, 10, Ww)) : W("v-if", !0)
          ], 64)),
          e.shouldShowPlaceholder ? (E(), _("span", {
            key: 3,
            class: $([
              e.nsSelectV2.e("placeholder"),
              e.nsSelectV2.is("transparent", e.multiple ? e.modelValue.length === 0 : !e.hasModelValue)
            ])
          }, ce(e.currentPlaceholder), 3)) : W("v-if", !0),
          H("span", {
            class: $(e.nsSelectV2.e("suffix"))
          }, [
            e.iconComponent ? qe((E(), q(u, {
              key: 0,
              class: $([e.nsSelectV2.e("caret"), e.nsInput.e("icon"), e.iconReverse])
            }, {
              default: K(() => [
                (E(), q(Ge(e.iconComponent)))
              ]),
              _: 1
            }, 8, ["class"])), [
              [at, !e.showClearBtn]
            ]) : W("v-if", !0),
            e.showClearBtn && e.clearIcon ? (E(), q(u, {
              key: 1,
              class: $([e.nsSelectV2.e("caret"), e.nsInput.e("icon")]),
              onClick: Ae(e.handleClear, ["prevent", "stop"])
            }, {
              default: K(() => [
                (E(), q(Ge(e.clearIcon)))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : W("v-if", !0),
            e.validateState && e.validateIcon ? (E(), q(u, {
              key: 2,
              class: $([e.nsInput.e("icon"), e.nsInput.e("validateIcon")])
            }, {
              default: K(() => [
                (E(), q(Ge(e.validateIcon)))
              ]),
              _: 1
            }, 8, ["class"])) : W("v-if", !0)
          ], 2)
        ], 2)
      ]),
      content: K(() => [
        x(c, {
          ref: "menuRef",
          data: e.filteredOptions,
          width: e.popperSize,
          "hovering-index": e.states.hoveringIndex,
          "scrollbar-always-on": e.scrollbarAlwaysOn
        }, {
          default: K((f) => [
            ne(e.$slots, "default", Zt(da(f)))
          ]),
          empty: K(() => [
            ne(e.$slots, "empty", {}, () => [
              H("p", {
                class: $(e.nsSelectV2.e("empty"))
              }, ce(e.emptyText ? e.emptyText : ""), 3)
            ])
          ]),
          _: 3
        }, 8, ["data", "width", "hovering-index", "scrollbar-always-on"])
      ]),
      _: 3
    }, 8, ["visible", "teleported", "popper-class", "popper-options", "effect", "placement", "transition", "persistent", "onBeforeShow"])
  ], 34)), [
    [d, e.handleClickOutside, e.popperRef]
  ]);
}
var bo = /* @__PURE__ */ de(xw, [["render", jw], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/select.vue"]]);
bo.install = (e) => {
  e.component(bo.name, bo);
};
const Uw = bo, qw = Uw, Gw = he({
  animated: {
    type: Boolean,
    default: !1
  },
  count: {
    type: Number,
    default: 1
  },
  rows: {
    type: Number,
    default: 3
  },
  loading: {
    type: Boolean,
    default: !0
  },
  throttle: {
    type: Number
  }
}), Yw = he({
  variant: {
    type: String,
    values: [
      "circle",
      "rect",
      "h1",
      "h3",
      "text",
      "caption",
      "p",
      "image",
      "button"
    ],
    default: "text"
  }
}), Xw = F({
  name: "ElSkeletonItem"
}), Zw = /* @__PURE__ */ F({
  ...Xw,
  props: Yw,
  setup(e) {
    const t = se("skeleton");
    return (n, l) => (E(), _("div", {
      class: $([s(t).e("item"), s(t).e(n.variant)])
    }, [
      n.variant === "image" ? (E(), q(s(Wd), { key: 0 })) : W("v-if", !0)
    ], 2));
  }
});
var xo = /* @__PURE__ */ de(Zw, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton-item.vue"]]);
const Jw = F({
  name: "ElSkeleton"
}), Qw = /* @__PURE__ */ F({
  ...Jw,
  props: Gw,
  setup(e, { expose: t }) {
    const n = e, l = se("skeleton"), o = qp(tn(n, "loading"), n.throttle);
    return t({
      uiLoading: o
    }), (a, r) => s(o) ? (E(), _("div", Be({
      key: 0,
      class: [s(l).b(), s(l).is("animated", a.animated)]
    }, a.$attrs), [
      (E(!0), _(Re, null, Xe(a.count, (i) => (E(), _(Re, { key: i }, [
        a.loading ? ne(a.$slots, "template", { key: i }, () => [
          x(xo, {
            class: $(s(l).is("first")),
            variant: "p"
          }, null, 8, ["class"]),
          (E(!0), _(Re, null, Xe(a.rows, (u) => (E(), q(xo, {
            key: u,
            class: $([
              s(l).e("paragraph"),
              s(l).is("last", u === a.rows && a.rows > 1)
            ]),
            variant: "p"
          }, null, 8, ["class"]))), 128))
        ]) : W("v-if", !0)
      ], 64))), 128))
    ], 16)) : ne(a.$slots, "default", Zt(Be({ key: 1 }, a.$attrs)));
  }
});
var ek = /* @__PURE__ */ de(Qw, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton.vue"]]);
const tk = xe(ek, {
  SkeletonItem: xo
}), nk = Rt(xo), yc = Symbol("sliderContextKey"), lk = he({
  modelValue: {
    type: j([Number, Array]),
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  min: {
    type: Number,
    default: 0
  },
  max: {
    type: Number,
    default: 100
  },
  step: {
    type: Number,
    default: 1
  },
  showInput: Boolean,
  showInputControls: {
    type: Boolean,
    default: !0
  },
  size: Cn,
  inputSize: Cn,
  showStops: Boolean,
  showTooltip: {
    type: Boolean,
    default: !0
  },
  formatTooltip: {
    type: j(Function),
    default: void 0
  },
  disabled: Boolean,
  range: Boolean,
  vertical: Boolean,
  height: String,
  debounce: {
    type: Number,
    default: 300
  },
  label: {
    type: String,
    default: void 0
  },
  rangeStartLabel: {
    type: String,
    default: void 0
  },
  rangeEndLabel: {
    type: String,
    default: void 0
  },
  formatValueText: {
    type: j(Function),
    default: void 0
  },
  tooltipClass: {
    type: String,
    default: void 0
  },
  placement: {
    type: String,
    values: ua,
    default: "top"
  },
  marks: {
    type: j(Object)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), us = (e) => Pe(e) || Je(e) && e.every(Pe), ok = {
  [et]: us,
  [nn]: us,
  [vt]: us
}, sk = (e, t, n) => {
  const l = N();
  return We(async () => {
    e.range ? (Array.isArray(e.modelValue) ? (t.firstValue = Math.max(e.min, e.modelValue[0]), t.secondValue = Math.min(e.max, e.modelValue[1])) : (t.firstValue = e.min, t.secondValue = e.max), t.oldValue = [t.firstValue, t.secondValue]) : (typeof e.modelValue != "number" || Number.isNaN(e.modelValue) ? t.firstValue = e.min : t.firstValue = Math.min(e.max, Math.max(e.min, e.modelValue)), t.oldValue = t.firstValue), Nt(window, "resize", n), await Ne(), n();
  }), {
    sliderWrapper: l
  };
}, ak = (e) => k(() => e.marks ? Object.keys(e.marks).map(Number.parseFloat).sort((n, l) => n - l).filter((n) => n <= e.max && n >= e.min).map((n) => ({
  point: n,
  position: (n - e.min) * 100 / (e.max - e.min),
  mark: e.marks[n]
})) : []), rk = (e, t, n) => {
  const { form: l, formItem: o } = kl(), a = ht(), r = N(), i = N(), u = {
    firstButton: r,
    secondButton: i
  }, c = k(() => e.disabled || (l == null ? void 0 : l.disabled) || !1), p = k(() => Math.min(t.firstValue, t.secondValue)), d = k(() => Math.max(t.firstValue, t.secondValue)), f = k(() => e.range ? `${100 * (d.value - p.value) / (e.max - e.min)}%` : `${100 * (t.firstValue - e.min) / (e.max - e.min)}%`), h = k(() => e.range ? `${100 * (p.value - e.min) / (e.max - e.min)}%` : "0%"), v = k(() => e.vertical ? { height: e.height } : {}), m = k(() => e.vertical ? {
    height: f.value,
    bottom: h.value
  } : {
    width: f.value,
    left: h.value
  }), g = () => {
    a.value && (t.sliderSize = a.value[`client${e.vertical ? "Height" : "Width"}`]);
  }, w = (D) => {
    const A = e.min + D * (e.max - e.min) / 100;
    if (!e.range)
      return r;
    let z;
    return Math.abs(p.value - A) < Math.abs(d.value - A) ? z = t.firstValue < t.secondValue ? "firstButton" : "secondButton" : z = t.firstValue > t.secondValue ? "firstButton" : "secondButton", u[z];
  }, C = (D) => {
    const A = w(D);
    return A.value.setPosition(D), A;
  }, y = (D) => {
    t.firstValue = D, S(e.range ? [p.value, d.value] : D);
  }, b = (D) => {
    t.secondValue = D, e.range && S([p.value, d.value]);
  }, S = (D) => {
    n(et, D), n(nn, D);
  }, T = async () => {
    await Ne(), n(vt, e.range ? [p.value, d.value] : e.modelValue);
  }, O = (D) => {
    var A, z, Z, J, V, M;
    if (c.value || t.dragging)
      return;
    g();
    let P = 0;
    if (e.vertical) {
      const L = (Z = (z = (A = D.touches) == null ? void 0 : A.item(0)) == null ? void 0 : z.clientY) != null ? Z : D.clientY;
      P = (a.value.getBoundingClientRect().bottom - L) / t.sliderSize * 100;
    } else {
      const L = (M = (V = (J = D.touches) == null ? void 0 : J.item(0)) == null ? void 0 : V.clientX) != null ? M : D.clientX, U = a.value.getBoundingClientRect().left;
      P = (L - U) / t.sliderSize * 100;
    }
    if (!(P < 0 || P > 100))
      return C(P);
  };
  return {
    elFormItem: o,
    slider: a,
    firstButton: r,
    secondButton: i,
    sliderDisabled: c,
    minValue: p,
    maxValue: d,
    runwayStyle: v,
    barStyle: m,
    resetSize: g,
    setPosition: C,
    emitChange: T,
    onSliderWrapperPrevent: (D) => {
      var A, z;
      (((A = u.firstButton.value) == null ? void 0 : A.dragging) || ((z = u.secondButton.value) == null ? void 0 : z.dragging)) && D.preventDefault();
    },
    onSliderClick: (D) => {
      O(D) && T();
    },
    onSliderDown: async (D) => {
      const A = O(D);
      A && (await Ne(), A.value.onButtonDown(D));
    },
    setFirstValue: y,
    setSecondValue: b
  };
}, { left: ik, down: uk, right: ck, up: dk, home: fk, end: pk, pageUp: hk, pageDown: vk } = Ce, mk = (e, t, n) => {
  const l = N(), o = N(!1), a = k(() => t.value instanceof Function), r = k(() => a.value && t.value(e.modelValue) || e.modelValue), i = Gt(() => {
    n.value && (o.value = !0);
  }, 50), u = Gt(() => {
    n.value && (o.value = !1);
  }, 50);
  return {
    tooltip: l,
    tooltipVisible: o,
    formatValue: r,
    displayTooltip: i,
    hideTooltip: u
  };
}, gk = (e, t, n) => {
  const {
    disabled: l,
    min: o,
    max: a,
    step: r,
    showTooltip: i,
    precision: u,
    sliderSize: c,
    formatTooltip: p,
    emitChange: d,
    resetSize: f,
    updateDragging: h
  } = Oe(yc), { tooltip: v, tooltipVisible: m, formatValue: g, displayTooltip: w, hideTooltip: C } = mk(e, p, i), y = N(), b = k(() => `${(e.modelValue - o.value) / (a.value - o.value) * 100}%`), S = k(() => e.vertical ? { bottom: b.value } : { left: b.value }), T = () => {
    t.hovering = !0, w();
  }, O = () => {
    t.hovering = !1, t.dragging || C();
  }, I = (le) => {
    l.value || (le.preventDefault(), P(le), window.addEventListener("mousemove", L), window.addEventListener("touchmove", L), window.addEventListener("mouseup", U), window.addEventListener("touchend", U), window.addEventListener("contextmenu", U), y.value.focus());
  }, R = (le) => {
    l.value || (t.newPosition = Number.parseFloat(b.value) + le / (a.value - o.value) * 100, oe(t.newPosition), d());
  }, B = () => {
    R(-r.value);
  }, D = () => {
    R(r.value);
  }, A = () => {
    R(-r.value * 4);
  }, z = () => {
    R(r.value * 4);
  }, Z = () => {
    l.value || (oe(0), d());
  }, J = () => {
    l.value || (oe(100), d());
  }, V = (le) => {
    let ee = !0;
    [ik, uk].includes(le.key) ? B() : [ck, dk].includes(le.key) ? D() : le.key === fk ? Z() : le.key === pk ? J() : le.key === vk ? A() : le.key === hk ? z() : ee = !1, ee && le.preventDefault();
  }, M = (le) => {
    let ee, pe;
    return le.type.startsWith("touch") ? (pe = le.touches[0].clientY, ee = le.touches[0].clientX) : (pe = le.clientY, ee = le.clientX), {
      clientX: ee,
      clientY: pe
    };
  }, P = (le) => {
    t.dragging = !0, t.isClick = !0;
    const { clientX: ee, clientY: pe } = M(le);
    e.vertical ? t.startY = pe : t.startX = ee, t.startPosition = Number.parseFloat(b.value), t.newPosition = t.startPosition;
  }, L = (le) => {
    if (t.dragging) {
      t.isClick = !1, w(), f();
      let ee;
      const { clientX: pe, clientY: ge } = M(le);
      e.vertical ? (t.currentY = ge, ee = (t.startY - t.currentY) / c.value * 100) : (t.currentX = pe, ee = (t.currentX - t.startX) / c.value * 100), t.newPosition = t.startPosition + ee, oe(t.newPosition);
    }
  }, U = () => {
    t.dragging && (setTimeout(() => {
      t.dragging = !1, t.hovering || C(), t.isClick || oe(t.newPosition), d();
    }, 0), window.removeEventListener("mousemove", L), window.removeEventListener("touchmove", L), window.removeEventListener("mouseup", U), window.removeEventListener("touchend", U), window.removeEventListener("contextmenu", U));
  }, oe = async (le) => {
    if (le === null || Number.isNaN(+le))
      return;
    le < 0 ? le = 0 : le > 100 && (le = 100);
    const ee = 100 / ((a.value - o.value) / r.value);
    let ge = Math.round(le / ee) * ee * (a.value - o.value) * 0.01 + o.value;
    ge = Number.parseFloat(ge.toFixed(u.value)), ge !== e.modelValue && n(et, ge), !t.dragging && e.modelValue !== t.oldValue && (t.oldValue = e.modelValue), await Ne(), t.dragging && w(), v.value.updatePopper();
  };
  return ue(() => t.dragging, (le) => {
    h(le);
  }), {
    disabled: l,
    button: y,
    tooltip: v,
    tooltipVisible: m,
    showTooltip: i,
    wrapperStyle: S,
    formatValue: g,
    handleMouseEnter: T,
    handleMouseLeave: O,
    onButtonDown: I,
    onKeyDown: V,
    setPosition: oe
  };
}, yk = (e, t, n, l) => ({
  stops: k(() => {
    if (!e.showStops || e.min > e.max)
      return [];
    if (e.step === 0)
      return pt("ElSlider", "step should not be 0."), [];
    const r = (e.max - e.min) / e.step, i = 100 * e.step / (e.max - e.min), u = Array.from({ length: r - 1 }).map((c, p) => (p + 1) * i);
    return e.range ? u.filter((c) => c < 100 * (n.value - e.min) / (e.max - e.min) || c > 100 * (l.value - e.min) / (e.max - e.min)) : u.filter((c) => c > 100 * (t.firstValue - e.min) / (e.max - e.min));
  }),
  getStopStyle: (r) => e.vertical ? { bottom: `${r}%` } : { left: `${r}%` }
}), bk = (e, t, n, l, o, a) => {
  const r = (c) => {
    o(et, c), o(nn, c);
  }, i = () => e.range ? ![n.value, l.value].every((c, p) => c === t.oldValue[p]) : e.modelValue !== t.oldValue, u = () => {
    var c, p;
    e.min > e.max && wt("Slider", "min should not be greater than max.");
    const d = e.modelValue;
    e.range && Array.isArray(d) ? d[1] < e.min ? r([e.min, e.min]) : d[0] > e.max ? r([e.max, e.max]) : d[0] < e.min ? r([e.min, d[1]]) : d[1] > e.max ? r([d[0], e.max]) : (t.firstValue = d[0], t.secondValue = d[1], i() && (e.validateEvent && ((c = a == null ? void 0 : a.validate) == null || c.call(a, "change").catch((f) => pt(f))), t.oldValue = d.slice())) : !e.range && typeof d == "number" && !Number.isNaN(d) && (d < e.min ? r(e.min) : d > e.max ? r(e.max) : (t.firstValue = d, i() && (e.validateEvent && ((p = a == null ? void 0 : a.validate) == null || p.call(a, "change").catch((f) => pt(f))), t.oldValue = d)));
  };
  u(), ue(() => t.dragging, (c) => {
    c || u();
  }), ue(() => e.modelValue, (c, p) => {
    t.dragging || Array.isArray(c) && Array.isArray(p) && c.every((d, f) => d === p[f]) && t.firstValue === c[0] && t.secondValue === c[1] || u();
  }, {
    deep: !0
  }), ue(() => [e.min, e.max], () => {
    u();
  });
}, Ck = he({
  modelValue: {
    type: Number,
    default: 0
  },
  vertical: Boolean,
  tooltipClass: String,
  placement: {
    type: String,
    values: ua,
    default: "top"
  }
}), wk = {
  [et]: (e) => Pe(e)
}, kk = ["tabindex"], Sk = F({
  name: "ElSliderButton"
}), Ek = /* @__PURE__ */ F({
  ...Sk,
  props: Ck,
  emits: wk,
  setup(e, { expose: t, emit: n }) {
    const l = e, o = se("slider"), a = ct({
      hovering: !1,
      dragging: !1,
      isClick: !1,
      startX: 0,
      currentX: 0,
      startY: 0,
      currentY: 0,
      startPosition: 0,
      newPosition: 0,
      oldValue: l.modelValue
    }), {
      disabled: r,
      button: i,
      tooltip: u,
      showTooltip: c,
      tooltipVisible: p,
      wrapperStyle: d,
      formatValue: f,
      handleMouseEnter: h,
      handleMouseLeave: v,
      onButtonDown: m,
      onKeyDown: g,
      setPosition: w
    } = gk(l, a, n), { hovering: C, dragging: y } = Ut(a);
    return t({
      onButtonDown: m,
      onKeyDown: g,
      setPosition: w,
      hovering: C,
      dragging: y
    }), (b, S) => (E(), _("div", {
      ref_key: "button",
      ref: i,
      class: $([s(o).e("button-wrapper"), { hover: s(C), dragging: s(y) }]),
      style: ye(s(d)),
      tabindex: s(r) ? -1 : 0,
      onMouseenter: S[0] || (S[0] = (...T) => s(h) && s(h)(...T)),
      onMouseleave: S[1] || (S[1] = (...T) => s(v) && s(v)(...T)),
      onMousedown: S[2] || (S[2] = (...T) => s(m) && s(m)(...T)),
      onTouchstart: S[3] || (S[3] = (...T) => s(m) && s(m)(...T)),
      onFocus: S[4] || (S[4] = (...T) => s(h) && s(h)(...T)),
      onBlur: S[5] || (S[5] = (...T) => s(v) && s(v)(...T)),
      onKeydown: S[6] || (S[6] = (...T) => s(g) && s(g)(...T))
    }, [
      x(s(Wt), {
        ref_key: "tooltip",
        ref: u,
        visible: s(p),
        placement: b.placement,
        "fallback-placements": ["top", "bottom", "right", "left"],
        "stop-popper-mouse-event": !1,
        "popper-class": b.tooltipClass,
        disabled: !s(c),
        persistent: ""
      }, {
        content: K(() => [
          H("span", null, ce(s(f)), 1)
        ]),
        default: K(() => [
          H("div", {
            class: $([s(o).e("button"), { hover: s(C), dragging: s(y) }])
          }, null, 2)
        ]),
        _: 1
      }, 8, ["visible", "placement", "popper-class", "disabled"])
    ], 46, kk));
  }
});
var Kr = /* @__PURE__ */ de(Ek, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/button.vue"]]);
const $k = he({
  mark: {
    type: j([String, Object]),
    default: void 0
  }
});
var Tk = F({
  name: "ElSliderMarker",
  props: $k,
  setup(e) {
    const t = se("slider"), n = k(() => Ue(e.mark) ? e.mark : e.mark.label), l = k(() => Ue(e.mark) ? void 0 : e.mark.style);
    return () => fe("div", {
      class: t.e("marks-text"),
      style: l.value
    }, n.value);
  }
});
const Nk = ["id", "role", "aria-label", "aria-labelledby"], Ik = { key: 1 }, Mk = F({
  name: "ElSlider"
}), Rk = /* @__PURE__ */ F({
  ...Mk,
  props: lk,
  emits: ok,
  setup(e, { expose: t, emit: n }) {
    const l = e, o = se("slider"), { t: a } = ot(), r = ct({
      firstValue: 0,
      secondValue: 0,
      oldValue: 0,
      dragging: !1,
      sliderSize: 1
    }), {
      elFormItem: i,
      slider: u,
      firstButton: c,
      secondButton: p,
      sliderDisabled: d,
      minValue: f,
      maxValue: h,
      runwayStyle: v,
      barStyle: m,
      resetSize: g,
      emitChange: w,
      onSliderWrapperPrevent: C,
      onSliderClick: y,
      onSliderDown: b,
      setFirstValue: S,
      setSecondValue: T
    } = rk(l, r, n), { stops: O, getStopStyle: I } = yk(l, r, f, h), { inputId: R, isLabeledByFormItem: B } = jo(l, {
      formItemContext: i
    }), D = dn(), A = k(() => l.inputSize || D.value), z = k(() => l.label || a("el.slider.defaultLabel", {
      min: l.min,
      max: l.max
    })), Z = k(() => l.range ? l.rangeStartLabel || a("el.slider.defaultRangeStartLabel") : z.value), J = k(() => l.formatValueText ? l.formatValueText(le.value) : `${le.value}`), V = k(() => l.rangeEndLabel || a("el.slider.defaultRangeEndLabel")), M = k(() => l.formatValueText ? l.formatValueText(ee.value) : `${ee.value}`), P = k(() => [
      o.b(),
      o.m(D.value),
      o.is("vertical", l.vertical),
      { [o.m("with-input")]: l.showInput }
    ]), L = ak(l);
    bk(l, r, f, h, n, i);
    const U = k(() => {
      const te = [l.min, l.max, l.step].map((ve) => {
        const G = `${ve}`.split(".")[1];
        return G ? G.length : 0;
      });
      return Math.max.apply(null, te);
    }), { sliderWrapper: oe } = sk(l, r, g), { firstValue: le, secondValue: ee, sliderSize: pe } = Ut(r), ge = (te) => {
      r.dragging = te;
    };
    return tt(yc, {
      ...Ut(l),
      sliderSize: pe,
      disabled: d,
      precision: U,
      emitChange: w,
      resetSize: g,
      updateDragging: ge
    }), t({
      onSliderClick: y
    }), (te, ve) => {
      var G, Q;
      return E(), _("div", {
        id: te.range ? s(R) : void 0,
        ref_key: "sliderWrapper",
        ref: oe,
        class: $(s(P)),
        role: te.range ? "group" : void 0,
        "aria-label": te.range && !s(B) ? s(z) : void 0,
        "aria-labelledby": te.range && s(B) ? (G = s(i)) == null ? void 0 : G.labelId : void 0,
        onTouchstart: ve[2] || (ve[2] = (...ie) => s(C) && s(C)(...ie)),
        onTouchmove: ve[3] || (ve[3] = (...ie) => s(C) && s(C)(...ie))
      }, [
        H("div", {
          ref_key: "slider",
          ref: u,
          class: $([
            s(o).e("runway"),
            { "show-input": te.showInput && !te.range },
            s(o).is("disabled", s(d))
          ]),
          style: ye(s(v)),
          onMousedown: ve[0] || (ve[0] = (...ie) => s(b) && s(b)(...ie)),
          onTouchstart: ve[1] || (ve[1] = (...ie) => s(b) && s(b)(...ie))
        }, [
          H("div", {
            class: $(s(o).e("bar")),
            style: ye(s(m))
          }, null, 6),
          x(Kr, {
            id: te.range ? void 0 : s(R),
            ref_key: "firstButton",
            ref: c,
            "model-value": s(le),
            vertical: te.vertical,
            "tooltip-class": te.tooltipClass,
            placement: te.placement,
            role: "slider",
            "aria-label": te.range || !s(B) ? s(Z) : void 0,
            "aria-labelledby": !te.range && s(B) ? (Q = s(i)) == null ? void 0 : Q.labelId : void 0,
            "aria-valuemin": te.min,
            "aria-valuemax": te.range ? s(ee) : te.max,
            "aria-valuenow": s(le),
            "aria-valuetext": s(J),
            "aria-orientation": te.vertical ? "vertical" : "horizontal",
            "aria-disabled": s(d),
            "onUpdate:modelValue": s(S)
          }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
          te.range ? (E(), q(Kr, {
            key: 0,
            ref_key: "secondButton",
            ref: p,
            "model-value": s(ee),
            vertical: te.vertical,
            "tooltip-class": te.tooltipClass,
            placement: te.placement,
            role: "slider",
            "aria-label": s(V),
            "aria-valuemin": s(le),
            "aria-valuemax": te.max,
            "aria-valuenow": s(ee),
            "aria-valuetext": s(M),
            "aria-orientation": te.vertical ? "vertical" : "horizontal",
            "aria-disabled": s(d),
            "onUpdate:modelValue": s(T)
          }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : W("v-if", !0),
          te.showStops ? (E(), _("div", Ik, [
            (E(!0), _(Re, null, Xe(s(O), (ie, Ee) => (E(), _("div", {
              key: Ee,
              class: $(s(o).e("stop")),
              style: ye(s(I)(ie))
            }, null, 6))), 128))
          ])) : W("v-if", !0),
          s(L).length > 0 ? (E(), _(Re, { key: 2 }, [
            H("div", null, [
              (E(!0), _(Re, null, Xe(s(L), (ie, Ee) => (E(), _("div", {
                key: Ee,
                style: ye(s(I)(ie.position)),
                class: $([s(o).e("stop"), s(o).e("marks-stop")])
              }, null, 6))), 128))
            ]),
            H("div", {
              class: $(s(o).e("marks"))
            }, [
              (E(!0), _(Re, null, Xe(s(L), (ie, Ee) => (E(), q(s(Tk), {
                key: Ee,
                mark: ie.mark,
                style: ye(s(I)(ie.position))
              }, null, 8, ["mark", "style"]))), 128))
            ], 2)
          ], 64)) : W("v-if", !0)
        ], 38),
        te.showInput && !te.range ? (E(), q(s(Ni), {
          key: 0,
          ref: "input",
          "model-value": s(le),
          class: $(s(o).e("input")),
          step: te.step,
          disabled: s(d),
          controls: te.showInputControls,
          min: te.min,
          max: te.max,
          debounce: te.debounce,
          size: s(A),
          "onUpdate:modelValue": s(S),
          onChange: s(w)
        }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : W("v-if", !0)
      ], 42, Nk);
    };
  }
});
var Ok = /* @__PURE__ */ de(Rk, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/slider.vue"]]);
const Pk = xe(Ok), Ak = he({
  prefixCls: {
    type: String
  }
}), Wr = F({
  name: "ElSpaceItem",
  props: Ak,
  setup(e, { slots: t }) {
    const n = se("space"), l = k(() => `${e.prefixCls || n.b()}__item`);
    return () => fe("div", { class: l.value }, ne(t, "default"));
  }
}), jr = {
  small: 8,
  default: 12,
  large: 16
};
function _k(e) {
  const t = se("space"), n = k(() => [t.b(), t.m(e.direction), e.class]), l = N(0), o = N(0), a = k(() => {
    const i = e.wrap || e.fill ? { flexWrap: "wrap", marginBottom: `-${o.value}px` } : {}, u = {
      alignItems: e.alignment
    };
    return [i, u, e.style];
  }), r = k(() => {
    const i = {
      paddingBottom: `${o.value}px`,
      marginRight: `${l.value}px`
    }, u = e.fill ? { flexGrow: 1, minWidth: `${e.fillRatio}%` } : {};
    return [i, u];
  });
  return en(() => {
    const { size: i = "small", wrap: u, direction: c, fill: p } = e;
    if (Je(i)) {
      const [d = 0, f = 0] = i;
      l.value = d, o.value = f;
    } else {
      let d;
      Pe(i) ? d = i : d = jr[i || "small"] || jr.small, (u || p) && c === "horizontal" ? l.value = o.value = d : c === "horizontal" ? (l.value = d, o.value = 0) : (o.value = d, l.value = 0);
    }
  }), {
    classes: n,
    containerStyle: a,
    itemStyle: r
  };
}
const Lk = he({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  class: {
    type: j([
      String,
      Object,
      Array
    ]),
    default: ""
  },
  style: {
    type: j([String, Array, Object]),
    default: ""
  },
  alignment: {
    type: j(String),
    default: "center"
  },
  prefixCls: {
    type: String
  },
  spacer: {
    type: j([Object, String, Number, Array]),
    default: null,
    validator: (e) => Mt(e) || Pe(e) || Ue(e)
  },
  wrap: Boolean,
  fill: Boolean,
  fillRatio: {
    type: Number,
    default: 100
  },
  size: {
    type: [String, Array, Number],
    values: Yl,
    validator: (e) => Pe(e) || Je(e) && e.length === 2 && e.every(Pe)
  }
}), Vk = F({
  name: "ElSpace",
  props: Lk,
  setup(e, { slots: t }) {
    const { classes: n, containerStyle: l, itemStyle: o } = _k(e);
    function a(r, i = "", u = []) {
      const { prefixCls: c } = e;
      return r.forEach((p, d) => {
        tr(p) ? Je(p.children) && p.children.forEach((f, h) => {
          tr(f) && Je(f.children) ? a(f.children, `${i + h}-`, u) : u.push(x(Wr, {
            style: o.value,
            prefixCls: c,
            key: `nested-${i + h}`
          }, {
            default: () => [f]
          }, Sn.PROPS | Sn.STYLE, ["style", "prefixCls"]));
        }) : jd(p) && u.push(x(Wr, {
          style: o.value,
          prefixCls: c,
          key: `LoopKey${i + d}`
        }, {
          default: () => [p]
        }, Sn.PROPS | Sn.STYLE, ["style", "prefixCls"]));
      }), u;
    }
    return () => {
      var r;
      const { spacer: i, direction: u } = e, c = ne(t, "default", { key: 0 }, () => []);
      if (((r = c.children) != null ? r : []).length === 0)
        return null;
      if (Je(c.children)) {
        let p = a(c.children);
        if (i) {
          const d = p.length - 1;
          p = p.reduce((f, h, v) => {
            const m = [...f, h];
            return v !== d && m.push(x("span", {
              style: [
                o.value,
                u === "vertical" ? "width: 100%" : null
              ],
              key: v
            }, [
              Mt(i) ? i : st(i, Sn.TEXT)
            ], Sn.STYLE)), m;
          }, []);
        }
        return x("div", {
          class: n.value,
          style: l.value
        }, p, Sn.STYLE | Sn.CLASS);
      }
      return c.children;
    };
  }
}), Bk = xe(Vk), Dk = he({
  decimalSeparator: {
    type: String,
    default: "."
  },
  groupSeparator: {
    type: String,
    default: ","
  },
  precision: {
    type: Number,
    default: 0
  },
  formatter: Function,
  value: {
    type: j([Number, Object]),
    default: 0
  },
  prefix: String,
  suffix: String,
  title: String,
  valueStyle: {
    type: j([String, Object, Array])
  }
}), xk = F({
  name: "ElStatistic"
}), Fk = /* @__PURE__ */ F({
  ...xk,
  props: Dk,
  setup(e, { expose: t }) {
    const n = e, l = se("statistic"), o = k(() => {
      const { value: a, formatter: r, precision: i, decimalSeparator: u, groupSeparator: c } = n;
      if (mt(r))
        return r(a);
      if (!Pe(a))
        return a;
      let [p, d = ""] = String(a).split(".");
      return d = d.padEnd(i, "0").slice(0, i > 0 ? i : 0), p = p.replace(/\B(?=(\d{3})+(?!\d))/g, c), [p, d].join(d ? u : "");
    });
    return t({
      displayValue: o
    }), (a, r) => (E(), _("div", {
      class: $(s(l).b())
    }, [
      a.$slots.title || a.title ? (E(), _("div", {
        key: 0,
        class: $(s(l).e("head"))
      }, [
        ne(a.$slots, "title", {}, () => [
          st(ce(a.title), 1)
        ])
      ], 2)) : W("v-if", !0),
      H("div", {
        class: $(s(l).e("content"))
      }, [
        a.$slots.prefix || a.prefix ? (E(), _("div", {
          key: 0,
          class: $(s(l).e("prefix"))
        }, [
          ne(a.$slots, "prefix", {}, () => [
            H("span", null, ce(a.prefix), 1)
          ])
        ], 2)) : W("v-if", !0),
        H("span", {
          class: $(s(l).e("number")),
          style: ye(a.valueStyle)
        }, ce(s(o)), 7),
        a.$slots.suffix || a.suffix ? (E(), _("div", {
          key: 1,
          class: $(s(l).e("suffix"))
        }, [
          ne(a.$slots, "suffix", {}, () => [
            H("span", null, ce(a.suffix), 1)
          ])
        ], 2)) : W("v-if", !0)
      ], 2)
    ], 2));
  }
});
var Hk = /* @__PURE__ */ de(Fk, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/statistic/src/statistic.vue"]]);
const bc = xe(Hk), zk = he({
  format: {
    type: String,
    default: "HH:mm:ss"
  },
  prefix: String,
  suffix: String,
  title: String,
  value: {
    type: j([Number, Object]),
    default: 0
  },
  valueStyle: {
    type: j([String, Object, Array])
  }
}), Kk = {
  finish: () => !0,
  [vt]: (e) => Pe(e)
}, Wk = [
  ["Y", 1e3 * 60 * 60 * 24 * 365],
  ["M", 1e3 * 60 * 60 * 24 * 30],
  ["D", 1e3 * 60 * 60 * 24],
  ["H", 1e3 * 60 * 60],
  ["m", 1e3 * 60],
  ["s", 1e3],
  ["S", 1]
], Ur = (e) => Pe(e) ? new Date(e).getTime() : e.valueOf(), qr = (e, t) => {
  let n = e;
  const l = /\[([^\]]*)]/g;
  return Wk.reduce((a, [r, i]) => {
    const u = new RegExp(`${r}+(?![^\\[\\]]*\\])`, "g");
    if (u.test(a)) {
      const c = Math.floor(n / i);
      return n -= c * i, a.replace(u, (p) => String(c).padStart(p.length, "0"));
    }
    return a;
  }, t).replace(l, "$1");
}, jk = F({
  name: "ElCountdown"
}), Uk = /* @__PURE__ */ F({
  ...jk,
  props: zk,
  emits: Kk,
  setup(e, { expose: t, emit: n }) {
    const l = e;
    let o;
    const a = N(Ur(l.value) - Date.now()), r = k(() => qr(a.value, l.format)), i = (p) => qr(p, l.format), u = () => {
      o && (Xo(o), o = void 0);
    }, c = () => {
      const p = Ur(l.value), d = () => {
        let f = p - Date.now();
        n("change", f), f <= 0 ? (f = 0, u(), n("finish")) : o = Bl(d), a.value = f;
      };
      o = Bl(d);
    };
    return ue(() => [l.value, l.format], () => {
      u(), c();
    }, {
      immediate: !0
    }), Dt(() => {
      u();
    }), t({
      displayValue: r
    }), (p, d) => (E(), q(s(bc), {
      value: a.value,
      title: p.title,
      prefix: p.prefix,
      suffix: p.suffix,
      "value-style": p.valueStyle,
      formatter: i
    }, Yn({ _: 2 }, [
      Xe(p.$slots, (f, h) => ({
        name: h,
        fn: K(() => [
          ne(p.$slots, h)
        ])
      }))
    ]), 1032, ["value", "title", "prefix", "suffix", "value-style"]));
  }
});
var qk = /* @__PURE__ */ de(Uk, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/countdown/src/countdown.vue"]]);
const Gk = xe(qk), Yk = he({
  space: {
    type: [Number, String],
    default: ""
  },
  active: {
    type: Number,
    default: 0
  },
  direction: {
    type: String,
    default: "horizontal",
    values: ["horizontal", "vertical"]
  },
  alignCenter: {
    type: Boolean
  },
  simple: {
    type: Boolean
  },
  finishStatus: {
    type: String,
    values: ["wait", "process", "finish", "error", "success"],
    default: "finish"
  },
  processStatus: {
    type: String,
    values: ["wait", "process", "finish", "error", "success"],
    default: "process"
  }
}), Xk = {
  [vt]: (e, t) => [e, t].every(Pe)
}, Zk = F({
  name: "ElSteps"
}), Jk = /* @__PURE__ */ F({
  ...Zk,
  props: Yk,
  emits: Xk,
  setup(e, { emit: t }) {
    const n = e, l = se("steps"), o = N([]);
    return ue(o, () => {
      o.value.forEach((a, r) => {
        a.setIndex(r);
      });
    }), tt("ElSteps", { props: n, steps: o }), ue(() => n.active, (a, r) => {
      t(vt, a, r);
    }), (a, r) => (E(), _("div", {
      class: $([s(l).b(), s(l).m(a.simple ? "simple" : a.direction)])
    }, [
      ne(a.$slots, "default")
    ], 2));
  }
});
var Qk = /* @__PURE__ */ de(Jk, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/steps/src/steps.vue"]]);
const eS = he({
  title: {
    type: String,
    default: ""
  },
  icon: {
    type: ft
  },
  description: {
    type: String,
    default: ""
  },
  status: {
    type: String,
    values: ["", "wait", "process", "finish", "error", "success"],
    default: ""
  }
}), tS = F({
  name: "ElStep"
}), nS = F({
  ...tS,
  props: eS,
  setup(e) {
    const t = e, n = se("step"), l = N(-1), o = N({}), a = N(""), r = Oe("ElSteps"), i = je();
    We(() => {
      ue([
        () => r.props.active,
        () => r.props.processStatus,
        () => r.props.finishStatus
      ], ([S]) => {
        y(S);
      }, { immediate: !0 });
    }), Dt(() => {
      r.steps.value = r.steps.value.filter((S) => S.uid !== (i == null ? void 0 : i.uid));
    });
    const u = k(() => t.status || a.value), c = k(() => {
      const S = r.steps.value[l.value - 1];
      return S ? S.currentStatus : "wait";
    }), p = k(() => r.props.alignCenter), d = k(() => r.props.direction === "vertical"), f = k(() => r.props.simple), h = k(() => r.steps.value.length), v = k(() => {
      var S;
      return ((S = r.steps.value[h.value - 1]) == null ? void 0 : S.uid) === (i == null ? void 0 : i.uid);
    }), m = k(() => f.value ? "" : r.props.space), g = k(() => {
      const S = {
        flexBasis: Pe(m.value) ? `${m.value}px` : m.value ? m.value : `${100 / (h.value - (p.value ? 0 : 1))}%`
      };
      return d.value || v.value && (S.maxWidth = `${100 / h.value}%`), S;
    }), w = (S) => {
      l.value = S;
    }, C = (S) => {
      const T = S === "wait", O = {
        transitionDelay: `${T ? "-" : ""}${150 * l.value}ms`
      }, I = S === r.props.processStatus || T ? 0 : 100;
      O.borderWidth = I && !f.value ? "1px" : 0, O[r.props.direction === "vertical" ? "height" : "width"] = `${I}%`, o.value = O;
    }, y = (S) => {
      S > l.value ? a.value = r.props.finishStatus : S === l.value && c.value !== "error" ? a.value = r.props.processStatus : a.value = "wait";
      const T = r.steps.value[l.value - 1];
      T && T.calcProgress(a.value);
    }, b = ct({
      uid: k(() => i == null ? void 0 : i.uid),
      currentStatus: u,
      setIndex: w,
      calcProgress: C
    });
    return r.steps.value = [...r.steps.value, b], (S, T) => (E(), _("div", {
      style: ye(s(g)),
      class: $([
        s(n).b(),
        s(n).is(s(f) ? "simple" : s(r).props.direction),
        s(n).is("flex", s(v) && !s(m) && !s(p)),
        s(n).is("center", s(p) && !s(d) && !s(f))
      ])
    }, [
      W(" icon & line "),
      H("div", {
        class: $([s(n).e("head"), s(n).is(s(u))])
      }, [
        s(f) ? W("v-if", !0) : (E(), _("div", {
          key: 0,
          class: $(s(n).e("line"))
        }, [
          H("i", {
            class: $(s(n).e("line-inner")),
            style: ye(o.value)
          }, null, 6)
        ], 2)),
        H("div", {
          class: $([s(n).e("icon"), s(n).is(S.icon || S.$slots.icon ? "icon" : "text")])
        }, [
          ne(S.$slots, "icon", {}, () => [
            S.icon ? (E(), q(s(Se), {
              key: 0,
              class: $(s(n).e("icon-inner"))
            }, {
              default: K(() => [
                (E(), q(Ge(S.icon)))
              ]),
              _: 1
            }, 8, ["class"])) : s(u) === "success" ? (E(), q(s(Se), {
              key: 1,
              class: $([s(n).e("icon-inner"), s(n).is("status")])
            }, {
              default: K(() => [
                x(s(Xl))
              ]),
              _: 1
            }, 8, ["class"])) : s(u) === "error" ? (E(), q(s(Se), {
              key: 2,
              class: $([s(n).e("icon-inner"), s(n).is("status")])
            }, {
              default: K(() => [
                x(s(Sl))
              ]),
              _: 1
            }, 8, ["class"])) : s(f) ? W("v-if", !0) : (E(), _("div", {
              key: 3,
              class: $(s(n).e("icon-inner"))
            }, ce(l.value + 1), 3))
          ])
        ], 2)
      ], 2),
      W(" title & description "),
      H("div", {
        class: $(s(n).e("main"))
      }, [
        H("div", {
          class: $([s(n).e("title"), s(n).is(s(u))])
        }, [
          ne(S.$slots, "title", {}, () => [
            st(ce(S.title), 1)
          ])
        ], 2),
        s(f) ? (E(), _("div", {
          key: 0,
          class: $(s(n).e("arrow"))
        }, null, 2)) : (E(), _("div", {
          key: 1,
          class: $([s(n).e("description"), s(n).is(s(u))])
        }, [
          ne(S.$slots, "description", {}, () => [
            st(ce(S.description), 1)
          ])
        ], 2))
      ], 2)
    ], 6));
  }
});
var Cc = /* @__PURE__ */ de(nS, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/steps/src/item.vue"]]);
const lS = xe(Qk, {
  Step: Cc
}), oS = Rt(Cc), sS = he({
  modelValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  value: {
    type: [Boolean, String, Number],
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  width: {
    type: [String, Number],
    default: ""
  },
  inlinePrompt: {
    type: Boolean,
    default: !1
  },
  activeIcon: {
    type: ft
  },
  inactiveIcon: {
    type: ft
  },
  activeText: {
    type: String,
    default: ""
  },
  inactiveText: {
    type: String,
    default: ""
  },
  activeColor: {
    type: String,
    default: ""
  },
  inactiveColor: {
    type: String,
    default: ""
  },
  borderColor: {
    type: String,
    default: ""
  },
  activeValue: {
    type: [Boolean, String, Number],
    default: !0
  },
  inactiveValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  name: {
    type: String,
    default: ""
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  id: String,
  loading: {
    type: Boolean,
    default: !1
  },
  beforeChange: {
    type: j(Function)
  },
  size: {
    type: String,
    validator: ia
  },
  tabindex: {
    type: [String, Number]
  }
}), aS = {
  [et]: (e) => Qt(e) || Ue(e) || Pe(e),
  [vt]: (e) => Qt(e) || Ue(e) || Pe(e),
  [nn]: (e) => Qt(e) || Ue(e) || Pe(e)
}, rS = ["onClick"], iS = ["id", "aria-checked", "aria-disabled", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"], uS = ["aria-hidden"], cS = ["aria-hidden"], dS = ["aria-hidden"], Co = "ElSwitch", fS = F({
  name: Co
}), pS = /* @__PURE__ */ F({
  ...fS,
  props: sS,
  emits: aS,
  setup(e, { expose: t, emit: n }) {
    const l = e, o = je(), { formItem: a } = kl(), r = dn(), i = se("switch");
    Ll({
      from: '"value"',
      replacement: '"model-value" or "v-model"',
      scope: Co,
      version: "2.3.0",
      ref: "https://element-plus.org/en-US/component/switch.html#attributes",
      type: "Attribute"
    }, k(() => {
      var S;
      return !!((S = o.vnode.props) != null && S.value);
    }));
    const { inputId: u } = jo(l, {
      formItemContext: a
    }), c = Pn(k(() => l.loading)), p = N(l.modelValue !== !1), d = N(), f = N(), h = k(() => [
      i.b(),
      i.m(r.value),
      i.is("disabled", c.value),
      i.is("checked", g.value)
    ]), v = k(() => ({
      width: It(l.width)
    }));
    ue(() => l.modelValue, () => {
      p.value = !0;
    }), ue(() => l.value, () => {
      p.value = !1;
    });
    const m = k(() => p.value ? l.modelValue : l.value), g = k(() => m.value === l.activeValue);
    [l.activeValue, l.inactiveValue].includes(m.value) || (n(et, l.inactiveValue), n(vt, l.inactiveValue), n(nn, l.inactiveValue)), ue(g, (S) => {
      var T;
      d.value.checked = S, l.validateEvent && ((T = a == null ? void 0 : a.validate) == null || T.call(a, "change").catch((O) => pt(O)));
    });
    const w = () => {
      const S = g.value ? l.inactiveValue : l.activeValue;
      n(et, S), n(vt, S), n(nn, S), Ne(() => {
        d.value.checked = g.value;
      });
    }, C = () => {
      if (c.value)
        return;
      const { beforeChange: S } = l;
      if (!S) {
        w();
        return;
      }
      const T = S();
      [
        gs(T),
        Qt(T)
      ].includes(!0) || wt(Co, "beforeChange must return type `Promise<boolean>` or `boolean`"), gs(T) ? T.then((I) => {
        I && w();
      }).catch((I) => {
        pt(Co, `some error occurred: ${I}`);
      }) : T && w();
    }, y = k(() => i.cssVarBlock({
      ...l.activeColor ? { "on-color": l.activeColor } : null,
      ...l.inactiveColor ? { "off-color": l.inactiveColor } : null,
      ...l.borderColor ? { "border-color": l.borderColor } : null
    })), b = () => {
      var S, T;
      (T = (S = d.value) == null ? void 0 : S.focus) == null || T.call(S);
    };
    return We(() => {
      d.value.checked = g.value;
    }), t({
      focus: b,
      checked: g
    }), (S, T) => (E(), _("div", {
      class: $(s(h)),
      style: ye(s(y)),
      onClick: Ae(C, ["prevent"])
    }, [
      H("input", {
        id: s(u),
        ref_key: "input",
        ref: d,
        class: $(s(i).e("input")),
        type: "checkbox",
        role: "switch",
        "aria-checked": s(g),
        "aria-disabled": s(c),
        name: S.name,
        "true-value": S.activeValue,
        "false-value": S.inactiveValue,
        disabled: s(c),
        tabindex: S.tabindex,
        onChange: w,
        onKeydown: ut(C, ["enter"])
      }, null, 42, iS),
      !S.inlinePrompt && (S.inactiveIcon || S.inactiveText) ? (E(), _("span", {
        key: 0,
        class: $([
          s(i).e("label"),
          s(i).em("label", "left"),
          s(i).is("active", !s(g))
        ])
      }, [
        S.inactiveIcon ? (E(), q(s(Se), { key: 0 }, {
          default: K(() => [
            (E(), q(Ge(S.inactiveIcon)))
          ]),
          _: 1
        })) : W("v-if", !0),
        !S.inactiveIcon && S.inactiveText ? (E(), _("span", {
          key: 1,
          "aria-hidden": s(g)
        }, ce(S.inactiveText), 9, uS)) : W("v-if", !0)
      ], 2)) : W("v-if", !0),
      H("span", {
        ref_key: "core",
        ref: f,
        class: $(s(i).e("core")),
        style: ye(s(v))
      }, [
        S.inlinePrompt ? (E(), _("div", {
          key: 0,
          class: $(s(i).e("inner"))
        }, [
          S.activeIcon || S.inactiveIcon ? (E(), q(s(Se), {
            key: 0,
            class: $(s(i).is("icon"))
          }, {
            default: K(() => [
              (E(), q(Ge(s(g) ? S.activeIcon : S.inactiveIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : S.activeText || S.inactiveText ? (E(), _("span", {
            key: 1,
            class: $(s(i).is("text")),
            "aria-hidden": !s(g)
          }, ce(s(g) ? S.activeText : S.inactiveText), 11, cS)) : W("v-if", !0)
        ], 2)) : W("v-if", !0),
        H("div", {
          class: $(s(i).e("action"))
        }, [
          S.loading ? (E(), q(s(Se), {
            key: 0,
            class: $(s(i).is("loading"))
          }, {
            default: K(() => [
              x(s(wl))
            ]),
            _: 1
          }, 8, ["class"])) : W("v-if", !0)
        ], 2)
      ], 6),
      !S.inlinePrompt && (S.activeIcon || S.activeText) ? (E(), _("span", {
        key: 1,
        class: $([
          s(i).e("label"),
          s(i).em("label", "right"),
          s(i).is("active", s(g))
        ])
      }, [
        S.activeIcon ? (E(), q(s(Se), { key: 0 }, {
          default: K(() => [
            (E(), q(Ge(S.activeIcon)))
          ]),
          _: 1
        })) : W("v-if", !0),
        !S.activeIcon && S.activeText ? (E(), _("span", {
          key: 1,
          "aria-hidden": !s(g)
        }, ce(S.activeText), 9, dS)) : W("v-if", !0)
      ], 2)) : W("v-if", !0)
    ], 14, rS));
  }
});
var hS = /* @__PURE__ */ de(pS, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/switch/src/switch.vue"]]);
const vS = xe(hS);
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var mS = /["'&<>]/, gS = yS;
function yS(e) {
  var t = "" + e, n = mS.exec(t);
  if (!n)
    return t;
  var l, o = "", a = 0, r = 0;
  for (a = n.index; a < t.length; a++) {
    switch (t.charCodeAt(a)) {
      case 34:
        l = "&quot;";
        break;
      case 38:
        l = "&amp;";
        break;
      case 39:
        l = "&#39;";
        break;
      case 60:
        l = "&lt;";
        break;
      case 62:
        l = "&gt;";
        break;
      default:
        continue;
    }
    r !== a && (o += t.substring(r, a)), r = a + 1, o += l;
  }
  return r !== a ? o + t.substring(r, a) : o;
}
const cs = function(e) {
  var t;
  return (t = e.target) == null ? void 0 : t.closest("td");
}, bS = function(e, t, n, l, o) {
  if (!t && !l && (!o || Array.isArray(o) && !o.length))
    return e;
  typeof n == "string" ? n = n === "descending" ? -1 : 1 : n = n && n < 0 ? -1 : 1;
  const a = l ? null : function(i, u) {
    return o ? (Array.isArray(o) || (o = [o]), o.map((c) => typeof c == "string" ? Lt(i, c) : c(i, u, e))) : (t !== "$key" && Ct(i) && "$value" in i && (i = i.$value), [Ct(i) ? Lt(i, t) : i]);
  }, r = function(i, u) {
    if (l)
      return l(i.value, u.value);
    for (let c = 0, p = i.key.length; c < p; c++) {
      if (i.key[c] < u.key[c])
        return -1;
      if (i.key[c] > u.key[c])
        return 1;
    }
    return 0;
  };
  return e.map((i, u) => ({
    value: i,
    index: u,
    key: a ? a(i, u) : null
  })).sort((i, u) => {
    let c = r(i, u);
    return c || (c = i.index - u.index), c * +n;
  }).map((i) => i.value);
}, wc = function(e, t) {
  let n = null;
  return e.columns.forEach((l) => {
    l.id === t && (n = l);
  }), n;
}, CS = function(e, t) {
  let n = null;
  for (let l = 0; l < e.columns.length; l++) {
    const o = e.columns[l];
    if (o.columnKey === t) {
      n = o;
      break;
    }
  }
  return n || wt("ElTable", `No column matching with column-key: ${t}`), n;
}, Gr = function(e, t, n) {
  const l = (t.className || "").match(new RegExp(`${n}-table_[^\\s]+`, "gm"));
  return l ? wc(e, l[0]) : null;
}, Tt = (e, t) => {
  if (!e)
    throw new Error("Row is required when get row identity");
  if (typeof t == "string") {
    if (!t.includes("."))
      return `${e[t]}`;
    const n = t.split(".");
    let l = e;
    for (const o of n)
      l = l[o];
    return `${l}`;
  } else if (typeof t == "function")
    return t.call(null, e);
}, Hn = function(e, t) {
  const n = {};
  return (e || []).forEach((l, o) => {
    n[Tt(l, t)] = { row: l, index: o };
  }), n;
};
function wS(e, t) {
  const n = {};
  let l;
  for (l in e)
    n[l] = e[l];
  for (l in t)
    if (Bt(t, l)) {
      const o = t[l];
      typeof o < "u" && (n[l] = o);
    }
  return n;
}
function Aa(e) {
  return e === "" || e !== void 0 && (e = Number.parseInt(e, 10), Number.isNaN(e) && (e = "")), e;
}
function kc(e) {
  return e === "" || e !== void 0 && (e = Aa(e), Number.isNaN(e) && (e = 80)), e;
}
function kS(e) {
  return typeof e == "number" ? e : typeof e == "string" ? /^\d+(?:px)?$/.test(e) ? Number.parseInt(e, 10) : e : null;
}
function SS(...e) {
  return e.length === 0 ? (t) => t : e.length === 1 ? e[0] : e.reduce((t, n) => (...l) => t(n(...l)));
}
function Al(e, t, n) {
  let l = !1;
  const o = e.indexOf(t), a = o !== -1, r = (i) => {
    i === "add" ? e.push(t) : e.splice(o, 1), l = !0, Je(t.children) && t.children.forEach((u) => {
      Al(e, u, n != null ? n : !a);
    });
  };
  return Qt(n) ? n && !a ? r("add") : !n && a && r("remove") : r(a ? "remove" : "add"), l;
}
function ES(e, t, n = "children", l = "hasChildren") {
  const o = (r) => !(Array.isArray(r) && r.length);
  function a(r, i, u) {
    t(r, i, u), i.forEach((c) => {
      if (c[l]) {
        t(c, null, u + 1);
        return;
      }
      const p = c[n];
      o(p) || a(c, p, u + 1);
    });
  }
  e.forEach((r) => {
    if (r[l]) {
      t(r, null, 0);
      return;
    }
    const i = r[n];
    o(i) || a(r, i, 0);
  });
}
let vn;
function $S(e, t, n, l, o) {
  o = ji({
    enterable: !0,
    showArrow: !0
  }, o);
  const a = e == null ? void 0 : e.dataset.prefix, r = e == null ? void 0 : e.querySelector(`.${a}-scrollbar__wrap`);
  function i() {
    const g = o.effect === "light", w = document.createElement("div");
    return w.className = [
      `${a}-popper`,
      g ? "is-light" : "is-dark",
      o.popperClass || ""
    ].join(" "), n = gS(n), w.innerHTML = n, w.style.zIndex = String(l()), e == null || e.appendChild(w), w;
  }
  function u() {
    const g = document.createElement("div");
    return g.className = `${a}-popper__arrow`, g;
  }
  function c() {
    p && p.update();
  }
  vn == null || vn(), vn = () => {
    try {
      p && p.destroy(), h && (e == null || e.removeChild(h)), t.removeEventListener("mouseenter", d), t.removeEventListener("mouseleave", f), r == null || r.removeEventListener("scroll", vn), vn = void 0;
    } catch {
    }
  };
  let p = null, d = c, f = vn;
  o.enterable && ({ onOpen: d, onClose: f } = Ud({
    showAfter: o.showAfter,
    hideAfter: o.hideAfter,
    open: c,
    close: vn
  }));
  const h = i();
  h.onmouseenter = d, h.onmouseleave = f;
  const v = [];
  if (o.offset && v.push({
    name: "offset",
    options: {
      offset: [0, o.offset]
    }
  }), o.showArrow) {
    const g = h.appendChild(u());
    v.push({
      name: "arrow",
      options: {
        element: g,
        padding: 10
      }
    });
  }
  const m = o.popperOptions || {};
  return p = qd(t, h, {
    placement: o.placement || "top",
    strategy: "fixed",
    ...m,
    modifiers: m.modifiers ? v.concat(m.modifiers) : v
  }), t.addEventListener("mouseenter", d), t.addEventListener("mouseleave", f), r == null || r.addEventListener("scroll", vn), p;
}
function Sc(e) {
  return e.children ? Op(e.children, Sc) : [e];
}
function Yr(e, t) {
  return e + t.colSpan;
}
const Ec = (e, t, n, l) => {
  let o = 0, a = e;
  const r = n.states.columns.value;
  if (l) {
    const u = Sc(l[e]);
    o = r.slice(0, r.indexOf(u[0])).reduce(Yr, 0), a = o + u.reduce(Yr, 0) - 1;
  } else
    o = e;
  let i;
  switch (t) {
    case "left":
      a < n.states.fixedLeafColumnsLength.value && (i = "left");
      break;
    case "right":
      o >= r.length - n.states.rightFixedLeafColumnsLength.value && (i = "right");
      break;
    default:
      a < n.states.fixedLeafColumnsLength.value ? i = "left" : o >= r.length - n.states.rightFixedLeafColumnsLength.value && (i = "right");
  }
  return i ? {
    direction: i,
    start: o,
    after: a
  } : {};
}, _a = (e, t, n, l, o, a = 0) => {
  const r = [], { direction: i, start: u, after: c } = Ec(t, n, l, o);
  if (i) {
    const p = i === "left";
    r.push(`${e}-fixed-column--${i}`), p && c + a === l.states.fixedLeafColumnsLength.value - 1 ? r.push("is-last-column") : !p && u - a === l.states.columns.value.length - l.states.rightFixedLeafColumnsLength.value && r.push("is-first-column");
  }
  return r;
};
function Xr(e, t) {
  return e + (t.realWidth === null || Number.isNaN(t.realWidth) ? Number(t.width) : t.realWidth);
}
const La = (e, t, n, l) => {
  const {
    direction: o,
    start: a = 0,
    after: r = 0
  } = Ec(e, t, n, l);
  if (!o)
    return;
  const i = {}, u = o === "left", c = n.states.columns.value;
  return u ? i.left = c.slice(0, a).reduce(Xr, 0) : i.right = c.slice(r + 1).reverse().reduce(Xr, 0), i;
}, yl = (e, t) => {
  !e || Number.isNaN(e[t]) || (e[t] = `${e[t]}px`);
};
function TS(e) {
  const t = je(), n = N(!1), l = N([]);
  return {
    updateExpandRows: () => {
      const u = e.data.value || [], c = e.rowKey.value;
      if (n.value)
        l.value = u.slice();
      else if (c) {
        const p = Hn(l.value, c);
        l.value = u.reduce((d, f) => {
          const h = Tt(f, c);
          return p[h] && d.push(f), d;
        }, []);
      } else
        l.value = [];
    },
    toggleRowExpansion: (u, c) => {
      Al(l.value, u, c) && t.emit("expand-change", u, l.value.slice());
    },
    setExpandRowKeys: (u) => {
      t.store.assertRowKey();
      const c = e.data.value || [], p = e.rowKey.value, d = Hn(c, p);
      l.value = u.reduce((f, h) => {
        const v = d[h];
        return v && f.push(v.row), f;
      }, []);
    },
    isRowExpanded: (u) => {
      const c = e.rowKey.value;
      return c ? !!Hn(l.value, c)[Tt(u, c)] : l.value.includes(u);
    },
    states: {
      expandRows: l,
      defaultExpandAll: n
    }
  };
}
function NS(e) {
  const t = je(), n = N(null), l = N(null), o = (c) => {
    t.store.assertRowKey(), n.value = c, r(c);
  }, a = () => {
    n.value = null;
  }, r = (c) => {
    const { data: p, rowKey: d } = e;
    let f = null;
    d.value && (f = (s(p) || []).find((h) => Tt(h, d.value) === c)), l.value = f, t.emit("current-change", l.value, null);
  };
  return {
    setCurrentRowKey: o,
    restoreCurrentRowKey: a,
    setCurrentRowByKey: r,
    updateCurrentRow: (c) => {
      const p = l.value;
      if (c && c !== p) {
        l.value = c, t.emit("current-change", l.value, p);
        return;
      }
      !c && p && (l.value = null, t.emit("current-change", null, p));
    },
    updateCurrentRowData: () => {
      const c = e.rowKey.value, p = e.data.value || [], d = l.value;
      if (!p.includes(d) && d) {
        if (c) {
          const f = Tt(d, c);
          r(f);
        } else
          l.value = null;
        l.value === null && t.emit("current-change", null, d);
      } else
        n.value && (r(n.value), a());
    },
    states: {
      _currentRowKey: n,
      currentRow: l
    }
  };
}
function IS(e) {
  const t = N([]), n = N({}), l = N(16), o = N(!1), a = N({}), r = N("hasChildren"), i = N("children"), u = je(), c = k(() => {
    if (!e.rowKey.value)
      return {};
    const w = e.data.value || [];
    return d(w);
  }), p = k(() => {
    const w = e.rowKey.value, C = Object.keys(a.value), y = {};
    return C.length && C.forEach((b) => {
      if (a.value[b].length) {
        const S = { children: [] };
        a.value[b].forEach((T) => {
          const O = Tt(T, w);
          S.children.push(O), T[r.value] && !y[O] && (y[O] = { children: [] });
        }), y[b] = S;
      }
    }), y;
  }), d = (w) => {
    const C = e.rowKey.value, y = {};
    return ES(w, (b, S, T) => {
      const O = Tt(b, C);
      Array.isArray(S) ? y[O] = {
        children: S.map((I) => Tt(I, C)),
        level: T
      } : o.value && (y[O] = {
        children: [],
        lazy: !0,
        level: T
      });
    }, i.value, r.value), y;
  }, f = (w = !1, C = ((y) => (y = u.store) == null ? void 0 : y.states.defaultExpandAll.value)()) => {
    var y;
    const b = c.value, S = p.value, T = Object.keys(b), O = {};
    if (T.length) {
      const I = s(n), R = [], B = (A, z) => {
        if (w)
          return t.value ? C || t.value.includes(z) : !!(C || (A == null ? void 0 : A.expanded));
        {
          const Z = C || t.value && t.value.includes(z);
          return !!((A == null ? void 0 : A.expanded) || Z);
        }
      };
      T.forEach((A) => {
        const z = I[A], Z = { ...b[A] };
        if (Z.expanded = B(z, A), Z.lazy) {
          const { loaded: J = !1, loading: V = !1 } = z || {};
          Z.loaded = !!J, Z.loading = !!V, R.push(A);
        }
        O[A] = Z;
      });
      const D = Object.keys(S);
      o.value && D.length && R.length && D.forEach((A) => {
        const z = I[A], Z = S[A].children;
        if (R.includes(A)) {
          if (O[A].children.length !== 0)
            throw new Error("[ElTable]children must be an empty array.");
          O[A].children = Z;
        } else {
          const { loaded: J = !1, loading: V = !1 } = z || {};
          O[A] = {
            lazy: !0,
            loaded: !!J,
            loading: !!V,
            expanded: B(z, A),
            children: Z,
            level: ""
          };
        }
      });
    }
    n.value = O, (y = u.store) == null || y.updateTableScrollY();
  };
  ue(() => t.value, () => {
    f(!0);
  }), ue(() => c.value, () => {
    f();
  }), ue(() => p.value, () => {
    f();
  });
  const h = (w) => {
    t.value = w, f();
  }, v = (w, C) => {
    u.store.assertRowKey();
    const y = e.rowKey.value, b = Tt(w, y), S = b && n.value[b];
    if (b && S && "expanded" in S) {
      const T = S.expanded;
      C = typeof C > "u" ? !S.expanded : C, n.value[b].expanded = C, T !== C && u.emit("expand-change", w, C), u.store.updateTableScrollY();
    }
  }, m = (w) => {
    u.store.assertRowKey();
    const C = e.rowKey.value, y = Tt(w, C), b = n.value[y];
    o.value && b && "loaded" in b && !b.loaded ? g(w, y, b) : v(w, void 0);
  }, g = (w, C, y) => {
    const { load: b } = u.props;
    b && !n.value[C].loaded && (n.value[C].loading = !0, b(w, y, (S) => {
      if (!Array.isArray(S))
        throw new TypeError("[ElTable] data must be an array");
      n.value[C].loading = !1, n.value[C].loaded = !0, n.value[C].expanded = !0, S.length && (a.value[C] = S), u.emit("expand-change", w, !0);
    }));
  };
  return {
    loadData: g,
    loadOrToggle: m,
    toggleTreeExpansion: v,
    updateTreeExpandKeys: h,
    updateTreeData: f,
    normalize: d,
    states: {
      expandRowKeys: t,
      treeData: n,
      indent: l,
      lazy: o,
      lazyTreeNodeMap: a,
      lazyColumnIdentifier: r,
      childrenColumnName: i
    }
  };
}
const MS = (e, t) => {
  const n = t.sortingColumn;
  return !n || typeof n.sortable == "string" ? e : bS(e, t.sortProp, t.sortOrder, n.sortMethod, n.sortBy);
}, wo = (e) => {
  const t = [];
  return e.forEach((n) => {
    n.children ? t.push.apply(t, wo(n.children)) : t.push(n);
  }), t;
};
function RS() {
  var e;
  const t = je(), { size: n } = Ut((e = t.proxy) == null ? void 0 : e.$props), l = N(null), o = N([]), a = N([]), r = N(!1), i = N([]), u = N([]), c = N([]), p = N([]), d = N([]), f = N([]), h = N([]), v = N([]), m = [], g = N(0), w = N(0), C = N(0), y = N(!1), b = N([]), S = N(!1), T = N(!1), O = N(null), I = N({}), R = N(null), B = N(null), D = N(null), A = N(null), z = N(null);
  ue(o, () => t.state && M(!1), {
    deep: !0
  });
  const Z = () => {
    if (!l.value)
      throw new Error("[ElTable] prop row-key is required");
  }, J = (ke) => {
    var Y;
    (Y = ke.children) == null || Y.forEach((ae) => {
      ae.fixed = ke.fixed, J(ae);
    });
  }, V = () => {
    i.value.forEach((Me) => {
      J(Me);
    }), p.value = i.value.filter((Me) => Me.fixed === !0 || Me.fixed === "left"), d.value = i.value.filter((Me) => Me.fixed === "right"), p.value.length > 0 && i.value[0] && i.value[0].type === "selection" && !i.value[0].fixed && (i.value[0].fixed = !0, p.value.unshift(i.value[0]));
    const ke = i.value.filter((Me) => !Me.fixed);
    u.value = [].concat(p.value).concat(ke).concat(d.value);
    const Y = wo(ke), ae = wo(p.value), re = wo(d.value);
    g.value = Y.length, w.value = ae.length, C.value = re.length, c.value = [].concat(ae).concat(Y).concat(re), r.value = p.value.length > 0 || d.value.length > 0;
  }, M = (ke, Y = !1) => {
    ke && V(), Y ? t.state.doLayout() : t.state.debouncedUpdateLayout();
  }, P = (ke) => b.value.includes(ke), L = () => {
    y.value = !1, b.value.length && (b.value = [], t.emit("selection-change", []));
  }, U = () => {
    let ke;
    if (l.value) {
      ke = [];
      const Y = Hn(b.value, l.value), ae = Hn(o.value, l.value);
      for (const re in Y)
        Bt(Y, re) && !ae[re] && ke.push(Y[re].row);
    } else
      ke = b.value.filter((Y) => !o.value.includes(Y));
    if (ke.length) {
      const Y = b.value.filter((ae) => !ke.includes(ae));
      b.value = Y, t.emit("selection-change", Y.slice());
    }
  }, oe = () => (b.value || []).slice(), le = (ke, Y = void 0, ae = !0) => {
    if (Al(b.value, ke, Y)) {
      const Me = (b.value || []).slice();
      ae && t.emit("select", Me, ke), t.emit("selection-change", Me);
    }
  }, ee = () => {
    var ke, Y;
    const ae = T.value ? !y.value : !(y.value || b.value.length);
    y.value = ae;
    let re = !1, Me = 0;
    const Ze = (Y = (ke = t == null ? void 0 : t.store) == null ? void 0 : ke.states) == null ? void 0 : Y.rowKey.value;
    o.value.forEach((Qe, dt) => {
      const xt = dt + Me;
      O.value ? O.value.call(null, Qe, xt) && Al(b.value, Qe, ae) && (re = !0) : Al(b.value, Qe, ae) && (re = !0), Me += te(Tt(Qe, Ze));
    }), re && t.emit("selection-change", b.value ? b.value.slice() : []), t.emit("select-all", b.value);
  }, pe = () => {
    const ke = Hn(b.value, l.value);
    o.value.forEach((Y) => {
      const ae = Tt(Y, l.value), re = ke[ae];
      re && (b.value[re.index] = Y);
    });
  }, ge = () => {
    var ke, Y, ae;
    if (((ke = o.value) == null ? void 0 : ke.length) === 0) {
      y.value = !1;
      return;
    }
    let re;
    l.value && (re = Hn(b.value, l.value));
    const Me = function(xt) {
      return re ? !!re[Tt(xt, l.value)] : b.value.includes(xt);
    };
    let Ze = !0, Qe = 0, dt = 0;
    for (let xt = 0, _n = (o.value || []).length; xt < _n; xt++) {
      const Ft = (ae = (Y = t == null ? void 0 : t.store) == null ? void 0 : Y.states) == null ? void 0 : ae.rowKey.value, $l = xt + dt, pn = o.value[xt], hn = O.value && O.value.call(null, pn, $l);
      if (Me(pn))
        Qe++;
      else if (!O.value || hn) {
        Ze = !1;
        break;
      }
      dt += te(Tt(pn, Ft));
    }
    Qe === 0 && (Ze = !1), y.value = Ze;
  }, te = (ke) => {
    var Y;
    if (!t || !t.store)
      return 0;
    const { treeData: ae } = t.store.states;
    let re = 0;
    const Me = (Y = ae.value[ke]) == null ? void 0 : Y.children;
    return Me && (re += Me.length, Me.forEach((Ze) => {
      re += te(Ze);
    })), re;
  }, ve = (ke, Y) => {
    Array.isArray(ke) || (ke = [ke]);
    const ae = {};
    return ke.forEach((re) => {
      I.value[re.id] = Y, ae[re.columnKey || re.id] = Y;
    }), ae;
  }, G = (ke, Y, ae) => {
    B.value && B.value !== ke && (B.value.order = null), B.value = ke, D.value = Y, A.value = ae;
  }, Q = () => {
    let ke = s(a);
    Object.keys(I.value).forEach((Y) => {
      const ae = I.value[Y];
      if (!ae || ae.length === 0)
        return;
      const re = wc({
        columns: c.value
      }, Y);
      re && re.filterMethod && (ke = ke.filter((Me) => ae.some((Ze) => re.filterMethod.call(null, Ze, Me, re))));
    }), R.value = ke;
  }, ie = () => {
    o.value = MS(R.value, {
      sortingColumn: B.value,
      sortProp: D.value,
      sortOrder: A.value
    });
  }, Ee = (ke = void 0) => {
    ke && ke.filter || Q(), ie();
  }, De = (ke) => {
    const { tableHeaderRef: Y } = t.refs;
    if (!Y)
      return;
    const ae = Object.assign({}, Y.filterPanels), re = Object.keys(ae);
    if (!!re.length)
      if (typeof ke == "string" && (ke = [ke]), Array.isArray(ke)) {
        const Me = ke.map((Ze) => CS({
          columns: c.value
        }, Ze));
        re.forEach((Ze) => {
          const Qe = Me.find((dt) => dt.id === Ze);
          Qe && (Qe.filteredValue = []);
        }), t.store.commit("filterChange", {
          column: Me,
          values: [],
          silent: !0,
          multi: !0
        });
      } else
        re.forEach((Me) => {
          const Ze = c.value.find((Qe) => Qe.id === Me);
          Ze && (Ze.filteredValue = []);
        }), I.value = {}, t.store.commit("filterChange", {
          column: {},
          values: [],
          silent: !0
        });
  }, Ve = () => {
    !B.value || (G(null, null, null), t.store.commit("changeSortCondition", {
      silent: !0
    }));
  }, {
    setExpandRowKeys: Fe,
    toggleRowExpansion: ze,
    updateExpandRows: it,
    states: be,
    isRowExpanded: Te
  } = TS({
    data: o,
    rowKey: l
  }), {
    updateTreeExpandKeys: we,
    toggleTreeExpansion: _e,
    updateTreeData: Ie,
    loadOrToggle: Le,
    states: Ke
  } = IS({
    data: o,
    rowKey: l
  }), {
    updateCurrentRowData: Ye,
    updateCurrentRow: nt,
    setCurrentRowKey: gt,
    states: kt
  } = NS({
    data: o,
    rowKey: l
  });
  return {
    assertRowKey: Z,
    updateColumns: V,
    scheduleLayout: M,
    isSelected: P,
    clearSelection: L,
    cleanSelection: U,
    getSelectionRows: oe,
    toggleRowSelection: le,
    _toggleAllSelection: ee,
    toggleAllSelection: null,
    updateSelectionByRowKey: pe,
    updateAllSelected: ge,
    updateFilters: ve,
    updateCurrentRow: nt,
    updateSort: G,
    execFilter: Q,
    execSort: ie,
    execQuery: Ee,
    clearFilter: De,
    clearSort: Ve,
    toggleRowExpansion: ze,
    setExpandRowKeysAdapter: (ke) => {
      Fe(ke), we(ke);
    },
    setCurrentRowKey: gt,
    toggleRowExpansionAdapter: (ke, Y) => {
      c.value.some(({ type: re }) => re === "expand") ? ze(ke, Y) : _e(ke, Y);
    },
    isRowExpanded: Te,
    updateExpandRows: it,
    updateCurrentRowData: Ye,
    loadOrToggle: Le,
    updateTreeData: Ie,
    states: {
      tableSize: n,
      rowKey: l,
      data: o,
      _data: a,
      isComplex: r,
      _columns: i,
      originColumns: u,
      columns: c,
      fixedColumns: p,
      rightFixedColumns: d,
      leafColumns: f,
      fixedLeafColumns: h,
      rightFixedLeafColumns: v,
      updateOrderFns: m,
      leafColumnsLength: g,
      fixedLeafColumnsLength: w,
      rightFixedLeafColumnsLength: C,
      isAllSelected: y,
      selection: b,
      reserveSelection: S,
      selectOnIndeterminate: T,
      selectable: O,
      filters: I,
      filteredData: R,
      sortingColumn: B,
      sortProp: D,
      sortOrder: A,
      hoverRow: z,
      ...be,
      ...Ke,
      ...kt
    }
  };
}
function zs(e, t) {
  return e.map((n) => {
    var l;
    return n.id === t.id ? t : ((l = n.children) != null && l.length && (n.children = zs(n.children, t)), n);
  });
}
function Ks(e) {
  e.forEach((t) => {
    var n, l;
    t.no = (n = t.getColumnIndex) == null ? void 0 : n.call(t), (l = t.children) != null && l.length && Ks(t.children);
  }), e.sort((t, n) => t.no - n.no);
}
function OS() {
  const e = je(), t = RS();
  return {
    ns: se("table"),
    ...t,
    mutations: {
      setData(r, i) {
        const u = s(r._data) !== i;
        r.data.value = i, r._data.value = i, e.store.execQuery(), e.store.updateCurrentRowData(), e.store.updateExpandRows(), e.store.updateTreeData(e.store.states.defaultExpandAll.value), s(r.reserveSelection) ? (e.store.assertRowKey(), e.store.updateSelectionByRowKey()) : u ? e.store.clearSelection() : e.store.cleanSelection(), e.store.updateAllSelected(), e.$ready && e.store.scheduleLayout();
      },
      insertColumn(r, i, u, c) {
        const p = s(r._columns);
        let d = [];
        u ? (u && !u.children && (u.children = []), u.children.push(i), d = zs(p, u)) : (p.push(i), d = p), Ks(d), r._columns.value = d, r.updateOrderFns.push(c), i.type === "selection" && (r.selectable.value = i.selectable, r.reserveSelection.value = i.reserveSelection), e.$ready && (e.store.updateColumns(), e.store.scheduleLayout());
      },
      updateColumnOrder(r, i) {
        var u;
        ((u = i.getColumnIndex) == null ? void 0 : u.call(i)) !== i.no && (Ks(r._columns.value), e.$ready && e.store.updateColumns());
      },
      removeColumn(r, i, u, c) {
        const p = s(r._columns) || [];
        if (u)
          u.children.splice(u.children.findIndex((f) => f.id === i.id), 1), Ne(() => {
            var f;
            ((f = u.children) == null ? void 0 : f.length) === 0 && delete u.children;
          }), r._columns.value = zs(p, u);
        else {
          const f = p.indexOf(i);
          f > -1 && (p.splice(f, 1), r._columns.value = p);
        }
        const d = r.updateOrderFns.indexOf(c);
        d > -1 && r.updateOrderFns.splice(d, 1), e.$ready && (e.store.updateColumns(), e.store.scheduleLayout());
      },
      sort(r, i) {
        const { prop: u, order: c, init: p } = i;
        if (u) {
          const d = s(r.columns).find((f) => f.property === u);
          d && (d.order = c, e.store.updateSort(d, u, c), e.store.commit("changeSortCondition", { init: p }));
        }
      },
      changeSortCondition(r, i) {
        const { sortingColumn: u, sortProp: c, sortOrder: p } = r, d = s(u), f = s(c), h = s(p);
        h === null && (r.sortingColumn.value = null, r.sortProp.value = null);
        const v = { filter: !0 };
        e.store.execQuery(v), (!i || !(i.silent || i.init)) && e.emit("sort-change", {
          column: d,
          prop: f,
          order: h
        }), e.store.updateTableScrollY();
      },
      filterChange(r, i) {
        const { column: u, values: c, silent: p } = i, d = e.store.updateFilters(u, c);
        e.store.execQuery(), p || e.emit("filter-change", d), e.store.updateTableScrollY();
      },
      toggleAllSelection() {
        e.store.toggleAllSelection();
      },
      rowSelectedChanged(r, i) {
        e.store.toggleRowSelection(i), e.store.updateAllSelected();
      },
      setHoverRow(r, i) {
        r.hoverRow.value = i;
      },
      setCurrentRow(r, i) {
        e.store.updateCurrentRow(i);
      }
    },
    commit: function(r, ...i) {
      const u = e.store.mutations;
      if (u[r])
        u[r].apply(e, [e.store.states].concat(i));
      else
        throw new Error(`Action not found: ${r}`);
    },
    updateTableScrollY: function() {
      Ne(() => e.layout.updateScrollY.apply(e.layout));
    }
  };
}
const _l = {
  rowKey: "rowKey",
  defaultExpandAll: "defaultExpandAll",
  selectOnIndeterminate: "selectOnIndeterminate",
  indent: "indent",
  lazy: "lazy",
  data: "data",
  ["treeProps.hasChildren"]: {
    key: "lazyColumnIdentifier",
    default: "hasChildren"
  },
  ["treeProps.children"]: {
    key: "childrenColumnName",
    default: "children"
  }
};
function PS(e, t) {
  if (!e)
    throw new Error("Table is required.");
  const n = OS();
  return n.toggleAllSelection = Gt(n._toggleAllSelection, 10), Object.keys(_l).forEach((l) => {
    $c(Tc(t, l), l, n);
  }), AS(n, t), n;
}
function AS(e, t) {
  Object.keys(_l).forEach((n) => {
    ue(() => Tc(t, n), (l) => {
      $c(l, n, e);
    });
  });
}
function $c(e, t, n) {
  let l = e, o = _l[t];
  typeof _l[t] == "object" && (o = o.key, l = l || _l[t].default), n.states[o].value = l;
}
function Tc(e, t) {
  if (t.includes(".")) {
    const n = t.split(".");
    let l = e;
    return n.forEach((o) => {
      l = l[o];
    }), l;
  } else
    return e[t];
}
class _S {
  constructor(t) {
    this.observers = [], this.table = null, this.store = null, this.columns = [], this.fit = !0, this.showHeader = !0, this.height = N(null), this.scrollX = N(!1), this.scrollY = N(!1), this.bodyWidth = N(null), this.fixedWidth = N(null), this.rightFixedWidth = N(null), this.gutterWidth = 0;
    for (const n in t)
      Bt(t, n) && (Nn(this[n]) ? this[n].value = t[n] : this[n] = t[n]);
    if (!this.table)
      throw new Error("Table is required for Table Layout");
    if (!this.store)
      throw new Error("Store is required for Table Layout");
  }
  updateScrollY() {
    if (this.height.value === null)
      return !1;
    const n = this.table.refs.scrollBarRef;
    if (this.table.vnode.el && (n == null ? void 0 : n.wrapRef)) {
      let l = !0;
      const o = this.scrollY.value;
      return l = n.wrapRef.scrollHeight > n.wrapRef.clientHeight, this.scrollY.value = l, o !== l;
    }
    return !1;
  }
  setHeight(t, n = "height") {
    if (!rt)
      return;
    const l = this.table.vnode.el;
    if (t = kS(t), this.height.value = Number(t), !l && (t || t === 0))
      return Ne(() => this.setHeight(t, n));
    typeof t == "number" ? (l.style[n] = `${t}px`, this.updateElsHeight()) : typeof t == "string" && (l.style[n] = t, this.updateElsHeight());
  }
  setMaxHeight(t) {
    this.setHeight(t, "max-height");
  }
  getFlattenColumns() {
    const t = [];
    return this.table.store.states.columns.value.forEach((l) => {
      l.isColumnGroup ? t.push.apply(t, l.columns) : t.push(l);
    }), t;
  }
  updateElsHeight() {
    this.updateScrollY(), this.notifyObservers("scrollable");
  }
  headerDisplayNone(t) {
    if (!t)
      return !0;
    let n = t;
    for (; n.tagName !== "DIV"; ) {
      if (getComputedStyle(n).display === "none")
        return !0;
      n = n.parentElement;
    }
    return !1;
  }
  updateColumnsWidth() {
    if (!rt)
      return;
    const t = this.fit, n = this.table.vnode.el.clientWidth;
    let l = 0;
    const o = this.getFlattenColumns(), a = o.filter((u) => typeof u.width != "number");
    if (o.forEach((u) => {
      typeof u.width == "number" && u.realWidth && (u.realWidth = null);
    }), a.length > 0 && t) {
      if (o.forEach((u) => {
        l += Number(u.width || u.minWidth || 80);
      }), l <= n) {
        this.scrollX.value = !1;
        const u = n - l;
        if (a.length === 1)
          a[0].realWidth = Number(a[0].minWidth || 80) + u;
        else {
          const c = a.reduce((f, h) => f + Number(h.minWidth || 80), 0), p = u / c;
          let d = 0;
          a.forEach((f, h) => {
            if (h === 0)
              return;
            const v = Math.floor(Number(f.minWidth || 80) * p);
            d += v, f.realWidth = Number(f.minWidth || 80) + v;
          }), a[0].realWidth = Number(a[0].minWidth || 80) + u - d;
        }
      } else
        this.scrollX.value = !0, a.forEach((u) => {
          u.realWidth = Number(u.minWidth);
        });
      this.bodyWidth.value = Math.max(l, n), this.table.state.resizeState.value.width = this.bodyWidth.value;
    } else
      o.forEach((u) => {
        !u.width && !u.minWidth ? u.realWidth = 80 : u.realWidth = Number(u.width || u.minWidth), l += u.realWidth;
      }), this.scrollX.value = l > n, this.bodyWidth.value = l;
    const r = this.store.states.fixedColumns.value;
    if (r.length > 0) {
      let u = 0;
      r.forEach((c) => {
        u += Number(c.realWidth || c.width);
      }), this.fixedWidth.value = u;
    }
    const i = this.store.states.rightFixedColumns.value;
    if (i.length > 0) {
      let u = 0;
      i.forEach((c) => {
        u += Number(c.realWidth || c.width);
      }), this.rightFixedWidth.value = u;
    }
    this.notifyObservers("columns");
  }
  addObserver(t) {
    this.observers.push(t);
  }
  removeObserver(t) {
    const n = this.observers.indexOf(t);
    n !== -1 && this.observers.splice(n, 1);
  }
  notifyObservers(t) {
    this.observers.forEach((l) => {
      var o, a;
      switch (t) {
        case "columns":
          (o = l.state) == null || o.onColumnsChange(this);
          break;
        case "scrollable":
          (a = l.state) == null || a.onScrollableChange(this);
          break;
        default:
          throw new Error(`Table Layout don't have event ${t}.`);
      }
    });
  }
}
const { CheckboxGroup: LS } = Yt, VS = F({
  name: "ElTableFilterPanel",
  components: {
    ElCheckbox: Yt,
    ElCheckboxGroup: LS,
    ElScrollbar: Zn,
    ElTooltip: Wt,
    ElIcon: Se,
    ArrowDown: Zl,
    ArrowUp: Ti
  },
  directives: { ClickOutside: Wo },
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    },
    store: {
      type: Object
    },
    column: {
      type: Object
    },
    upDataColumn: {
      type: Function
    }
  },
  setup(e) {
    const t = je(), { t: n } = ot(), l = se("table-filter"), o = t == null ? void 0 : t.parent;
    o.filterPanels.value[e.column.id] || (o.filterPanels.value[e.column.id] = t);
    const a = N(!1), r = N(null), i = k(() => e.column && e.column.filters), u = k({
      get: () => {
        var b;
        return (((b = e.column) == null ? void 0 : b.filteredValue) || [])[0];
      },
      set: (b) => {
        c.value && (typeof b < "u" && b !== null ? c.value.splice(0, 1, b) : c.value.splice(0, 1));
      }
    }), c = k({
      get() {
        return e.column ? e.column.filteredValue || [] : [];
      },
      set(b) {
        e.column && e.upDataColumn("filteredValue", b);
      }
    }), p = k(() => e.column ? e.column.filterMultiple : !0), d = (b) => b.value === u.value, f = () => {
      a.value = !1;
    }, h = (b) => {
      b.stopPropagation(), a.value = !a.value;
    }, v = () => {
      a.value = !1;
    }, m = () => {
      C(c.value), f();
    }, g = () => {
      c.value = [], C(c.value), f();
    }, w = (b) => {
      u.value = b, C(typeof b < "u" && b !== null ? c.value : []), f();
    }, C = (b) => {
      e.store.commit("filterChange", {
        column: e.column,
        values: b
      }), e.store.updateAllSelected();
    };
    ue(a, (b) => {
      e.column && e.upDataColumn("filterOpened", b);
    }, {
      immediate: !0
    });
    const y = k(() => {
      var b, S;
      return (S = (b = r.value) == null ? void 0 : b.popperRef) == null ? void 0 : S.contentRef;
    });
    return {
      tooltipVisible: a,
      multiple: p,
      filteredValue: c,
      filterValue: u,
      filters: i,
      handleConfirm: m,
      handleReset: g,
      handleSelect: w,
      isActive: d,
      t: n,
      ns: l,
      showFilterPanel: h,
      hideFilterPanel: v,
      popperPaneRef: y,
      tooltip: r
    };
  }
}), BS = { key: 0 }, DS = ["disabled"], xS = ["label", "onClick"];
function FS(e, t, n, l, o, a) {
  const r = $e("el-checkbox"), i = $e("el-checkbox-group"), u = $e("el-scrollbar"), c = $e("arrow-up"), p = $e("arrow-down"), d = $e("el-icon"), f = $e("el-tooltip"), h = Oo("click-outside");
  return E(), q(f, {
    ref: "tooltip",
    visible: e.tooltipVisible,
    offset: 0,
    placement: e.placement,
    "show-arrow": !1,
    "stop-popper-mouse-event": !1,
    teleported: "",
    effect: "light",
    pure: "",
    "popper-class": e.ns.b(),
    persistent: ""
  }, {
    content: K(() => [
      e.multiple ? (E(), _("div", BS, [
        H("div", {
          class: $(e.ns.e("content"))
        }, [
          x(u, {
            "wrap-class": e.ns.e("wrap")
          }, {
            default: K(() => [
              x(i, {
                modelValue: e.filteredValue,
                "onUpdate:modelValue": t[0] || (t[0] = (v) => e.filteredValue = v),
                class: $(e.ns.e("checkbox-group"))
              }, {
                default: K(() => [
                  (E(!0), _(Re, null, Xe(e.filters, (v) => (E(), q(r, {
                    key: v.value,
                    label: v.value
                  }, {
                    default: K(() => [
                      st(ce(v.text), 1)
                    ]),
                    _: 2
                  }, 1032, ["label"]))), 128))
                ]),
                _: 1
              }, 8, ["modelValue", "class"])
            ]),
            _: 1
          }, 8, ["wrap-class"])
        ], 2),
        H("div", {
          class: $(e.ns.e("bottom"))
        }, [
          H("button", {
            class: $({ [e.ns.is("disabled")]: e.filteredValue.length === 0 }),
            disabled: e.filteredValue.length === 0,
            type: "button",
            onClick: t[1] || (t[1] = (...v) => e.handleConfirm && e.handleConfirm(...v))
          }, ce(e.t("el.table.confirmFilter")), 11, DS),
          H("button", {
            type: "button",
            onClick: t[2] || (t[2] = (...v) => e.handleReset && e.handleReset(...v))
          }, ce(e.t("el.table.resetFilter")), 1)
        ], 2)
      ])) : (E(), _("ul", {
        key: 1,
        class: $(e.ns.e("list"))
      }, [
        H("li", {
          class: $([
            e.ns.e("list-item"),
            {
              [e.ns.is("active")]: e.filterValue === void 0 || e.filterValue === null
            }
          ]),
          onClick: t[3] || (t[3] = (v) => e.handleSelect(null))
        }, ce(e.t("el.table.clearFilter")), 3),
        (E(!0), _(Re, null, Xe(e.filters, (v) => (E(), _("li", {
          key: v.value,
          class: $([e.ns.e("list-item"), e.ns.is("active", e.isActive(v))]),
          label: v.value,
          onClick: (m) => e.handleSelect(v.value)
        }, ce(v.text), 11, xS))), 128))
      ], 2))
    ]),
    default: K(() => [
      qe((E(), _("span", {
        class: $([
          `${e.ns.namespace.value}-table__column-filter-trigger`,
          `${e.ns.namespace.value}-none-outline`
        ]),
        onClick: t[4] || (t[4] = (...v) => e.showFilterPanel && e.showFilterPanel(...v))
      }, [
        x(d, null, {
          default: K(() => [
            e.column.filterOpened ? (E(), q(c, { key: 0 })) : (E(), q(p, { key: 1 }))
          ]),
          _: 1
        })
      ], 2)), [
        [h, e.hideFilterPanel, e.popperPaneRef]
      ])
    ]),
    _: 1
  }, 8, ["visible", "placement", "popper-class"]);
}
var HS = /* @__PURE__ */ de(VS, [["render", FS], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/filter-panel.vue"]]);
function Nc(e) {
  const t = je();
  Oi(() => {
    n.value.addObserver(t);
  }), We(() => {
    l(n.value), o(n.value);
  }), fa(() => {
    l(n.value), o(n.value);
  }), Jl(() => {
    n.value.removeObserver(t);
  });
  const n = k(() => {
    const a = e.layout;
    if (!a)
      throw new Error("Can not find table layout.");
    return a;
  }), l = (a) => {
    var r;
    const i = ((r = e.vnode.el) == null ? void 0 : r.querySelectorAll("colgroup > col")) || [];
    if (!i.length)
      return;
    const u = a.getFlattenColumns(), c = {};
    u.forEach((p) => {
      c[p.id] = p;
    });
    for (let p = 0, d = i.length; p < d; p++) {
      const f = i[p], h = f.getAttribute("name"), v = c[h];
      v && f.setAttribute("width", v.realWidth || v.width);
    }
  }, o = (a) => {
    var r, i;
    const u = ((r = e.vnode.el) == null ? void 0 : r.querySelectorAll("colgroup > col[name=gutter]")) || [];
    for (let p = 0, d = u.length; p < d; p++)
      u[p].setAttribute("width", a.scrollY.value ? a.gutterWidth : "0");
    const c = ((i = e.vnode.el) == null ? void 0 : i.querySelectorAll("th.gutter")) || [];
    for (let p = 0, d = c.length; p < d; p++) {
      const f = c[p];
      f.style.width = a.scrollY.value ? `${a.gutterWidth}px` : "0", f.style.display = a.scrollY.value ? "" : "none";
    }
  };
  return {
    tableLayout: n.value,
    onColumnsChange: l,
    onScrollableChange: o
  };
}
const fn = Symbol("ElTable");
function zS(e, t) {
  const n = je(), l = Oe(fn), o = (m) => {
    m.stopPropagation();
  }, a = (m, g) => {
    !g.filters && g.sortable ? v(m, g, !1) : g.filterable && !g.sortable && o(m), l == null || l.emit("header-click", g, m);
  }, r = (m, g) => {
    l == null || l.emit("header-contextmenu", g, m);
  }, i = N(null), u = N(!1), c = N({}), p = (m, g) => {
    if (!!rt && !(g.children && g.children.length > 0) && i.value && e.border) {
      u.value = !0;
      const w = l;
      t("set-drag-visible", !0);
      const y = (w == null ? void 0 : w.vnode.el).getBoundingClientRect().left, b = n.vnode.el.querySelector(`th.${g.id}`), S = b.getBoundingClientRect(), T = S.left - y + 30;
      yn(b, "noclick"), c.value = {
        startMouseLeft: m.clientX,
        startLeft: S.right - y,
        startColumnLeft: S.left - y,
        tableLeft: y
      };
      const O = w == null ? void 0 : w.refs.resizeProxy;
      O.style.left = `${c.value.startLeft}px`, document.onselectstart = function() {
        return !1;
      }, document.ondragstart = function() {
        return !1;
      };
      const I = (B) => {
        const D = B.clientX - c.value.startMouseLeft, A = c.value.startLeft + D;
        O.style.left = `${Math.max(T, A)}px`;
      }, R = () => {
        if (u.value) {
          const { startColumnLeft: B, startLeft: D } = c.value, z = Number.parseInt(O.style.left, 10) - B;
          g.width = g.realWidth = z, w == null || w.emit("header-dragend", g.width, D - B, g, m), requestAnimationFrame(() => {
            e.store.scheduleLayout(!1, !0);
          }), document.body.style.cursor = "", u.value = !1, i.value = null, c.value = {}, t("set-drag-visible", !1);
        }
        document.removeEventListener("mousemove", I), document.removeEventListener("mouseup", R), document.onselectstart = null, document.ondragstart = null, setTimeout(() => {
          zt(b, "noclick");
        }, 0);
      };
      document.addEventListener("mousemove", I), document.addEventListener("mouseup", R);
    }
  }, d = (m, g) => {
    var w;
    if (g.children && g.children.length > 0)
      return;
    const C = (w = m.target) == null ? void 0 : w.closest("th");
    if (!(!g || !g.resizable) && !u.value && e.border) {
      const y = C.getBoundingClientRect(), b = document.body.style;
      y.width > 12 && y.right - m.pageX < 8 ? (b.cursor = "col-resize", Kn(C, "is-sortable") && (C.style.cursor = "col-resize"), i.value = g) : u.value || (b.cursor = "", Kn(C, "is-sortable") && (C.style.cursor = "pointer"), i.value = null);
    }
  }, f = () => {
    !rt || (document.body.style.cursor = "");
  }, h = ({ order: m, sortOrders: g }) => {
    if (m === "")
      return g[0];
    const w = g.indexOf(m || null);
    return g[w > g.length - 2 ? 0 : w + 1];
  }, v = (m, g, w) => {
    var C;
    m.stopPropagation();
    const y = g.order === w ? null : w || h(g), b = (C = m.target) == null ? void 0 : C.closest("th");
    if (b && Kn(b, "noclick")) {
      zt(b, "noclick");
      return;
    }
    if (!g.sortable)
      return;
    const S = e.store.states;
    let T = S.sortProp.value, O;
    const I = S.sortingColumn.value;
    (I !== g || I === g && I.order === null) && (I && (I.order = null), S.sortingColumn.value = g, T = g.property), y ? O = g.order = y : O = g.order = null, S.sortProp.value = T, S.sortOrder.value = O, l == null || l.store.commit("changeSortCondition");
  };
  return {
    handleHeaderClick: a,
    handleHeaderContextMenu: r,
    handleMouseDown: p,
    handleMouseMove: d,
    handleMouseOut: f,
    handleSortClick: v,
    handleFilterClick: o
  };
}
function KS(e) {
  const t = Oe(fn), n = se("table");
  return {
    getHeaderRowStyle: (i) => {
      const u = t == null ? void 0 : t.props.headerRowStyle;
      return typeof u == "function" ? u.call(null, { rowIndex: i }) : u;
    },
    getHeaderRowClass: (i) => {
      const u = [], c = t == null ? void 0 : t.props.headerRowClassName;
      return typeof c == "string" ? u.push(c) : typeof c == "function" && u.push(c.call(null, { rowIndex: i })), u.join(" ");
    },
    getHeaderCellStyle: (i, u, c, p) => {
      var d;
      let f = (d = t == null ? void 0 : t.props.headerCellStyle) != null ? d : {};
      typeof f == "function" && (f = f.call(null, {
        rowIndex: i,
        columnIndex: u,
        row: c,
        column: p
      }));
      const h = La(u, p.fixed, e.store, c);
      return yl(h, "left"), yl(h, "right"), Object.assign({}, f, h);
    },
    getHeaderCellClass: (i, u, c, p) => {
      const d = _a(n.b(), u, p.fixed, e.store, c), f = [
        p.id,
        p.order,
        p.headerAlign,
        p.className,
        p.labelClassName,
        ...d
      ];
      p.children || f.push("is-leaf"), p.sortable && f.push("is-sortable");
      const h = t == null ? void 0 : t.props.headerCellClassName;
      return typeof h == "string" ? f.push(h) : typeof h == "function" && f.push(h.call(null, {
        rowIndex: i,
        columnIndex: u,
        row: c,
        column: p
      })), f.push(n.e("cell")), f.filter((v) => Boolean(v)).join(" ");
    }
  };
}
const Ic = (e) => {
  const t = [];
  return e.forEach((n) => {
    n.children ? (t.push(n), t.push.apply(t, Ic(n.children))) : t.push(n);
  }), t;
}, WS = (e) => {
  let t = 1;
  const n = (a, r) => {
    if (r && (a.level = r.level + 1, t < a.level && (t = a.level)), a.children) {
      let i = 0;
      a.children.forEach((u) => {
        n(u, a), i += u.colSpan;
      }), a.colSpan = i;
    } else
      a.colSpan = 1;
  };
  e.forEach((a) => {
    a.level = 1, n(a, void 0);
  });
  const l = [];
  for (let a = 0; a < t; a++)
    l.push([]);
  return Ic(e).forEach((a) => {
    a.children ? (a.rowSpan = 1, a.children.forEach((r) => r.isSubColumn = !0)) : a.rowSpan = t - a.level + 1, l[a.level - 1].push(a);
  }), l;
};
function jS(e) {
  const t = Oe(fn), n = k(() => WS(e.store.states.originColumns.value));
  return {
    isGroup: k(() => {
      const a = n.value.length > 1;
      return a && t && (t.state.isGroup.value = !0), a;
    }),
    toggleAllSelection: (a) => {
      a.stopPropagation(), t == null || t.store.commit("toggleAllSelection");
    },
    columnRows: n
  };
}
var US = F({
  name: "ElTableHeader",
  components: {
    ElCheckbox: Yt
  },
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    }
  },
  setup(e, { emit: t }) {
    const n = je(), l = Oe(fn), o = se("table"), a = N({}), { onColumnsChange: r, onScrollableChange: i } = Nc(l);
    We(async () => {
      await Ne(), await Ne();
      const { prop: T, order: O } = e.defaultSort;
      l == null || l.store.commit("sort", { prop: T, order: O, init: !0 });
    });
    const {
      handleHeaderClick: u,
      handleHeaderContextMenu: c,
      handleMouseDown: p,
      handleMouseMove: d,
      handleMouseOut: f,
      handleSortClick: h,
      handleFilterClick: v
    } = zS(e, t), {
      getHeaderRowStyle: m,
      getHeaderRowClass: g,
      getHeaderCellStyle: w,
      getHeaderCellClass: C
    } = KS(e), { isGroup: y, toggleAllSelection: b, columnRows: S } = jS(e);
    return n.state = {
      onColumnsChange: r,
      onScrollableChange: i
    }, n.filterPanels = a, {
      ns: o,
      filterPanels: a,
      onColumnsChange: r,
      onScrollableChange: i,
      columnRows: S,
      getHeaderRowClass: g,
      getHeaderRowStyle: m,
      getHeaderCellClass: C,
      getHeaderCellStyle: w,
      handleHeaderClick: u,
      handleHeaderContextMenu: c,
      handleMouseDown: p,
      handleMouseMove: d,
      handleMouseOut: f,
      handleSortClick: h,
      handleFilterClick: v,
      isGroup: y,
      toggleAllSelection: b
    };
  },
  render() {
    const {
      ns: e,
      isGroup: t,
      columnRows: n,
      getHeaderCellStyle: l,
      getHeaderCellClass: o,
      getHeaderRowClass: a,
      getHeaderRowStyle: r,
      handleHeaderClick: i,
      handleHeaderContextMenu: u,
      handleMouseDown: c,
      handleMouseMove: p,
      handleSortClick: d,
      handleMouseOut: f,
      store: h,
      $parent: v
    } = this;
    let m = 1;
    return fe("thead", {
      class: { [e.is("group")]: t }
    }, n.map((g, w) => fe("tr", {
      class: a(w),
      key: w,
      style: r(w)
    }, g.map((C, y) => (C.rowSpan > m && (m = C.rowSpan), fe("th", {
      class: o(w, y, g, C),
      colspan: C.colSpan,
      key: `${C.id}-thead`,
      rowspan: C.rowSpan,
      style: l(w, y, g, C),
      onClick: (b) => i(b, C),
      onContextmenu: (b) => u(b, C),
      onMousedown: (b) => c(b, C),
      onMousemove: (b) => p(b, C),
      onMouseout: f
    }, [
      fe("div", {
        class: [
          "cell",
          C.filteredValue && C.filteredValue.length > 0 ? "highlight" : ""
        ]
      }, [
        C.renderHeader ? C.renderHeader({
          column: C,
          $index: y,
          store: h,
          _self: v
        }) : C.label,
        C.sortable && fe("span", {
          onClick: (b) => d(b, C),
          class: "caret-wrapper"
        }, [
          fe("i", {
            onClick: (b) => d(b, C, "ascending"),
            class: "sort-caret ascending"
          }),
          fe("i", {
            onClick: (b) => d(b, C, "descending"),
            class: "sort-caret descending"
          })
        ]),
        C.filterable && fe(HS, {
          store: h,
          placement: C.filterPlacement || "bottom-start",
          column: C,
          upDataColumn: (b, S) => {
            C[b] = S;
          }
        })
      ])
    ]))))));
  }
});
function qS(e) {
  const t = Oe(fn), n = N(""), l = N(fe("div")), { nextZIndex: o } = Uo(), a = (h, v, m) => {
    var g;
    const w = t, C = cs(h);
    let y;
    const b = (g = w == null ? void 0 : w.vnode.el) == null ? void 0 : g.dataset.prefix;
    C && (y = Gr({
      columns: e.store.states.columns.value
    }, C, b), y && (w == null || w.emit(`cell-${m}`, v, y, C, h))), w == null || w.emit(`row-${m}`, v, y, h);
  }, r = (h, v) => {
    a(h, v, "dblclick");
  }, i = (h, v) => {
    e.store.commit("setCurrentRow", v), a(h, v, "click");
  }, u = (h, v) => {
    a(h, v, "contextmenu");
  }, c = Gt((h) => {
    e.store.commit("setHoverRow", h);
  }, 30), p = Gt(() => {
    e.store.commit("setHoverRow", null);
  }, 30);
  return {
    handleDoubleClick: r,
    handleClick: i,
    handleContextMenu: u,
    handleMouseEnter: c,
    handleMouseLeave: p,
    handleCellMouseEnter: (h, v, m) => {
      var g;
      const w = t, C = cs(h), y = (g = w == null ? void 0 : w.vnode.el) == null ? void 0 : g.dataset.prefix;
      if (C) {
        const I = Gr({
          columns: e.store.states.columns.value
        }, C, y), R = w.hoverState = { cell: C, column: I, row: v };
        w == null || w.emit("cell-mouse-enter", R.row, R.column, R.cell, h);
      }
      if (!m)
        return;
      const b = h.target.querySelector(".cell");
      if (!(Kn(b, `${y}-tooltip`) && b.childNodes.length))
        return;
      const S = document.createRange();
      S.setStart(b, 0), S.setEnd(b, b.childNodes.length);
      const T = Math.round(S.getBoundingClientRect().width), O = (Number.parseInt(Vn(b, "paddingLeft"), 10) || 0) + (Number.parseInt(Vn(b, "paddingRight"), 10) || 0);
      (T + O > b.offsetWidth || b.scrollWidth > b.offsetWidth) && $S(t == null ? void 0 : t.refs.tableWrapper, C, C.innerText || C.textContent, o, m);
    },
    handleCellMouseLeave: (h) => {
      if (!cs(h))
        return;
      const m = t == null ? void 0 : t.hoverState;
      t == null || t.emit("cell-mouse-leave", m == null ? void 0 : m.row, m == null ? void 0 : m.column, m == null ? void 0 : m.cell, h);
    },
    tooltipContent: n,
    tooltipTrigger: l
  };
}
function GS(e) {
  const t = Oe(fn), n = se("table");
  return {
    getRowStyle: (c, p) => {
      const d = t == null ? void 0 : t.props.rowStyle;
      return typeof d == "function" ? d.call(null, {
        row: c,
        rowIndex: p
      }) : d || null;
    },
    getRowClass: (c, p) => {
      const d = [n.e("row")];
      (t == null ? void 0 : t.props.highlightCurrentRow) && c === e.store.states.currentRow.value && d.push("current-row"), e.stripe && p % 2 === 1 && d.push(n.em("row", "striped"));
      const f = t == null ? void 0 : t.props.rowClassName;
      return typeof f == "string" ? d.push(f) : typeof f == "function" && d.push(f.call(null, {
        row: c,
        rowIndex: p
      })), d;
    },
    getCellStyle: (c, p, d, f) => {
      const h = t == null ? void 0 : t.props.cellStyle;
      let v = h != null ? h : {};
      typeof h == "function" && (v = h.call(null, {
        rowIndex: c,
        columnIndex: p,
        row: d,
        column: f
      }));
      const m = La(p, e == null ? void 0 : e.fixed, e.store);
      return yl(m, "left"), yl(m, "right"), Object.assign({}, v, m);
    },
    getCellClass: (c, p, d, f, h) => {
      const v = _a(n.b(), p, e == null ? void 0 : e.fixed, e.store, void 0, h), m = [f.id, f.align, f.className, ...v], g = t == null ? void 0 : t.props.cellClassName;
      return typeof g == "string" ? m.push(g) : typeof g == "function" && m.push(g.call(null, {
        rowIndex: c,
        columnIndex: p,
        row: d,
        column: f
      })), m.push(n.e("cell")), m.filter((w) => Boolean(w)).join(" ");
    },
    getSpan: (c, p, d, f) => {
      let h = 1, v = 1;
      const m = t == null ? void 0 : t.props.spanMethod;
      if (typeof m == "function") {
        const g = m({
          row: c,
          column: p,
          rowIndex: d,
          columnIndex: f
        });
        Array.isArray(g) ? (h = g[0], v = g[1]) : typeof g == "object" && (h = g.rowspan, v = g.colspan);
      }
      return { rowspan: h, colspan: v };
    },
    getColspanRealWidth: (c, p, d) => {
      if (p < 1)
        return c[d].realWidth;
      const f = c.map(({ realWidth: h, width: v }) => h || v).slice(d, d + p);
      return Number(f.reduce((h, v) => Number(h) + Number(v), -1));
    }
  };
}
function YS(e) {
  const t = Oe(fn), n = se("table"), {
    handleDoubleClick: l,
    handleClick: o,
    handleContextMenu: a,
    handleMouseEnter: r,
    handleMouseLeave: i,
    handleCellMouseEnter: u,
    handleCellMouseLeave: c,
    tooltipContent: p,
    tooltipTrigger: d
  } = qS(e), {
    getRowStyle: f,
    getRowClass: h,
    getCellStyle: v,
    getCellClass: m,
    getSpan: g,
    getColspanRealWidth: w
  } = GS(e), C = k(() => e.store.states.columns.value.findIndex(({ type: O }) => O === "default")), y = (O, I) => {
    const R = t.props.rowKey;
    return R ? Tt(O, R) : I;
  }, b = (O, I, R, B = !1) => {
    const { tooltipEffect: D, tooltipOptions: A, store: z } = e, { indent: Z, columns: J } = z.states, V = h(O, I);
    let M = !0;
    return R && (V.push(n.em("row", `level-${R.level}`)), M = R.display), fe("tr", {
      style: [M ? null : {
        display: "none"
      }, f(O, I)],
      class: V,
      key: y(O, I),
      onDblclick: (L) => l(L, O),
      onClick: (L) => o(L, O),
      onContextmenu: (L) => a(L, O),
      onMouseenter: () => r(I),
      onMouseleave: i
    }, J.value.map((L, U) => {
      const { rowspan: oe, colspan: le } = g(O, L, I, U);
      if (!oe || !le)
        return null;
      const ee = { ...L };
      ee.realWidth = w(J.value, le, U);
      const pe = {
        store: e.store,
        _self: e.context || t,
        column: ee,
        row: O,
        $index: I,
        cellIndex: U,
        expanded: B
      };
      U === C.value && R && (pe.treeNode = {
        indent: R.level * Z.value,
        level: R.level
      }, typeof R.expanded == "boolean" && (pe.treeNode.expanded = R.expanded, "loading" in R && (pe.treeNode.loading = R.loading), "noLazyChildren" in R && (pe.treeNode.noLazyChildren = R.noLazyChildren)));
      const ge = `${I},${U}`, te = ee.columnKey || ee.rawColumnKey || "", ve = S(U, L, pe), G = L.showOverflowTooltip && ji({
        effect: D
      }, A, L.showOverflowTooltip);
      return fe("td", {
        style: v(I, U, O, L),
        class: m(I, U, O, L, le - 1),
        key: `${te}${ge}`,
        rowspan: oe,
        colspan: le,
        onMouseenter: (Q) => u(Q, O, G),
        onMouseleave: c
      }, [ve]);
    }));
  }, S = (O, I, R) => I.renderCell(R);
  return {
    wrappedRowRender: (O, I) => {
      const R = e.store, { isRowExpanded: B, assertRowKey: D } = R, { treeData: A, lazyTreeNodeMap: z, childrenColumnName: Z, rowKey: J } = R.states, V = R.states.columns.value;
      if (V.some(({ type: P }) => P === "expand")) {
        const P = B(O), L = b(O, I, void 0, P), U = t.renderExpanded;
        return P ? U ? [
          [
            L,
            fe("tr", {
              key: `expanded-row__${L.key}`
            }, [
              fe("td", {
                colspan: V.length,
                class: `${n.e("cell")} ${n.e("expanded-cell")}`
              }, [U({ row: O, $index: I, store: R, expanded: P })])
            ])
          ]
        ] : (console.error("[Element Error]renderExpanded is required."), L) : [[L]];
      } else if (Object.keys(A.value).length) {
        D();
        const P = Tt(O, J.value);
        let L = A.value[P], U = null;
        L && (U = {
          expanded: L.expanded,
          level: L.level,
          display: !0
        }, typeof L.lazy == "boolean" && (typeof L.loaded == "boolean" && L.loaded && (U.noLazyChildren = !(L.children && L.children.length)), U.loading = L.loading));
        const oe = [b(O, I, U)];
        if (L) {
          let le = 0;
          const ee = (ge, te) => {
            !(ge && ge.length && te) || ge.forEach((ve) => {
              const G = {
                display: te.display && te.expanded,
                level: te.level + 1,
                expanded: !1,
                noLazyChildren: !1,
                loading: !1
              }, Q = Tt(ve, J.value);
              if (Q == null)
                throw new Error("For nested data item, row-key is required.");
              if (L = { ...A.value[Q] }, L && (G.expanded = L.expanded, L.level = L.level || G.level, L.display = !!(L.expanded && G.display), typeof L.lazy == "boolean" && (typeof L.loaded == "boolean" && L.loaded && (G.noLazyChildren = !(L.children && L.children.length)), G.loading = L.loading)), le++, oe.push(b(ve, I + le, G)), L) {
                const ie = z.value[Q] || ve[Z.value];
                ee(ie, L);
              }
            });
          };
          L.display = !0;
          const pe = z.value[P] || O[Z.value];
          ee(pe, L);
        }
        return oe;
      } else
        return b(O, I, void 0);
    },
    tooltipContent: p,
    tooltipTrigger: d
  };
}
const XS = {
  store: {
    required: !0,
    type: Object
  },
  stripe: Boolean,
  tooltipEffect: String,
  tooltipOptions: {
    type: Object
  },
  context: {
    default: () => ({}),
    type: Object
  },
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  fixed: {
    type: String,
    default: ""
  },
  highlight: Boolean
};
var ZS = F({
  name: "ElTableBody",
  props: XS,
  setup(e) {
    const t = je(), n = Oe(fn), l = se("table"), { wrappedRowRender: o, tooltipContent: a, tooltipTrigger: r } = YS(e), { onColumnsChange: i, onScrollableChange: u } = Nc(n);
    return ue(e.store.states.hoverRow, (c, p) => {
      if (!e.store.states.isComplex.value || !rt)
        return;
      let d = window.requestAnimationFrame;
      d || (d = (f) => window.setTimeout(f, 16)), d(() => {
        const f = t == null ? void 0 : t.vnode.el, h = Array.from((f == null ? void 0 : f.children) || []).filter((g) => g == null ? void 0 : g.classList.contains(`${l.e("row")}`)), v = h[p], m = h[c];
        v && zt(v, "hover-row"), m && yn(m, "hover-row");
      });
    }), Jl(() => {
      var c;
      (c = vn) == null || c();
    }), {
      ns: l,
      onColumnsChange: i,
      onScrollableChange: u,
      wrappedRowRender: o,
      tooltipContent: a,
      tooltipTrigger: r
    };
  },
  render() {
    const { wrappedRowRender: e, store: t } = this, n = t.states.data.value || [];
    return fe("tbody", {}, [
      n.reduce((l, o) => l.concat(e(o, l.length)), [])
    ]);
  }
});
function Va(e) {
  const t = e.tableLayout === "auto";
  let n = e.columns || [];
  t && n.every((o) => o.width === void 0) && (n = []);
  const l = (o) => {
    const a = {
      key: `${e.tableLayout}_${o.id}`,
      style: {},
      name: void 0
    };
    return t ? a.style = {
      width: `${o.width}px`
    } : a.name = o.id, a;
  };
  return fe("colgroup", {}, n.map((o) => fe("col", l(o))));
}
Va.props = ["columns", "tableLayout"];
function JS() {
  const e = Oe(fn), t = e == null ? void 0 : e.store, n = k(() => t.states.fixedLeafColumnsLength.value), l = k(() => t.states.rightFixedColumns.value.length), o = k(() => t.states.columns.value.length), a = k(() => t.states.fixedColumns.value.length), r = k(() => t.states.rightFixedColumns.value.length);
  return {
    leftFixedLeafCount: n,
    rightFixedLeafCount: l,
    columnsCount: o,
    leftFixedCount: a,
    rightFixedCount: r,
    columns: t.states.columns
  };
}
function QS(e) {
  const { columns: t } = JS(), n = se("table");
  return {
    getCellClasses: (a, r) => {
      const i = a[r], u = [
        n.e("cell"),
        i.id,
        i.align,
        i.labelClassName,
        ..._a(n.b(), r, i.fixed, e.store)
      ];
      return i.className && u.push(i.className), i.children || u.push(n.is("leaf")), u;
    },
    getCellStyles: (a, r) => {
      const i = La(r, a.fixed, e.store);
      return yl(i, "left"), yl(i, "right"), i;
    },
    columns: t
  };
}
var eE = F({
  name: "ElTableFooter",
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    }
  },
  setup(e) {
    const { getCellClasses: t, getCellStyles: n, columns: l } = QS(e);
    return {
      ns: se("table"),
      getCellClasses: t,
      getCellStyles: n,
      columns: l
    };
  },
  render() {
    const {
      columns: e,
      getCellStyles: t,
      getCellClasses: n,
      summaryMethod: l,
      sumText: o,
      ns: a
    } = this, r = this.store.states.data.value;
    let i = [];
    return l ? i = l({
      columns: e,
      data: r
    }) : e.forEach((u, c) => {
      if (c === 0) {
        i[c] = o;
        return;
      }
      const p = r.map((v) => Number(v[u.property])), d = [];
      let f = !0;
      p.forEach((v) => {
        if (!Number.isNaN(+v)) {
          f = !1;
          const m = `${v}`.split(".")[1];
          d.push(m ? m.length : 0);
        }
      });
      const h = Math.max.apply(null, d);
      f ? i[c] = "" : i[c] = p.reduce((v, m) => {
        const g = Number(m);
        return Number.isNaN(+g) ? v : Number.parseFloat((v + m).toFixed(Math.min(h, 20)));
      }, 0);
    }), fe("table", {
      class: a.e("footer"),
      cellspacing: "0",
      cellpadding: "0",
      border: "0"
    }, [
      Va({
        columns: e
      }),
      fe("tbody", [
        fe("tr", {}, [
          ...e.map((u, c) => fe("td", {
            key: c,
            colspan: u.colSpan,
            rowspan: u.rowSpan,
            class: n(e, c),
            style: t(u, c)
          }, [
            fe("div", {
              class: ["cell", u.labelClassName]
            }, [i[c]])
          ]))
        ])
      ])
    ]);
  }
});
function tE(e) {
  return {
    setCurrentRow: (p) => {
      e.commit("setCurrentRow", p);
    },
    getSelectionRows: () => e.getSelectionRows(),
    toggleRowSelection: (p, d) => {
      e.toggleRowSelection(p, d, !1), e.updateAllSelected();
    },
    clearSelection: () => {
      e.clearSelection();
    },
    clearFilter: (p) => {
      e.clearFilter(p);
    },
    toggleAllSelection: () => {
      e.commit("toggleAllSelection");
    },
    toggleRowExpansion: (p, d) => {
      e.toggleRowExpansionAdapter(p, d);
    },
    clearSort: () => {
      e.clearSort();
    },
    sort: (p, d) => {
      e.commit("sort", { prop: p, order: d });
    }
  };
}
function nE(e, t, n, l) {
  const o = N(!1), a = N(null), r = N(!1), i = (P) => {
    r.value = P;
  }, u = N({
    width: null,
    height: null,
    headerHeight: null
  }), c = N(!1), p = {
    display: "inline-block",
    verticalAlign: "middle"
  }, d = N(), f = N(0), h = N(0), v = N(0), m = N(0);
  en(() => {
    t.setHeight(e.height);
  }), en(() => {
    t.setMaxHeight(e.maxHeight);
  }), ue(() => [e.currentRowKey, n.states.rowKey], ([P, L]) => {
    !s(L) || !s(P) || n.setCurrentRowKey(`${P}`);
  }, {
    immediate: !0
  }), ue(() => e.data, (P) => {
    l.store.commit("setData", P);
  }, {
    immediate: !0,
    deep: !0
  }), en(() => {
    e.expandRowKeys && n.setExpandRowKeysAdapter(e.expandRowKeys);
  });
  const g = () => {
    l.store.commit("setHoverRow", null), l.hoverState && (l.hoverState = null);
  }, w = (P, L) => {
    const { pixelX: U, pixelY: oe } = L;
    Math.abs(U) >= Math.abs(oe) && (l.refs.bodyWrapper.scrollLeft += L.pixelX / 5);
  }, C = k(() => e.height || e.maxHeight || n.states.fixedColumns.value.length > 0 || n.states.rightFixedColumns.value.length > 0), y = k(() => ({
    width: t.bodyWidth.value ? `${t.bodyWidth.value}px` : ""
  })), b = () => {
    C.value && t.updateElsHeight(), t.updateColumnsWidth(), requestAnimationFrame(I);
  };
  We(async () => {
    await Ne(), n.updateColumns(), R(), requestAnimationFrame(b);
    const P = l.vnode.el, L = l.refs.headerWrapper;
    e.flexible && P && P.parentElement && (P.parentElement.style.minWidth = "0"), u.value = {
      width: d.value = P.offsetWidth,
      height: P.offsetHeight,
      headerHeight: e.showHeader && L ? L.offsetHeight : null
    }, n.states.columns.value.forEach((U) => {
      U.filteredValue && U.filteredValue.length && l.store.commit("filterChange", {
        column: U,
        values: U.filteredValue,
        silent: !0
      });
    }), l.$ready = !0;
  });
  const S = (P, L) => {
    if (!P)
      return;
    const U = Array.from(P.classList).filter((oe) => !oe.startsWith("is-scrolling-"));
    U.push(t.scrollX.value ? L : "is-scrolling-none"), P.className = U.join(" ");
  }, T = (P) => {
    const { tableWrapper: L } = l.refs;
    S(L, P);
  }, O = (P) => {
    const { tableWrapper: L } = l.refs;
    return !!(L && L.classList.contains(P));
  }, I = function() {
    if (!l.refs.scrollBarRef)
      return;
    if (!t.scrollX.value) {
      const ge = "is-scrolling-none";
      O(ge) || T(ge);
      return;
    }
    const P = l.refs.scrollBarRef.wrapRef;
    if (!P)
      return;
    const { scrollLeft: L, offsetWidth: U, scrollWidth: oe } = P, { headerWrapper: le, footerWrapper: ee } = l.refs;
    le && (le.scrollLeft = L), ee && (ee.scrollLeft = L);
    const pe = oe - U - 1;
    L >= pe ? T("is-scrolling-right") : T(L === 0 ? "is-scrolling-left" : "is-scrolling-middle");
  }, R = () => {
    !l.refs.scrollBarRef || (l.refs.scrollBarRef.wrapRef && Nt(l.refs.scrollBarRef.wrapRef, "scroll", I, {
      passive: !0
    }), e.fit ? Mn(l.vnode.el, B) : Nt(window, "resize", B), Mn(l.refs.bodyWrapper, () => {
      var P, L;
      B(), (L = (P = l.refs) == null ? void 0 : P.scrollBarRef) == null || L.update();
    }));
  }, B = () => {
    var P, L, U;
    const oe = l.vnode.el;
    if (!l.$ready || !oe)
      return;
    let le = !1;
    const {
      width: ee,
      height: pe,
      headerHeight: ge
    } = u.value, te = d.value = oe.offsetWidth;
    ee !== te && (le = !0);
    const ve = oe.offsetHeight;
    (e.height || C.value) && pe !== ve && (le = !0);
    const G = e.tableLayout === "fixed" ? l.refs.headerWrapper : (P = l.refs.tableHeaderRef) == null ? void 0 : P.$el;
    e.showHeader && (G == null ? void 0 : G.offsetHeight) !== ge && (le = !0), f.value = ((L = l.refs.tableWrapper) == null ? void 0 : L.scrollHeight) || 0, v.value = (G == null ? void 0 : G.scrollHeight) || 0, m.value = ((U = l.refs.footerWrapper) == null ? void 0 : U.offsetHeight) || 0, h.value = f.value - v.value - m.value, le && (u.value = {
      width: te,
      height: ve,
      headerHeight: e.showHeader && (G == null ? void 0 : G.offsetHeight) || 0
    }, b());
  }, D = dn(), A = k(() => {
    const { bodyWidth: P, scrollY: L, gutterWidth: U } = t;
    return P.value ? `${P.value - (L.value ? U : 0)}px` : "";
  }), z = k(() => e.maxHeight ? "fixed" : e.tableLayout), Z = k(() => {
    if (e.data && e.data.length)
      return null;
    let P = "100%";
    e.height && h.value && (P = `${h.value}px`);
    const L = d.value;
    return {
      width: L ? `${L}px` : "",
      height: P
    };
  }), J = k(() => e.height ? {
    height: Number.isNaN(Number(e.height)) ? e.height : `${e.height}px`
  } : e.maxHeight ? {
    maxHeight: Number.isNaN(Number(e.maxHeight)) ? e.maxHeight : `${e.maxHeight}px`
  } : {}), V = k(() => {
    if (e.height)
      return {
        height: "100%"
      };
    if (e.maxHeight) {
      if (Number.isNaN(Number(e.maxHeight)))
        return {
          maxHeight: `calc(${e.maxHeight} - ${v.value + m.value}px)`
        };
      {
        const P = e.maxHeight;
        if (f.value >= Number(P))
          return {
            maxHeight: `${f.value - v.value - m.value}px`
          };
      }
    }
    return {};
  });
  return {
    isHidden: o,
    renderExpanded: a,
    setDragVisible: i,
    isGroup: c,
    handleMouseLeave: g,
    handleHeaderFooterMousewheel: w,
    tableSize: D,
    emptyBlockStyle: Z,
    handleFixedMousewheel: (P, L) => {
      const U = l.refs.bodyWrapper;
      if (Math.abs(L.spinY) > 0) {
        const oe = U.scrollTop;
        L.pixelY < 0 && oe !== 0 && P.preventDefault(), L.pixelY > 0 && U.scrollHeight - U.clientHeight > oe && P.preventDefault(), U.scrollTop += Math.ceil(L.pixelY / 5);
      } else
        U.scrollLeft += Math.ceil(L.pixelX / 5);
    },
    resizeProxyVisible: r,
    bodyWidth: A,
    resizeState: u,
    doLayout: b,
    tableBodyStyles: y,
    tableLayout: z,
    scrollbarViewStyle: p,
    tableInnerStyle: J,
    scrollbarStyle: V
  };
}
function lE(e) {
  const t = N(), n = () => {
    const o = e.vnode.el.querySelector(".hidden-columns"), a = { childList: !0, subtree: !0 }, r = e.store.states.updateOrderFns;
    t.value = new MutationObserver(() => {
      r.forEach((i) => i());
    }), t.value.observe(o, a);
  };
  We(() => {
    n();
  }), Jl(() => {
    var l;
    (l = t.value) == null || l.disconnect();
  });
}
var oE = {
  data: {
    type: Array,
    default: () => []
  },
  size: Cn,
  width: [String, Number],
  height: [String, Number],
  maxHeight: [String, Number],
  fit: {
    type: Boolean,
    default: !0
  },
  stripe: Boolean,
  border: Boolean,
  rowKey: [String, Function],
  showHeader: {
    type: Boolean,
    default: !0
  },
  showSummary: Boolean,
  sumText: String,
  summaryMethod: Function,
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  cellClassName: [String, Function],
  cellStyle: [Object, Function],
  headerRowClassName: [String, Function],
  headerRowStyle: [Object, Function],
  headerCellClassName: [String, Function],
  headerCellStyle: [Object, Function],
  highlightCurrentRow: Boolean,
  currentRowKey: [String, Number],
  emptyText: String,
  expandRowKeys: Array,
  defaultExpandAll: Boolean,
  defaultSort: Object,
  tooltipEffect: String,
  tooltipOptions: Object,
  spanMethod: Function,
  selectOnIndeterminate: {
    type: Boolean,
    default: !0
  },
  indent: {
    type: Number,
    default: 16
  },
  treeProps: {
    type: Object,
    default: () => ({
      hasChildren: "hasChildren",
      children: "children"
    })
  },
  lazy: Boolean,
  load: Function,
  style: {
    type: Object,
    default: () => ({})
  },
  className: {
    type: String,
    default: ""
  },
  tableLayout: {
    type: String,
    default: "fixed"
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: !1
  },
  flexible: Boolean
};
const sE = () => {
  const e = N(), t = (a, r) => {
    const i = e.value;
    i && i.scrollTo(a, r);
  }, n = (a, r) => {
    const i = e.value;
    i && Pe(r) && ["Top", "Left"].includes(a) && i[`setScroll${a}`](r);
  };
  return {
    scrollBarRef: e,
    scrollTo: t,
    setScrollTop: (a) => n("Top", a),
    setScrollLeft: (a) => n("Left", a)
  };
};
let aE = 1;
const rE = F({
  name: "ElTable",
  directives: {
    Mousewheel: Nv
  },
  components: {
    TableHeader: US,
    TableBody: ZS,
    TableFooter: eE,
    ElScrollbar: Zn,
    hColgroup: Va
  },
  props: oE,
  emits: [
    "select",
    "select-all",
    "selection-change",
    "cell-mouse-enter",
    "cell-mouse-leave",
    "cell-contextmenu",
    "cell-click",
    "cell-dblclick",
    "row-click",
    "row-contextmenu",
    "row-dblclick",
    "header-click",
    "header-contextmenu",
    "sort-change",
    "filter-change",
    "current-change",
    "header-dragend",
    "expand-change"
  ],
  setup(e) {
    const { t } = ot(), n = se("table"), l = je();
    tt(fn, l);
    const o = PS(l, e);
    l.store = o;
    const a = new _S({
      store: l.store,
      table: l,
      fit: e.fit,
      showHeader: e.showHeader
    });
    l.layout = a;
    const r = k(() => (o.states.data.value || []).length === 0), {
      setCurrentRow: i,
      getSelectionRows: u,
      toggleRowSelection: c,
      clearSelection: p,
      clearFilter: d,
      toggleAllSelection: f,
      toggleRowExpansion: h,
      clearSort: v,
      sort: m
    } = tE(o), {
      isHidden: g,
      renderExpanded: w,
      setDragVisible: C,
      isGroup: y,
      handleMouseLeave: b,
      handleHeaderFooterMousewheel: S,
      tableSize: T,
      emptyBlockStyle: O,
      handleFixedMousewheel: I,
      resizeProxyVisible: R,
      bodyWidth: B,
      resizeState: D,
      doLayout: A,
      tableBodyStyles: z,
      tableLayout: Z,
      scrollbarViewStyle: J,
      tableInnerStyle: V,
      scrollbarStyle: M
    } = nE(e, a, o, l), { scrollBarRef: P, scrollTo: L, setScrollLeft: U, setScrollTop: oe } = sE(), le = Gt(A, 50), ee = `${n.namespace.value}-table_${aE++}`;
    l.tableId = ee, l.state = {
      isGroup: y,
      resizeState: D,
      doLayout: A,
      debouncedUpdateLayout: le
    };
    const pe = k(() => e.sumText || t("el.table.sumText")), ge = k(() => e.emptyText || t("el.table.emptyText"));
    return lE(l), {
      ns: n,
      layout: a,
      store: o,
      handleHeaderFooterMousewheel: S,
      handleMouseLeave: b,
      tableId: ee,
      tableSize: T,
      isHidden: g,
      isEmpty: r,
      renderExpanded: w,
      resizeProxyVisible: R,
      resizeState: D,
      isGroup: y,
      bodyWidth: B,
      tableBodyStyles: z,
      emptyBlockStyle: O,
      debouncedUpdateLayout: le,
      handleFixedMousewheel: I,
      setCurrentRow: i,
      getSelectionRows: u,
      toggleRowSelection: c,
      clearSelection: p,
      clearFilter: d,
      toggleAllSelection: f,
      toggleRowExpansion: h,
      clearSort: v,
      doLayout: A,
      sort: m,
      t,
      setDragVisible: C,
      context: l,
      computedSumText: pe,
      computedEmptyText: ge,
      tableLayout: Z,
      scrollbarViewStyle: J,
      tableInnerStyle: V,
      scrollbarStyle: M,
      scrollBarRef: P,
      scrollTo: L,
      setScrollLeft: U,
      setScrollTop: oe
    };
  }
}), iE = ["data-prefix"], uE = {
  ref: "hiddenColumns",
  class: "hidden-columns"
};
function cE(e, t, n, l, o, a) {
  const r = $e("hColgroup"), i = $e("table-header"), u = $e("table-body"), c = $e("el-scrollbar"), p = $e("table-footer"), d = Oo("mousewheel");
  return E(), _("div", {
    ref: "tableWrapper",
    class: $([
      {
        [e.ns.m("fit")]: e.fit,
        [e.ns.m("striped")]: e.stripe,
        [e.ns.m("border")]: e.border || e.isGroup,
        [e.ns.m("hidden")]: e.isHidden,
        [e.ns.m("group")]: e.isGroup,
        [e.ns.m("fluid-height")]: e.maxHeight,
        [e.ns.m("scrollable-x")]: e.layout.scrollX.value,
        [e.ns.m("scrollable-y")]: e.layout.scrollY.value,
        [e.ns.m("enable-row-hover")]: !e.store.states.isComplex.value,
        [e.ns.m("enable-row-transition")]: (e.store.states.data.value || []).length !== 0 && (e.store.states.data.value || []).length < 100,
        "has-footer": e.showSummary
      },
      e.ns.m(e.tableSize),
      e.className,
      e.ns.b(),
      e.ns.m(`layout-${e.tableLayout}`)
    ]),
    style: ye(e.style),
    "data-prefix": e.ns.namespace.value,
    onMouseleave: t[0] || (t[0] = (f) => e.handleMouseLeave())
  }, [
    H("div", {
      class: $(e.ns.e("inner-wrapper")),
      style: ye(e.tableInnerStyle)
    }, [
      H("div", uE, [
        ne(e.$slots, "default")
      ], 512),
      e.showHeader && e.tableLayout === "fixed" ? qe((E(), _("div", {
        key: 0,
        ref: "headerWrapper",
        class: $(e.ns.e("header-wrapper"))
      }, [
        H("table", {
          ref: "tableHeader",
          class: $(e.ns.e("header")),
          style: ye(e.tableBodyStyles),
          border: "0",
          cellpadding: "0",
          cellspacing: "0"
        }, [
          x(r, {
            columns: e.store.states.columns.value,
            "table-layout": e.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          x(i, {
            ref: "tableHeaderRef",
            border: e.border,
            "default-sort": e.defaultSort,
            store: e.store,
            onSetDragVisible: e.setDragVisible
          }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])
        ], 6)
      ], 2)), [
        [d, e.handleHeaderFooterMousewheel]
      ]) : W("v-if", !0),
      H("div", {
        ref: "bodyWrapper",
        class: $(e.ns.e("body-wrapper"))
      }, [
        x(c, {
          ref: "scrollBarRef",
          "view-style": e.scrollbarViewStyle,
          "wrap-style": e.scrollbarStyle,
          always: e.scrollbarAlwaysOn
        }, {
          default: K(() => [
            H("table", {
              ref: "tableBody",
              class: $(e.ns.e("body")),
              cellspacing: "0",
              cellpadding: "0",
              border: "0",
              style: ye({
                width: e.bodyWidth,
                tableLayout: e.tableLayout
              })
            }, [
              x(r, {
                columns: e.store.states.columns.value,
                "table-layout": e.tableLayout
              }, null, 8, ["columns", "table-layout"]),
              e.showHeader && e.tableLayout === "auto" ? (E(), q(i, {
                key: 0,
                ref: "tableHeaderRef",
                border: e.border,
                "default-sort": e.defaultSort,
                store: e.store,
                onSetDragVisible: e.setDragVisible
              }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])) : W("v-if", !0),
              x(u, {
                context: e.context,
                highlight: e.highlightCurrentRow,
                "row-class-name": e.rowClassName,
                "tooltip-effect": e.tooltipEffect,
                "tooltip-options": e.tooltipOptions,
                "row-style": e.rowStyle,
                store: e.store,
                stripe: e.stripe
              }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"])
            ], 6),
            e.isEmpty ? (E(), _("div", {
              key: 0,
              ref: "emptyBlock",
              style: ye(e.emptyBlockStyle),
              class: $(e.ns.e("empty-block"))
            }, [
              H("span", {
                class: $(e.ns.e("empty-text"))
              }, [
                ne(e.$slots, "empty", {}, () => [
                  st(ce(e.computedEmptyText), 1)
                ])
              ], 2)
            ], 6)) : W("v-if", !0),
            e.$slots.append ? (E(), _("div", {
              key: 1,
              ref: "appendWrapper",
              class: $(e.ns.e("append-wrapper"))
            }, [
              ne(e.$slots, "append")
            ], 2)) : W("v-if", !0)
          ]),
          _: 3
        }, 8, ["view-style", "wrap-style", "always"])
      ], 2),
      e.showSummary ? qe((E(), _("div", {
        key: 1,
        ref: "footerWrapper",
        class: $(e.ns.e("footer-wrapper"))
      }, [
        x(p, {
          border: e.border,
          "default-sort": e.defaultSort,
          store: e.store,
          style: ye(e.tableBodyStyles),
          "sum-text": e.computedSumText,
          "summary-method": e.summaryMethod
        }, null, 8, ["border", "default-sort", "store", "style", "sum-text", "summary-method"])
      ], 2)), [
        [at, !e.isEmpty],
        [d, e.handleHeaderFooterMousewheel]
      ]) : W("v-if", !0),
      e.border || e.isGroup ? (E(), _("div", {
        key: 2,
        class: $(e.ns.e("border-left-patch"))
      }, null, 2)) : W("v-if", !0)
    ], 6),
    qe(H("div", {
      ref: "resizeProxy",
      class: $(e.ns.e("column-resize-proxy"))
    }, null, 2), [
      [at, e.resizeProxyVisible]
    ])
  ], 46, iE);
}
var dE = /* @__PURE__ */ de(rE, [["render", cE], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/table.vue"]]);
const fE = {
  selection: "table-column--selection",
  expand: "table__expand-column"
}, pE = {
  default: {
    order: ""
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  }
}, hE = (e) => fE[e] || "", vE = {
  selection: {
    renderHeader({ store: e }) {
      function t() {
        return e.states.data.value && e.states.data.value.length === 0;
      }
      return fe(Yt, {
        disabled: t(),
        size: e.states.tableSize.value,
        indeterminate: e.states.selection.value.length > 0 && !e.states.isAllSelected.value,
        "onUpdate:modelValue": e.toggleAllSelection,
        modelValue: e.states.isAllSelected.value
      });
    },
    renderCell({
      row: e,
      column: t,
      store: n,
      $index: l
    }) {
      return fe(Yt, {
        disabled: t.selectable ? !t.selectable.call(null, e, l) : !1,
        size: n.states.tableSize.value,
        onChange: () => {
          n.commit("rowSelectedChanged", e);
        },
        onClick: (o) => o.stopPropagation(),
        modelValue: n.isSelected(e)
      });
    },
    sortable: !1,
    resizable: !1
  },
  index: {
    renderHeader({ column: e }) {
      return e.label || "#";
    },
    renderCell({
      column: e,
      $index: t
    }) {
      let n = t + 1;
      const l = e.index;
      return typeof l == "number" ? n = t + l : typeof l == "function" && (n = l(t)), fe("div", {}, [n]);
    },
    sortable: !1
  },
  expand: {
    renderHeader({ column: e }) {
      return e.label || "";
    },
    renderCell({
      row: e,
      store: t,
      expanded: n
    }) {
      const { ns: l } = t, o = [l.e("expand-icon")];
      return n && o.push(l.em("expand-icon", "expanded")), fe("div", {
        class: o,
        onClick: function(r) {
          r.stopPropagation(), t.toggleRowExpansion(e);
        }
      }, {
        default: () => [
          fe(Se, null, {
            default: () => [fe(wn)]
          })
        ]
      });
    },
    sortable: !1,
    resizable: !1
  }
};
function mE({
  row: e,
  column: t,
  $index: n
}) {
  var l;
  const o = t.property, a = o && Gd(e, o).value;
  return t && t.formatter ? t.formatter(e, t, a, n) : ((l = a == null ? void 0 : a.toString) == null ? void 0 : l.call(a)) || "";
}
function gE({
  row: e,
  treeNode: t,
  store: n
}, l = !1) {
  const { ns: o } = n;
  if (!t)
    return l ? [
      fe("span", {
        class: o.e("placeholder")
      })
    ] : null;
  const a = [], r = function(i) {
    i.stopPropagation(), !t.loading && n.loadOrToggle(e);
  };
  if (t.indent && a.push(fe("span", {
    class: o.e("indent"),
    style: { "padding-left": `${t.indent}px` }
  })), typeof t.expanded == "boolean" && !t.noLazyChildren) {
    const i = [
      o.e("expand-icon"),
      t.expanded ? o.em("expand-icon", "expanded") : ""
    ];
    let u = wn;
    t.loading && (u = wl), a.push(fe("div", {
      class: i,
      onClick: r
    }, {
      default: () => [
        fe(Se, { class: { [o.is("loading")]: t.loading } }, {
          default: () => [fe(u)]
        })
      ]
    }));
  } else
    a.push(fe("span", {
      class: o.e("placeholder")
    }));
  return a;
}
function Zr(e, t) {
  return e.reduce((n, l) => (n[l] = l, n), t);
}
function yE(e, t) {
  const n = je();
  return {
    registerComplexWatchers: () => {
      const a = ["fixed"], r = {
        realWidth: "width",
        realMinWidth: "minWidth"
      }, i = Zr(a, r);
      Object.keys(i).forEach((u) => {
        const c = r[u];
        Bt(t, c) && ue(() => t[c], (p) => {
          let d = p;
          c === "width" && u === "realWidth" && (d = Aa(p)), c === "minWidth" && u === "realMinWidth" && (d = kc(p)), n.columnConfig.value[c] = d, n.columnConfig.value[u] = d;
          const f = c === "fixed";
          e.value.store.scheduleLayout(f);
        });
      });
    },
    registerNormalWatchers: () => {
      const a = [
        "label",
        "filters",
        "filterMultiple",
        "sortable",
        "index",
        "formatter",
        "className",
        "labelClassName",
        "showOverflowTooltip"
      ], r = {
        property: "prop",
        align: "realAlign",
        headerAlign: "realHeaderAlign"
      }, i = Zr(a, r);
      Object.keys(i).forEach((u) => {
        const c = r[u];
        Bt(t, c) && ue(() => t[c], (p) => {
          n.columnConfig.value[u] = p;
        });
      });
    }
  };
}
function bE(e, t, n) {
  const l = je(), o = N(""), a = N(!1), r = N(), i = N(), u = se("table");
  en(() => {
    r.value = e.align ? `is-${e.align}` : null, r.value;
  }), en(() => {
    i.value = e.headerAlign ? `is-${e.headerAlign}` : r.value, i.value;
  });
  const c = k(() => {
    let b = l.vnode.vParent || l.parent;
    for (; b && !b.tableId && !b.columnId; )
      b = b.vnode.vParent || b.parent;
    return b;
  }), p = k(() => {
    const { store: b } = l.parent;
    if (!b)
      return !1;
    const { treeData: S } = b.states, T = S.value;
    return T && Object.keys(T).length > 0;
  }), d = N(Aa(e.width)), f = N(kc(e.minWidth)), h = (b) => (d.value && (b.width = d.value), f.value && (b.minWidth = f.value), !d.value && f.value && (b.width = void 0), b.minWidth || (b.minWidth = 80), b.realWidth = Number(b.width === void 0 ? b.minWidth : b.width), b), v = (b) => {
    const S = b.type, T = vE[S] || {};
    Object.keys(T).forEach((I) => {
      const R = T[I];
      I !== "className" && R !== void 0 && (b[I] = R);
    });
    const O = hE(S);
    if (O) {
      const I = `${s(u.namespace)}-${O}`;
      b.className = b.className ? `${b.className} ${I}` : I;
    }
    return b;
  }, m = (b) => {
    Array.isArray(b) ? b.forEach((T) => S(T)) : S(b);
    function S(T) {
      var O;
      ((O = T == null ? void 0 : T.type) == null ? void 0 : O.name) === "ElTableColumn" && (T.vParent = l);
    }
  };
  return {
    columnId: o,
    realAlign: r,
    isSubColumn: a,
    realHeaderAlign: i,
    columnOrTableParent: c,
    setColumnWidth: h,
    setColumnForcedProps: v,
    setColumnRenders: (b) => {
      e.renderHeader ? pt("TableColumn", "Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.") : b.type !== "selection" && (b.renderHeader = (T) => {
        l.columnConfig.value.label;
        const O = t.header;
        return O ? O(T) : b.label;
      });
      let S = b.renderCell;
      return b.type === "expand" ? (b.renderCell = (T) => fe("div", {
        class: "cell"
      }, [S(T)]), n.value.renderExpanded = (T) => t.default ? t.default(T) : t.default) : (S = S || mE, b.renderCell = (T) => {
        let O = null;
        if (t.default) {
          const z = t.default(T);
          O = z.some((Z) => Z.type !== Tf) ? z : S(T);
        } else
          O = S(T);
        const { columns: I } = n.value.store.states, R = I.value.findIndex((z) => z.type === "default"), B = p.value && T.cellIndex === R, D = gE(T, B), A = {
          class: "cell",
          style: {}
        };
        return b.showOverflowTooltip && (A.class = `${A.class} ${s(u.namespace)}-tooltip`, A.style = {
          width: `${(T.column.realWidth || Number(T.column.width)) - 1}px`
        }), m(O), fe("div", A, [D, O]);
      }), b;
    },
    getPropsData: (...b) => b.reduce((S, T) => (Array.isArray(T) && T.forEach((O) => {
      S[O] = e[O];
    }), S), {}),
    getColumnElIndex: (b, S) => Array.prototype.indexOf.call(b, S),
    updateColumnOrder: () => {
      n.value.store.commit("updateColumnOrder", l.columnConfig.value);
    }
  };
}
var CE = {
  type: {
    type: String,
    default: "default"
  },
  label: String,
  className: String,
  labelClassName: String,
  property: String,
  prop: String,
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  renderHeader: Function,
  sortable: {
    type: [Boolean, String],
    default: !1
  },
  sortMethod: Function,
  sortBy: [String, Function, Array],
  resizable: {
    type: Boolean,
    default: !0
  },
  columnKey: String,
  align: String,
  headerAlign: String,
  showOverflowTooltip: [Boolean, Object],
  fixed: [Boolean, String],
  formatter: Function,
  selectable: Function,
  reserveSelection: Boolean,
  filterMethod: Function,
  filteredValue: Array,
  filters: Array,
  filterPlacement: String,
  filterMultiple: {
    type: Boolean,
    default: !0
  },
  index: [Number, Function],
  sortOrders: {
    type: Array,
    default: () => ["ascending", "descending", null],
    validator: (e) => e.every((t) => ["ascending", "descending", null].includes(t))
  }
};
let wE = 1;
var Mc = F({
  name: "ElTableColumn",
  components: {
    ElCheckbox: Yt
  },
  props: CE,
  setup(e, { slots: t }) {
    const n = je(), l = N({}), o = k(() => {
      let y = n.parent;
      for (; y && !y.tableId; )
        y = y.parent;
      return y;
    }), { registerNormalWatchers: a, registerComplexWatchers: r } = yE(o, e), {
      columnId: i,
      isSubColumn: u,
      realHeaderAlign: c,
      columnOrTableParent: p,
      setColumnWidth: d,
      setColumnForcedProps: f,
      setColumnRenders: h,
      getPropsData: v,
      getColumnElIndex: m,
      realAlign: g,
      updateColumnOrder: w
    } = bE(e, t, o), C = p.value;
    i.value = `${C.tableId || C.columnId}_column_${wE++}`, Oi(() => {
      u.value = o.value !== C;
      const y = e.type || "default", b = e.sortable === "" ? !0 : e.sortable, S = {
        ...pE[y],
        id: i.value,
        type: y,
        property: e.prop || e.property,
        align: g,
        headerAlign: c,
        showOverflowTooltip: e.showOverflowTooltip,
        filterable: e.filters || e.filterMethod,
        filteredValue: [],
        filterPlacement: "",
        isColumnGroup: !1,
        isSubColumn: !1,
        filterOpened: !1,
        sortable: b,
        index: e.index,
        rawColumnKey: n.vnode.key
      };
      let B = v([
        "columnKey",
        "label",
        "className",
        "labelClassName",
        "type",
        "renderHeader",
        "formatter",
        "fixed",
        "resizable"
      ], ["sortMethod", "sortBy", "sortOrders"], ["selectable", "reserveSelection"], [
        "filterMethod",
        "filters",
        "filterMultiple",
        "filterOpened",
        "filteredValue",
        "filterPlacement"
      ]);
      B = wS(S, B), B = SS(h, d, f)(B), l.value = B, a(), r();
    }), We(() => {
      var y;
      const b = p.value, S = u.value ? b.vnode.el.children : (y = b.refs.hiddenColumns) == null ? void 0 : y.children, T = () => m(S || [], n.vnode.el);
      l.value.getColumnIndex = T, T() > -1 && o.value.store.commit("insertColumn", l.value, u.value ? b.columnConfig.value : null, w);
    }), Dt(() => {
      o.value.store.commit("removeColumn", l.value, u.value ? C.columnConfig.value : null, w);
    }), n.columnId = i.value, n.columnConfig = l;
  },
  render() {
    var e, t, n;
    try {
      const l = (t = (e = this.$slots).default) == null ? void 0 : t.call(e, {
        row: {},
        column: {},
        $index: -1
      }), o = [];
      if (Array.isArray(l))
        for (const r of l)
          ((n = r.type) == null ? void 0 : n.name) === "ElTableColumn" || r.shapeFlag & 2 ? o.push(r) : r.type === Re && Array.isArray(r.children) && r.children.forEach((i) => {
            (i == null ? void 0 : i.patchFlag) !== 1024 && !Ue(i == null ? void 0 : i.children) && o.push(i);
          });
      return fe("div", o);
    } catch {
      return fe("div", []);
    }
  }
});
const kE = xe(dE, {
  TableColumn: Mc
}), SE = Rt(Mc);
var jl = /* @__PURE__ */ ((e) => (e.ASC = "asc", e.DESC = "desc", e))(jl || {}), Ul = /* @__PURE__ */ ((e) => (e.CENTER = "center", e.RIGHT = "right", e))(Ul || {}), Rc = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e))(Rc || {});
const Ws = {
  asc: "desc",
  desc: "asc"
}, ql = Symbol("placeholder"), EE = (e, t, n) => {
  var l;
  const o = {
    flexGrow: 0,
    flexShrink: 0,
    ...n ? {} : {
      flexGrow: e.flexGrow || 0,
      flexShrink: e.flexShrink || 1
    }
  };
  n || (o.flexShrink = 1);
  const a = {
    ...(l = e.style) != null ? l : {},
    ...o,
    flexBasis: "auto",
    width: e.width
  };
  return t || (e.maxWidth && (a.maxWidth = e.maxWidth), e.minWidth && (a.minWidth = e.minWidth)), a;
};
function $E(e, t, n) {
  const l = k(() => s(t).filter((m) => !m.hidden)), o = k(() => s(l).filter((m) => m.fixed === "left" || m.fixed === !0)), a = k(() => s(l).filter((m) => m.fixed === "right")), r = k(() => s(l).filter((m) => !m.fixed)), i = k(() => {
    const m = [];
    return s(o).forEach((g) => {
      m.push({
        ...g,
        placeholderSign: ql
      });
    }), s(r).forEach((g) => {
      m.push(g);
    }), s(a).forEach((g) => {
      m.push({
        ...g,
        placeholderSign: ql
      });
    }), m;
  }), u = k(() => s(o).length || s(a).length), c = k(() => s(t).reduce((g, w) => (g[w.key] = EE(w, s(n), e.fixed), g), {})), p = k(() => s(l).reduce((m, g) => m + g.width, 0)), d = (m) => s(t).find((g) => g.key === m), f = (m) => s(c)[m], h = (m, g) => {
    m.width = g;
  };
  function v(m) {
    var g;
    const { key: w } = m.currentTarget.dataset;
    if (!w)
      return;
    const { sortState: C, sortBy: y } = e;
    let b = jl.ASC;
    Ct(C) ? b = Ws[C[w]] : b = Ws[y.order], (g = e.onColumnSort) == null || g.call(e, { column: d(w), key: w, order: b });
  }
  return {
    columns: t,
    columnsStyles: c,
    columnsTotalWidth: p,
    fixedColumnsOnLeft: o,
    fixedColumnsOnRight: a,
    hasFixedColumns: u,
    mainColumns: i,
    normalColumns: r,
    visibleColumns: l,
    getColumn: d,
    getColumnStyle: f,
    updateColumnWidth: h,
    onColumnSorted: v
  };
}
const TE = (e, {
  mainTableRef: t,
  leftTableRef: n,
  rightTableRef: l,
  onMaybeEndReached: o
}) => {
  const a = N({ scrollLeft: 0, scrollTop: 0 });
  function r(h) {
    var v, m, g;
    const { scrollTop: w } = h;
    (v = t.value) == null || v.scrollTo(h), (m = n.value) == null || m.scrollToTop(w), (g = l.value) == null || g.scrollToTop(w);
  }
  function i(h) {
    a.value = h, r(h);
  }
  function u(h) {
    a.value.scrollTop = h, r(s(a));
  }
  function c(h) {
    var v, m;
    a.value.scrollLeft = h, (m = (v = t.value) == null ? void 0 : v.scrollTo) == null || m.call(v, s(a));
  }
  function p(h) {
    var v;
    i(h), (v = e.onScroll) == null || v.call(e, h);
  }
  function d({ scrollTop: h }) {
    const { scrollTop: v } = s(a);
    h !== v && u(h);
  }
  function f(h, v = "auto") {
    var m;
    (m = t.value) == null || m.scrollToRow(h, v);
  }
  return ue(() => s(a).scrollTop, (h, v) => {
    h > v && o();
  }), {
    scrollPos: a,
    scrollTo: i,
    scrollToLeft: c,
    scrollToTop: u,
    scrollToRow: f,
    onScroll: p,
    onVerticalScroll: d
  };
}, NE = (e, { mainTableRef: t, leftTableRef: n, rightTableRef: l }) => {
  const o = je(), { emit: a } = o, r = ht(!1), i = ht(null), u = N(e.defaultExpandedRowKeys || []), c = N(-1), p = ht(null), d = N({}), f = N({}), h = ht({}), v = ht({}), m = ht({}), g = k(() => Pe(e.estimatedRowHeight));
  function w(I) {
    var R;
    (R = e.onRowsRendered) == null || R.call(e, I), I.rowCacheEnd > s(c) && (c.value = I.rowCacheEnd);
  }
  function C({ hovered: I, rowKey: R }) {
    i.value = I ? R : null;
  }
  function y({
    expanded: I,
    rowData: R,
    rowIndex: B,
    rowKey: D
  }) {
    var A, z;
    const Z = [...s(u)], J = Z.indexOf(D);
    I ? J === -1 && Z.push(D) : J > -1 && Z.splice(J, 1), u.value = Z, a("update:expandedRowKeys", Z), (A = e.onRowExpand) == null || A.call(e, {
      expanded: I,
      rowData: R,
      rowIndex: B,
      rowKey: D
    }), (z = e.onExpandedRowsChange) == null || z.call(e, Z);
  }
  const b = Gt(() => {
    var I, R, B, D;
    r.value = !0, d.value = { ...s(d), ...s(f) }, S(s(p), !1), f.value = {}, p.value = null, (I = t.value) == null || I.forceUpdate(), (R = n.value) == null || R.forceUpdate(), (B = l.value) == null || B.forceUpdate(), (D = o.proxy) == null || D.$forceUpdate(), r.value = !1;
  }, 0);
  function S(I, R = !1) {
    !s(g) || [t, n, l].forEach((B) => {
      const D = s(B);
      D && D.resetAfterRowIndex(I, R);
    });
  }
  function T(I, R, B) {
    const D = s(p);
    (D === null || D > B) && (p.value = B), f.value[I] = R;
  }
  function O({ rowKey: I, height: R, rowIndex: B }, D) {
    D ? D === Rc.RIGHT ? m.value[I] = R : h.value[I] = R : v.value[I] = R;
    const A = Math.max(...[h, m, v].map((z) => z.value[I] || 0));
    s(d)[I] !== A && (T(I, A, B), b());
  }
  return {
    hoveringRowKey: i,
    expandedRowKeys: u,
    lastRenderedRowIndex: c,
    isDynamic: g,
    isResetting: r,
    rowHeights: d,
    resetAfterIndex: S,
    onRowExpanded: y,
    onRowHovered: C,
    onRowsRendered: w,
    onRowHeightChange: O
  };
}, IE = (e, { expandedRowKeys: t, lastRenderedRowIndex: n, resetAfterIndex: l }) => {
  const o = N({}), a = k(() => {
    const i = {}, { data: u, rowKey: c } = e, p = s(t);
    if (!p || !p.length)
      return u;
    const d = [], f = /* @__PURE__ */ new Set();
    p.forEach((v) => f.add(v));
    let h = u.slice();
    for (h.forEach((v) => i[v[c]] = 0); h.length > 0; ) {
      const v = h.shift();
      d.push(v), f.has(v[c]) && Array.isArray(v.children) && v.children.length > 0 && (h = [...v.children, ...h], v.children.forEach((m) => i[m[c]] = i[v[c]] + 1));
    }
    return o.value = i, d;
  }), r = k(() => {
    const { data: i, expandColumnKey: u } = e;
    return u ? s(a) : i;
  });
  return ue(r, (i, u) => {
    i !== u && (n.value = -1, l(0, !0));
  }), {
    data: r,
    depthMap: o
  };
}, ME = (e, t) => e + t, ko = (e) => Je(e) ? e.reduce(ME, 0) : e, Xn = (e, t, n = {}) => mt(e) ? e(t) : e != null ? e : n, Tn = (e) => (["width", "maxWidth", "minWidth", "height"].forEach((t) => {
  e[t] = It(e[t]);
}), e), Oc = (e) => Mt(e) ? (t) => fe(e, t) : e, RE = (e, {
  columnsTotalWidth: t,
  data: n,
  fixedColumnsOnLeft: l,
  fixedColumnsOnRight: o
}) => {
  const a = k(() => {
    const { fixed: y, width: b, vScrollbarSize: S } = e, T = b - S;
    return y ? Math.max(Math.round(s(t)), T) : T;
  }), r = k(() => s(a) + (e.fixed ? e.vScrollbarSize : 0)), i = k(() => {
    const { height: y = 0, maxHeight: b = 0, footerHeight: S, hScrollbarSize: T } = e;
    if (b > 0) {
      const O = s(v), I = s(u), B = s(h) + O + I + T;
      return Math.min(B, b - S);
    }
    return y - S;
  }), u = k(() => {
    const { rowHeight: y, estimatedRowHeight: b } = e, S = s(n);
    return Pe(b) ? S.length * b : S.length * y;
  }), c = k(() => {
    const { maxHeight: y } = e, b = s(i);
    if (Pe(y) && y > 0)
      return b;
    const S = s(u) + s(h) + s(v);
    return Math.min(b, S);
  }), p = (y) => y.width, d = k(() => ko(s(l).map(p))), f = k(() => ko(s(o).map(p))), h = k(() => ko(e.headerHeight)), v = k(() => {
    var y;
    return (((y = e.fixedData) == null ? void 0 : y.length) || 0) * e.rowHeight;
  }), m = k(() => s(i) - s(h) - s(v)), g = k(() => {
    const { style: y = {}, height: b, width: S } = e;
    return Tn({
      ...y,
      height: b,
      width: S
    });
  }), w = k(() => Tn({ height: e.footerHeight })), C = k(() => ({
    top: It(s(h)),
    bottom: It(e.footerHeight),
    width: It(e.width)
  }));
  return {
    bodyWidth: a,
    fixedTableHeight: c,
    mainTableHeight: i,
    leftTableWidth: d,
    rightTableWidth: f,
    headerWidth: r,
    rowsHeight: u,
    windowHeight: m,
    footerHeight: w,
    emptyStyle: C,
    rootStyle: g,
    headerHeight: h
  };
}, OE = (e) => {
  const t = N(), n = N(0), l = N(0);
  let o;
  return We(() => {
    o = Mn(t, ([a]) => {
      const { width: r, height: i } = a.contentRect, { paddingLeft: u, paddingRight: c, paddingTop: p, paddingBottom: d } = getComputedStyle(a.target), f = Number.parseInt(u) || 0, h = Number.parseInt(c) || 0, v = Number.parseInt(p) || 0, m = Number.parseInt(d) || 0;
      n.value = r - f - h, l.value = i - v - m;
    }).stop;
  }), Dt(() => {
    o == null || o();
  }), ue([n, l], ([a, r]) => {
    var i;
    (i = e.onResize) == null || i.call(e, {
      width: a,
      height: r
    });
  }), {
    sizer: t,
    width: n,
    height: l
  };
};
function PE(e) {
  const t = N(), n = N(), l = N(), {
    columns: o,
    columnsStyles: a,
    columnsTotalWidth: r,
    fixedColumnsOnLeft: i,
    fixedColumnsOnRight: u,
    hasFixedColumns: c,
    mainColumns: p,
    onColumnSorted: d
  } = $E(e, tn(e, "columns"), tn(e, "fixed")), {
    scrollTo: f,
    scrollToLeft: h,
    scrollToTop: v,
    scrollToRow: m,
    onScroll: g,
    onVerticalScroll: w,
    scrollPos: C
  } = TE(e, {
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: l,
    onMaybeEndReached: De
  }), {
    expandedRowKeys: y,
    hoveringRowKey: b,
    lastRenderedRowIndex: S,
    isDynamic: T,
    isResetting: O,
    rowHeights: I,
    resetAfterIndex: R,
    onRowExpanded: B,
    onRowHeightChange: D,
    onRowHovered: A,
    onRowsRendered: z
  } = NE(e, {
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: l
  }), { data: Z, depthMap: J } = IE(e, {
    expandedRowKeys: y,
    lastRenderedRowIndex: S,
    resetAfterIndex: R
  }), {
    bodyWidth: V,
    fixedTableHeight: M,
    mainTableHeight: P,
    leftTableWidth: L,
    rightTableWidth: U,
    headerWidth: oe,
    rowsHeight: le,
    windowHeight: ee,
    footerHeight: pe,
    emptyStyle: ge,
    rootStyle: te,
    headerHeight: ve
  } = RE(e, {
    columnsTotalWidth: r,
    data: Z,
    fixedColumnsOnLeft: i,
    fixedColumnsOnRight: u
  }), G = ht(!1), Q = N(), ie = k(() => {
    const Ve = s(Z).length === 0;
    return Je(e.fixedData) ? e.fixedData.length === 0 && Ve : Ve;
  });
  function Ee(Ve) {
    const { estimatedRowHeight: Fe, rowHeight: ze, rowKey: it } = e;
    return Fe ? s(I)[s(Z)[Ve][it]] || Fe : ze;
  }
  function De() {
    const { onEndReached: Ve } = e;
    if (!Ve)
      return;
    const { scrollTop: Fe } = s(C), ze = s(le), it = s(ee), be = ze - (Fe + it) + e.hScrollbarSize;
    s(S) >= 0 && ze === Fe + s(P) - s(ve) && Ve(be);
  }
  return ue(() => e.expandedRowKeys, (Ve) => y.value = Ve, {
    deep: !0
  }), {
    columns: o,
    containerRef: Q,
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: l,
    isDynamic: T,
    isResetting: O,
    isScrolling: G,
    hoveringRowKey: b,
    hasFixedColumns: c,
    columnsStyles: a,
    columnsTotalWidth: r,
    data: Z,
    expandedRowKeys: y,
    depthMap: J,
    fixedColumnsOnLeft: i,
    fixedColumnsOnRight: u,
    mainColumns: p,
    bodyWidth: V,
    emptyStyle: ge,
    rootStyle: te,
    headerWidth: oe,
    footerHeight: pe,
    mainTableHeight: P,
    fixedTableHeight: M,
    leftTableWidth: L,
    rightTableWidth: U,
    showEmpty: ie,
    getRowHeight: Ee,
    onColumnSorted: d,
    onRowHovered: A,
    onRowExpanded: B,
    onRowsRendered: z,
    onRowHeightChange: D,
    scrollTo: f,
    scrollToLeft: h,
    scrollToTop: v,
    scrollToRow: m,
    onScroll: g,
    onVerticalScroll: w
  };
}
const Ba = Symbol("tableV2"), Pc = String, Ql = {
  type: j(Array),
  required: !0
}, Da = {
  type: j(Array)
}, Ac = {
  ...Da,
  required: !0
}, AE = String, Jr = {
  type: j(Array),
  default: () => Et([])
}, Dn = {
  type: Number,
  required: !0
}, _c = {
  type: j([String, Number, Symbol]),
  default: "id"
}, Qr = {
  type: j(Object)
}, zn = he({
  class: String,
  columns: Ql,
  columnsStyles: {
    type: j(Object),
    required: !0
  },
  depth: Number,
  expandColumnKey: AE,
  estimatedRowHeight: {
    ...jn.estimatedRowHeight,
    default: void 0
  },
  isScrolling: Boolean,
  onRowExpand: {
    type: j(Function)
  },
  onRowHover: {
    type: j(Function)
  },
  onRowHeightChange: {
    type: j(Function)
  },
  rowData: {
    type: j(Object),
    required: !0
  },
  rowEventHandlers: {
    type: j(Object)
  },
  rowIndex: {
    type: Number,
    required: !0
  },
  rowKey: _c,
  style: {
    type: j(Object)
  }
}), ds = {
  type: Number,
  required: !0
}, xa = he({
  class: String,
  columns: Ql,
  fixedHeaderData: {
    type: j(Array)
  },
  headerData: {
    type: j(Array),
    required: !0
  },
  headerHeight: {
    type: j([Number, Array]),
    default: 50
  },
  rowWidth: ds,
  rowHeight: {
    type: Number,
    default: 50
  },
  height: ds,
  width: ds
}), So = he({
  columns: Ql,
  data: Ac,
  fixedData: Da,
  estimatedRowHeight: zn.estimatedRowHeight,
  width: Dn,
  height: Dn,
  headerWidth: Dn,
  headerHeight: xa.headerHeight,
  bodyWidth: Dn,
  rowHeight: Dn,
  cache: oc.cache,
  useIsScrolling: Boolean,
  scrollbarAlwaysOn: jn.scrollbarAlwaysOn,
  scrollbarStartGap: jn.scrollbarStartGap,
  scrollbarEndGap: jn.scrollbarEndGap,
  class: Pc,
  style: Qr,
  containerStyle: Qr,
  getRowHeight: {
    type: j(Function),
    required: !0
  },
  rowKey: zn.rowKey,
  onRowsRendered: {
    type: j(Function)
  },
  onScroll: {
    type: j(Function)
  }
}), _E = he({
  cache: So.cache,
  estimatedRowHeight: zn.estimatedRowHeight,
  rowKey: _c,
  headerClass: {
    type: j([
      String,
      Function
    ])
  },
  headerProps: {
    type: j([
      Object,
      Function
    ])
  },
  headerCellProps: {
    type: j([
      Object,
      Function
    ])
  },
  headerHeight: xa.headerHeight,
  footerHeight: {
    type: Number,
    default: 0
  },
  rowClass: {
    type: j([String, Function])
  },
  rowProps: {
    type: j([Object, Function])
  },
  rowHeight: {
    type: Number,
    default: 50
  },
  cellProps: {
    type: j([
      Object,
      Function
    ])
  },
  columns: Ql,
  data: Ac,
  dataGetter: {
    type: j(Function)
  },
  fixedData: Da,
  expandColumnKey: zn.expandColumnKey,
  expandedRowKeys: Jr,
  defaultExpandedRowKeys: Jr,
  class: Pc,
  fixed: Boolean,
  style: {
    type: j(Object)
  },
  width: Dn,
  height: Dn,
  maxHeight: Number,
  useIsScrolling: Boolean,
  indentSize: {
    type: Number,
    default: 12
  },
  iconSize: {
    type: Number,
    default: 12
  },
  hScrollbarSize: jn.hScrollbarSize,
  vScrollbarSize: jn.vScrollbarSize,
  scrollbarAlwaysOn: rc.alwaysOn,
  sortBy: {
    type: j(Object),
    default: () => ({})
  },
  sortState: {
    type: j(Object),
    default: void 0
  },
  onColumnSort: {
    type: j(Function)
  },
  onExpandedRowsChange: {
    type: j(Function)
  },
  onEndReached: {
    type: j(Function)
  },
  onRowExpand: zn.onRowExpand,
  onScroll: So.onScroll,
  onRowsRendered: So.onRowsRendered,
  rowEventHandlers: zn.rowEventHandlers
}), Fa = (e, {
  slots: t
}) => {
  var n;
  const {
    cellData: l,
    style: o
  } = e, a = ((n = l == null ? void 0 : l.toString) == null ? void 0 : n.call(l)) || "";
  return x("div", {
    class: e.class,
    title: a,
    style: o
  }, [t.default ? t.default(e) : a]);
};
Fa.displayName = "ElTableV2Cell";
Fa.inheritAttrs = !1;
const Ha = (e, {
  slots: t
}) => {
  var n, l;
  return t.default ? t.default(e) : x("div", {
    class: e.class,
    title: (n = e.column) == null ? void 0 : n.title
  }, [(l = e.column) == null ? void 0 : l.title]);
};
Ha.displayName = "ElTableV2HeaderCell";
Ha.inheritAttrs = !1;
const LE = he({
  class: String,
  columns: Ql,
  columnsStyles: {
    type: j(Object),
    required: !0
  },
  headerIndex: Number,
  style: { type: j(Object) }
}), VE = F({
  name: "ElTableV2HeaderRow",
  props: LE,
  setup(e, {
    slots: t
  }) {
    return () => {
      const {
        columns: n,
        columnsStyles: l,
        headerIndex: o,
        style: a
      } = e;
      let r = n.map((i, u) => t.cell({
        columns: n,
        column: i,
        columnIndex: u,
        headerIndex: o,
        style: l[i.key]
      }));
      return t.header && (r = t.header({
        cells: r.map((i) => Je(i) && i.length === 1 ? i[0] : i),
        columns: n,
        headerIndex: o
      })), x("div", {
        class: e.class,
        style: a,
        role: "row"
      }, [r]);
    };
  }
}), BE = "ElTableV2Header", DE = F({
  name: BE,
  props: xa,
  setup(e, {
    slots: t,
    expose: n
  }) {
    const l = se("table-v2"), o = N(), a = k(() => Tn({
      width: e.width,
      height: e.height
    })), r = k(() => Tn({
      width: e.rowWidth,
      height: e.height
    })), i = k(() => Yd(s(e.headerHeight))), u = (d) => {
      const f = s(o);
      Ne(() => {
        f != null && f.scroll && f.scroll({
          left: d
        });
      });
    }, c = () => {
      const d = l.e("fixed-header-row"), {
        columns: f,
        fixedHeaderData: h,
        rowHeight: v
      } = e;
      return h == null ? void 0 : h.map((m, g) => {
        var w;
        const C = Tn({
          height: v,
          width: "100%"
        });
        return (w = t.fixed) == null ? void 0 : w.call(t, {
          class: d,
          columns: f,
          rowData: m,
          rowIndex: -(g + 1),
          style: C
        });
      });
    }, p = () => {
      const d = l.e("dynamic-header-row"), {
        columns: f
      } = e;
      return s(i).map((h, v) => {
        var m;
        const g = Tn({
          width: "100%",
          height: h
        });
        return (m = t.dynamic) == null ? void 0 : m.call(t, {
          class: d,
          columns: f,
          headerIndex: v,
          style: g
        });
      });
    };
    return n({
      scrollToLeft: u
    }), () => {
      if (!(e.height <= 0))
        return x("div", {
          ref: o,
          class: e.class,
          style: s(a),
          role: "rowgroup"
        }, [x("div", {
          style: s(r),
          class: l.e("header")
        }, [p(), c()])]);
    };
  }
}), xE = (e) => {
  const {
    isScrolling: t
  } = Oe(Ba), n = N(!1), l = N(), o = k(() => Pe(e.estimatedRowHeight) && e.rowIndex >= 0), a = (u = !1) => {
    const c = s(l);
    if (!c)
      return;
    const {
      columns: p,
      onRowHeightChange: d,
      rowKey: f,
      rowIndex: h,
      style: v
    } = e, {
      height: m
    } = c.getBoundingClientRect();
    n.value = !0, Ne(() => {
      if (u || m !== Number.parseInt(v.height)) {
        const g = p[0], w = (g == null ? void 0 : g.placeholderSign) === ql;
        d == null || d({
          rowKey: f,
          height: m,
          rowIndex: h
        }, g && !w && g.fixed);
      }
    });
  }, r = k(() => {
    const {
      rowData: u,
      rowIndex: c,
      rowKey: p,
      onRowHover: d
    } = e, f = e.rowEventHandlers || {}, h = {};
    return Object.entries(f).forEach(([v, m]) => {
      mt(m) && (h[v] = (g) => {
        m({
          event: g,
          rowData: u,
          rowIndex: c,
          rowKey: p
        });
      });
    }), d && [{
      name: "onMouseleave",
      hovered: !1
    }, {
      name: "onMouseenter",
      hovered: !0
    }].forEach(({
      name: v,
      hovered: m
    }) => {
      const g = h[v];
      h[v] = (w) => {
        d({
          event: w,
          hovered: m,
          rowData: u,
          rowIndex: c,
          rowKey: p
        }), g == null || g(w);
      };
    }), h;
  }), i = (u) => {
    const {
      onRowExpand: c,
      rowData: p,
      rowIndex: d,
      rowKey: f
    } = e;
    c == null || c({
      expanded: u,
      rowData: p,
      rowIndex: d,
      rowKey: f
    });
  };
  return We(() => {
    s(o) && a(!0);
  }), {
    isScrolling: t,
    measurable: o,
    measured: n,
    rowRef: l,
    eventHandlers: r,
    onExpand: i
  };
}, FE = "ElTableV2TableRow", HE = F({
  name: FE,
  props: zn,
  setup(e, {
    expose: t,
    slots: n,
    attrs: l
  }) {
    const {
      eventHandlers: o,
      isScrolling: a,
      measurable: r,
      measured: i,
      rowRef: u,
      onExpand: c
    } = xE(e);
    return t({
      onExpand: c
    }), () => {
      const {
        columns: p,
        columnsStyles: d,
        expandColumnKey: f,
        depth: h,
        rowData: v,
        rowIndex: m,
        style: g
      } = e;
      let w = p.map((C, y) => {
        const b = Je(v.children) && v.children.length > 0 && C.key === f;
        return n.cell({
          column: C,
          columns: p,
          columnIndex: y,
          depth: h,
          style: d[C.key],
          rowData: v,
          rowIndex: m,
          isScrolling: s(a),
          expandIconProps: b ? {
            rowData: v,
            rowIndex: m,
            onExpand: c
          } : void 0
        });
      });
      if (n.row && (w = n.row({
        cells: w.map((C) => Je(C) && C.length === 1 ? C[0] : C),
        style: g,
        columns: p,
        depth: h,
        rowData: v,
        rowIndex: m,
        isScrolling: s(a)
      })), s(r)) {
        const {
          height: C,
          ...y
        } = g || {}, b = s(i);
        return x("div", Be({
          ref: u,
          class: e.class,
          style: b ? g : y,
          role: "row"
        }, l, s(o)), [w]);
      }
      return x("div", Be(l, {
        ref: u,
        class: e.class,
        style: g,
        role: "row"
      }, s(o)), [w]);
    };
  }
}), zE = (e) => {
  const {
    sortOrder: t
  } = e;
  return x(Se, {
    size: 14,
    class: e.class
  }, {
    default: () => [t === jl.ASC ? x(Xd, null, null) : x(Zd, null, null)]
  });
}, KE = (e) => {
  const {
    expanded: t,
    expandable: n,
    onExpand: l,
    style: o,
    size: a
  } = e, r = {
    onClick: n ? () => l(!t) : void 0,
    class: e.class
  };
  return x(Se, Be(r, {
    size: a,
    style: o
  }), {
    default: () => [x(wn, null, null)]
  });
}, WE = "ElTableV2Grid", jE = (e) => {
  const t = N(), n = N(), l = k(() => {
    const {
      data: m,
      rowHeight: g,
      estimatedRowHeight: w
    } = e;
    if (!w)
      return m.length * g;
  }), o = k(() => {
    const {
      fixedData: m,
      rowHeight: g
    } = e;
    return ((m == null ? void 0 : m.length) || 0) * g;
  }), a = k(() => ko(e.headerHeight)), r = k(() => {
    const {
      height: m
    } = e;
    return Math.max(0, m - s(a) - s(o));
  }), i = k(() => s(a) + s(o) > 0), u = ({
    data: m,
    rowIndex: g
  }) => m[g][e.rowKey];
  function c({
    rowCacheStart: m,
    rowCacheEnd: g,
    rowVisibleStart: w,
    rowVisibleEnd: C
  }) {
    var y;
    (y = e.onRowsRendered) == null || y.call(e, {
      rowCacheStart: m,
      rowCacheEnd: g,
      rowVisibleStart: w,
      rowVisibleEnd: C
    });
  }
  function p(m, g) {
    var w;
    (w = n.value) == null || w.resetAfterRowIndex(m, g);
  }
  function d(m, g) {
    const w = s(t), C = s(n);
    !w || !C || (Ct(m) ? (w.scrollToLeft(m.scrollLeft), C.scrollTo(m)) : (w.scrollToLeft(m), C.scrollTo({
      scrollLeft: m,
      scrollTop: g
    })));
  }
  function f(m) {
    var g;
    (g = s(n)) == null || g.scrollTo({
      scrollTop: m
    });
  }
  function h(m, g) {
    var w;
    (w = s(n)) == null || w.scrollToItem(m, 1, g);
  }
  function v() {
    var m, g;
    (m = s(n)) == null || m.$forceUpdate(), (g = s(t)) == null || g.$forceUpdate();
  }
  return {
    bodyRef: n,
    forceUpdate: v,
    fixedRowHeight: o,
    gridHeight: r,
    hasHeader: i,
    headerHeight: a,
    headerRef: t,
    totalHeight: l,
    itemKey: u,
    onItemRendered: c,
    resetAfterRowIndex: p,
    scrollTo: d,
    scrollToTop: f,
    scrollToRow: h
  };
}, za = F({
  name: WE,
  props: So,
  setup(e, {
    slots: t,
    expose: n
  }) {
    const {
      ns: l
    } = Oe(Ba), {
      bodyRef: o,
      fixedRowHeight: a,
      gridHeight: r,
      hasHeader: i,
      headerRef: u,
      headerHeight: c,
      totalHeight: p,
      forceUpdate: d,
      itemKey: f,
      onItemRendered: h,
      resetAfterRowIndex: v,
      scrollTo: m,
      scrollToTop: g,
      scrollToRow: w
    } = jE(e);
    n({
      forceUpdate: d,
      totalHeight: p,
      scrollTo: m,
      scrollToTop: g,
      scrollToRow: w,
      resetAfterRowIndex: v
    });
    const C = () => e.bodyWidth;
    return () => {
      const {
        cache: y,
        columns: b,
        data: S,
        fixedData: T,
        useIsScrolling: O,
        scrollbarAlwaysOn: I,
        scrollbarEndGap: R,
        scrollbarStartGap: B,
        style: D,
        rowHeight: A,
        bodyWidth: z,
        estimatedRowHeight: Z,
        headerWidth: J,
        height: V,
        width: M,
        getRowHeight: P,
        onScroll: L
      } = e, U = Pe(Z), oe = U ? kw : yw, le = s(c);
      return x("div", {
        role: "table",
        class: [l.e("table"), e.class],
        style: D
      }, [x(oe, {
        ref: o,
        data: S,
        useIsScrolling: O,
        itemKey: f,
        columnCache: 0,
        columnWidth: U ? C : z,
        totalColumn: 1,
        totalRow: S.length,
        rowCache: y,
        rowHeight: U ? P : A,
        width: M,
        height: s(r),
        class: l.e("body"),
        role: "rowgroup",
        scrollbarStartGap: B,
        scrollbarEndGap: R,
        scrollbarAlwaysOn: I,
        onScroll: L,
        onItemRendered: h,
        perfMode: !1
      }, {
        default: (ee) => {
          var pe;
          const ge = S[ee.rowIndex];
          return (pe = t.row) == null ? void 0 : pe.call(t, {
            ...ee,
            columns: b,
            rowData: ge
          });
        }
      }), s(i) && x(DE, {
        ref: u,
        class: l.e("header-wrapper"),
        columns: b,
        headerData: S,
        headerHeight: e.headerHeight,
        fixedHeaderData: T,
        rowWidth: J,
        rowHeight: A,
        width: M,
        height: Math.min(le + s(a), V)
      }, {
        dynamic: t.header,
        fixed: t.row
      })]);
    };
  }
});
function UE(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Mt(e);
}
const qE = (e, {
  slots: t
}) => {
  const {
    mainTableRef: n,
    ...l
  } = e;
  return x(za, Be({
    ref: n
  }, l), UE(t) ? t : {
    default: () => [t]
  });
};
function GE(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Mt(e);
}
const YE = (e, {
  slots: t
}) => {
  if (!e.columns.length)
    return;
  const {
    leftTableRef: n,
    ...l
  } = e;
  return x(za, Be({
    ref: n
  }, l), GE(t) ? t : {
    default: () => [t]
  });
};
function XE(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Mt(e);
}
const ZE = (e, {
  slots: t
}) => {
  if (!e.columns.length)
    return;
  const {
    rightTableRef: n,
    ...l
  } = e;
  return x(za, Be({
    ref: n
  }, l), XE(t) ? t : {
    default: () => [t]
  });
};
function JE(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Mt(e);
}
const QE = (e, {
  slots: t
}) => {
  const {
    columns: n,
    columnsStyles: l,
    depthMap: o,
    expandColumnKey: a,
    expandedRowKeys: r,
    estimatedRowHeight: i,
    hasFixedColumns: u,
    hoveringRowKey: c,
    rowData: p,
    rowIndex: d,
    style: f,
    isScrolling: h,
    rowProps: v,
    rowClass: m,
    rowKey: g,
    rowEventHandlers: w,
    ns: C,
    onRowHovered: y,
    onRowExpanded: b
  } = e, S = Xn(m, {
    columns: n,
    rowData: p,
    rowIndex: d
  }, ""), T = Xn(v, {
    columns: n,
    rowData: p,
    rowIndex: d
  }), O = p[g], I = o[O] || 0, R = Boolean(a), B = d < 0, D = [C.e("row"), S, {
    [C.e(`row-depth-${I}`)]: R && d >= 0,
    [C.is("expanded")]: R && r.includes(O),
    [C.is("hovered")]: !h && O === c,
    [C.is("fixed")]: !I && B,
    [C.is("customized")]: Boolean(t.row)
  }], A = u ? y : void 0, z = {
    ...T,
    columns: n,
    columnsStyles: l,
    class: D,
    depth: I,
    expandColumnKey: a,
    estimatedRowHeight: B ? void 0 : i,
    isScrolling: h,
    rowIndex: d,
    rowData: p,
    rowKey: O,
    rowEventHandlers: w,
    style: f
  };
  return x(HE, Be(z, {
    onRowHover: A,
    onRowExpand: b
  }), JE(t) ? t : {
    default: () => [t]
  });
}, js = ({
  columns: e,
  column: t,
  columnIndex: n,
  depth: l,
  expandIconProps: o,
  isScrolling: a,
  rowData: r,
  rowIndex: i,
  style: u,
  expandedRowKeys: c,
  ns: p,
  cellProps: d,
  expandColumnKey: f,
  indentSize: h,
  iconSize: v,
  rowKey: m
}, {
  slots: g
}) => {
  const w = Tn(u);
  if (t.placeholderSign === ql)
    return x("div", {
      class: p.em("row-cell", "placeholder"),
      style: w
    }, null);
  const {
    cellRenderer: C,
    dataKey: y,
    dataGetter: b
  } = t, T = Oc(C) || g.default || ((V) => x(Fa, V, null)), O = mt(b) ? b({
    columns: e,
    column: t,
    columnIndex: n,
    rowData: r,
    rowIndex: i
  }) : Lt(r, y != null ? y : ""), I = Xn(d, {
    cellData: O,
    columns: e,
    column: t,
    columnIndex: n,
    rowIndex: i,
    rowData: r
  }), R = {
    class: p.e("cell-text"),
    columns: e,
    column: t,
    columnIndex: n,
    cellData: O,
    isScrolling: a,
    rowData: r,
    rowIndex: i
  }, B = T(R), D = [p.e("row-cell"), t.class, t.align === Ul.CENTER && p.is("align-center"), t.align === Ul.RIGHT && p.is("align-right")], A = i >= 0 && t.key === f, z = i >= 0 && c.includes(r[m]);
  let Z;
  const J = `margin-inline-start: ${l * h}px;`;
  return A && (Ct(o) ? Z = x(KE, Be(o, {
    class: [p.e("expand-icon"), p.is("expanded", z)],
    size: v,
    expanded: z,
    style: J,
    expandable: !0
  }), null) : Z = x("div", {
    style: [J, `width: ${v}px; height: ${v}px;`].join(" ")
  }, null)), x("div", Be({
    class: D,
    style: w
  }, I, {
    role: "cell"
  }), [Z, B]);
};
js.inheritAttrs = !1;
function e1(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Mt(e);
}
const t1 = ({
  columns: e,
  columnsStyles: t,
  headerIndex: n,
  style: l,
  headerClass: o,
  headerProps: a,
  ns: r
}, {
  slots: i
}) => {
  const u = {
    columns: e,
    headerIndex: n
  }, c = [r.e("header-row"), Xn(o, u, ""), {
    [r.is("customized")]: Boolean(i.header)
  }], p = {
    ...Xn(a, u),
    columnsStyles: t,
    class: c,
    columns: e,
    headerIndex: n,
    style: l
  };
  return x(VE, p, e1(i) ? i : {
    default: () => [i]
  });
}, ei = (e, {
  slots: t
}) => {
  const {
    column: n,
    ns: l,
    style: o,
    onColumnSorted: a
  } = e, r = Tn(o);
  if (n.placeholderSign === ql)
    return x("div", {
      class: l.em("header-row-cell", "placeholder"),
      style: r
    }, null);
  const {
    headerCellRenderer: i,
    headerClass: u,
    sortable: c
  } = n, p = {
    ...e,
    class: l.e("header-cell-text")
  }, f = (Oc(i) || t.default || ((b) => x(Ha, b, null)))(p), {
    sortBy: h,
    sortState: v,
    headerCellProps: m
  } = e;
  let g, w;
  if (v) {
    const b = v[n.key];
    g = Boolean(Ws[b]), w = g ? b : jl.ASC;
  } else
    g = n.key === h.key, w = g ? h.order : jl.ASC;
  const C = [l.e("header-cell"), Xn(u, e, ""), n.align === Ul.CENTER && l.is("align-center"), n.align === Ul.RIGHT && l.is("align-right"), c && l.is("sortable")], y = {
    ...Xn(m, e),
    onClick: n.sortable ? a : void 0,
    class: C,
    style: r,
    ["data-key"]: n.key
  };
  return x("div", Be(y, {
    role: "columnheader"
  }), [f, c && x(zE, {
    class: [l.e("sort-icon"), g && l.is("sorting")],
    sortOrder: w
  }, null)]);
}, Lc = (e, {
  slots: t
}) => {
  var n;
  return x("div", {
    class: e.class,
    style: e.style
  }, [(n = t.default) == null ? void 0 : n.call(t)]);
};
Lc.displayName = "ElTableV2Footer";
const Vc = (e, {
  slots: t
}) => x("div", {
  class: e.class,
  style: e.style
}, [t.default ? t.default() : x(Uu, null, null)]);
Vc.displayName = "ElTableV2Empty";
const Bc = (e, {
  slots: t
}) => {
  var n;
  return x("div", {
    class: e.class,
    style: e.style
  }, [(n = t.default) == null ? void 0 : n.call(t)]);
};
Bc.displayName = "ElTableV2Overlay";
function Il(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Mt(e);
}
const n1 = "ElTableV2", l1 = F({
  name: n1,
  props: _E,
  setup(e, {
    slots: t,
    expose: n
  }) {
    const l = se("table-v2"), {
      columnsStyles: o,
      fixedColumnsOnLeft: a,
      fixedColumnsOnRight: r,
      mainColumns: i,
      mainTableHeight: u,
      fixedTableHeight: c,
      leftTableWidth: p,
      rightTableWidth: d,
      data: f,
      depthMap: h,
      expandedRowKeys: v,
      hasFixedColumns: m,
      hoveringRowKey: g,
      mainTableRef: w,
      leftTableRef: C,
      rightTableRef: y,
      isDynamic: b,
      isResetting: S,
      isScrolling: T,
      bodyWidth: O,
      emptyStyle: I,
      rootStyle: R,
      headerWidth: B,
      footerHeight: D,
      showEmpty: A,
      scrollTo: z,
      scrollToLeft: Z,
      scrollToTop: J,
      scrollToRow: V,
      getRowHeight: M,
      onColumnSorted: P,
      onRowHeightChange: L,
      onRowHovered: U,
      onRowExpanded: oe,
      onRowsRendered: le,
      onScroll: ee,
      onVerticalScroll: pe
    } = PE(e);
    return n({
      scrollTo: z,
      scrollToLeft: Z,
      scrollToTop: J,
      scrollToRow: V
    }), tt(Ba, {
      ns: l,
      isResetting: S,
      hoveringRowKey: g,
      isScrolling: T
    }), () => {
      const {
        cache: ge,
        cellProps: te,
        estimatedRowHeight: ve,
        expandColumnKey: G,
        fixedData: Q,
        headerHeight: ie,
        headerClass: Ee,
        headerProps: De,
        headerCellProps: Ve,
        sortBy: Fe,
        sortState: ze,
        rowHeight: it,
        rowClass: be,
        rowEventHandlers: Te,
        rowKey: we,
        rowProps: _e,
        scrollbarAlwaysOn: Ie,
        indentSize: Le,
        iconSize: Ke,
        useIsScrolling: Ye,
        vScrollbarSize: nt,
        width: gt
      } = e, kt = s(f), St = {
        cache: ge,
        class: l.e("main"),
        columns: s(i),
        data: kt,
        fixedData: Q,
        estimatedRowHeight: ve,
        bodyWidth: s(O),
        headerHeight: ie,
        headerWidth: s(B),
        height: s(u),
        mainTableRef: w,
        rowKey: we,
        rowHeight: it,
        scrollbarAlwaysOn: Ie,
        scrollbarStartGap: 2,
        scrollbarEndGap: nt,
        useIsScrolling: Ye,
        width: gt,
        getRowHeight: M,
        onRowsRendered: le,
        onScroll: ee
      }, yt = s(p), ke = s(c), Y = {
        cache: ge,
        class: l.e("left"),
        columns: s(a),
        data: kt,
        estimatedRowHeight: ve,
        leftTableRef: C,
        rowHeight: it,
        bodyWidth: yt,
        headerWidth: yt,
        headerHeight: ie,
        height: ke,
        rowKey: we,
        scrollbarAlwaysOn: Ie,
        scrollbarStartGap: 2,
        scrollbarEndGap: nt,
        useIsScrolling: Ye,
        width: yt,
        getRowHeight: M,
        onScroll: pe
      }, re = s(d) + nt, Me = {
        cache: ge,
        class: l.e("right"),
        columns: s(r),
        data: kt,
        estimatedRowHeight: ve,
        rightTableRef: y,
        rowHeight: it,
        bodyWidth: re,
        headerWidth: re,
        headerHeight: ie,
        height: ke,
        rowKey: we,
        scrollbarAlwaysOn: Ie,
        scrollbarStartGap: 2,
        scrollbarEndGap: nt,
        width: re,
        style: `--${s(l.namespace)}-table-scrollbar-size: ${nt}px`,
        useIsScrolling: Ye,
        getRowHeight: M,
        onScroll: pe
      }, Ze = s(o), Qe = {
        ns: l,
        depthMap: s(h),
        columnsStyles: Ze,
        expandColumnKey: G,
        expandedRowKeys: s(v),
        estimatedRowHeight: ve,
        hasFixedColumns: s(m),
        hoveringRowKey: s(g),
        rowProps: _e,
        rowClass: be,
        rowKey: we,
        rowEventHandlers: Te,
        onRowHovered: U,
        onRowExpanded: oe,
        onRowHeightChange: L
      }, dt = {
        cellProps: te,
        expandColumnKey: G,
        indentSize: Le,
        iconSize: Ke,
        rowKey: we,
        expandedRowKeys: s(v),
        ns: l
      }, xt = {
        ns: l,
        headerClass: Ee,
        headerProps: De,
        columnsStyles: Ze
      }, _n = {
        ns: l,
        sortBy: Fe,
        sortState: ze,
        headerCellProps: Ve,
        onColumnSorted: P
      }, Ft = {
        row: (hn) => x(QE, Be(hn, Qe), {
          row: t.row,
          cell: (X) => {
            let me;
            return t.cell ? x(js, Be(X, dt, {
              style: Ze[X.column.key]
            }), Il(me = t.cell(X)) ? me : {
              default: () => [me]
            }) : x(js, Be(X, dt, {
              style: Ze[X.column.key]
            }), null);
          }
        }),
        header: (hn) => x(t1, Be(hn, xt), {
          header: t.header,
          cell: (X) => {
            let me;
            return t["header-cell"] ? x(ei, Be(X, _n, {
              style: Ze[X.column.key]
            }), Il(me = t["header-cell"](X)) ? me : {
              default: () => [me]
            }) : x(ei, Be(X, _n, {
              style: Ze[X.column.key]
            }), null);
          }
        })
      }, $l = [e.class, l.b(), l.e("root"), {
        [l.is("dynamic")]: s(b)
      }], pn = {
        class: l.e("footer"),
        style: s(D)
      };
      return x("div", {
        class: $l,
        style: s(R)
      }, [x(qE, St, Il(Ft) ? Ft : {
        default: () => [Ft]
      }), x(YE, Y, Il(Ft) ? Ft : {
        default: () => [Ft]
      }), x(ZE, Me, Il(Ft) ? Ft : {
        default: () => [Ft]
      }), t.footer && x(Lc, pn, {
        default: t.footer
      }), s(A) && x(Vc, {
        class: l.e("empty"),
        style: s(I)
      }, {
        default: t.empty
      }), t.overlay && x(Bc, {
        class: l.e("overlay")
      }, {
        default: t.overlay
      })]);
    };
  }
}), o1 = he({
  disableWidth: Boolean,
  disableHeight: Boolean,
  onResize: {
    type: j(Function)
  }
}), s1 = F({
  name: "ElAutoResizer",
  props: o1,
  setup(e, {
    slots: t
  }) {
    const n = se("auto-resizer"), {
      height: l,
      width: o,
      sizer: a
    } = OE(e), r = {
      width: "100%",
      height: "100%"
    };
    return () => {
      var i;
      return x("div", {
        ref: a,
        class: n.b(),
        style: r
      }, [(i = t.default) == null ? void 0 : i.call(t, {
        height: l.value,
        width: o.value
      })]);
    };
  }
}), a1 = xe(l1), r1 = xe(s1), i1 = he({
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger", ""],
    default: ""
  },
  size: {
    type: String,
    values: Yl,
    default: ""
  },
  truncated: {
    type: Boolean
  },
  tag: {
    type: String,
    default: "span"
  }
}), u1 = F({
  name: "ElText"
}), c1 = /* @__PURE__ */ F({
  ...u1,
  props: i1,
  setup(e) {
    const t = e, n = dn(), l = se("text"), o = k(() => [
      l.b(),
      l.m(t.type),
      l.m(n.value),
      l.is("truncated", t.truncated)
    ]);
    return (a, r) => (E(), q(Ge(a.tag), {
      class: $(s(o))
    }, {
      default: K(() => [
        ne(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var d1 = /* @__PURE__ */ de(c1, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/text/src/text.vue"]]);
const f1 = xe(d1), p1 = he({
  format: {
    type: String,
    default: "HH:mm"
  },
  modelValue: String,
  disabled: Boolean,
  editable: {
    type: Boolean,
    default: !0
  },
  effect: {
    type: String,
    default: "light"
  },
  clearable: {
    type: Boolean,
    default: !0
  },
  size: Cn,
  placeholder: String,
  start: {
    type: String,
    default: "09:00"
  },
  end: {
    type: String,
    default: "18:00"
  },
  step: {
    type: String,
    default: "00:30"
  },
  minTime: String,
  maxTime: String,
  name: String,
  prefixIcon: {
    type: j([String, Object]),
    default: () => Jd
  },
  clearIcon: {
    type: j([String, Object]),
    default: () => Ko
  }
}), gn = (e) => {
  const t = (e || "").split(":");
  if (t.length >= 2) {
    let n = Number.parseInt(t[0], 10);
    const l = Number.parseInt(t[1], 10), o = e.toUpperCase();
    return o.includes("AM") && n === 12 ? n = 0 : o.includes("PM") && n !== 12 && (n += 12), {
      hours: n,
      minutes: l
    };
  }
  return null;
}, fs = (e, t) => {
  const n = gn(e);
  if (!n)
    return -1;
  const l = gn(t);
  if (!l)
    return -1;
  const o = n.minutes + n.hours * 60, a = l.minutes + l.hours * 60;
  return o === a ? 0 : o > a ? 1 : -1;
}, ti = (e) => `${e}`.padStart(2, "0"), nl = (e) => `${ti(e.hours)}:${ti(e.minutes)}`, h1 = (e, t) => {
  const n = gn(e);
  if (!n)
    return "";
  const l = gn(t);
  if (!l)
    return "";
  const o = {
    hours: n.hours,
    minutes: n.minutes
  };
  return o.minutes += l.minutes, o.hours += l.hours, o.hours += Math.floor(o.minutes / 60), o.minutes = o.minutes % 60, nl(o);
}, v1 = F({
  name: "ElTimeSelect"
}), m1 = /* @__PURE__ */ F({
  ...v1,
  props: p1,
  emits: ["change", "blur", "focus", "update:modelValue"],
  setup(e, { expose: t }) {
    const n = e;
    Vt.extend(Vi);
    const { Option: l } = Gn, o = se("input"), a = N(), r = Pn(), i = k(() => n.modelValue), u = k(() => {
      const g = gn(n.start);
      return g ? nl(g) : null;
    }), c = k(() => {
      const g = gn(n.end);
      return g ? nl(g) : null;
    }), p = k(() => {
      const g = gn(n.step);
      return g ? nl(g) : null;
    }), d = k(() => {
      const g = gn(n.minTime || "");
      return g ? nl(g) : null;
    }), f = k(() => {
      const g = gn(n.maxTime || "");
      return g ? nl(g) : null;
    }), h = k(() => {
      const g = [];
      if (n.start && n.end && n.step) {
        let w = u.value, C;
        for (; w && c.value && fs(w, c.value) <= 0; )
          C = Vt(w, "HH:mm").format(n.format), g.push({
            value: C,
            disabled: fs(w, d.value || "-1:-1") <= 0 || fs(w, f.value || "100:100") >= 0
          }), w = h1(w, p.value);
      }
      return g;
    });
    return t({
      blur: () => {
        var g, w;
        (w = (g = a.value) == null ? void 0 : g.blur) == null || w.call(g);
      },
      focus: () => {
        var g, w;
        (w = (g = a.value) == null ? void 0 : g.focus) == null || w.call(g);
      }
    }), (g, w) => (E(), q(s(Gn), {
      ref_key: "select",
      ref: a,
      "model-value": s(i),
      disabled: s(r),
      clearable: g.clearable,
      "clear-icon": g.clearIcon,
      size: g.size,
      effect: g.effect,
      placeholder: g.placeholder,
      "default-first-option": "",
      filterable: g.editable,
      "onUpdate:modelValue": w[0] || (w[0] = (C) => g.$emit("update:modelValue", C)),
      onChange: w[1] || (w[1] = (C) => g.$emit("change", C)),
      onBlur: w[2] || (w[2] = (C) => g.$emit("blur", C)),
      onFocus: w[3] || (w[3] = (C) => g.$emit("focus", C))
    }, {
      prefix: K(() => [
        g.prefixIcon ? (E(), q(s(Se), {
          key: 0,
          class: $(s(o).e("prefix-icon"))
        }, {
          default: K(() => [
            (E(), q(Ge(g.prefixIcon)))
          ]),
          _: 1
        }, 8, ["class"])) : W("v-if", !0)
      ]),
      default: K(() => [
        (E(!0), _(Re, null, Xe(s(h), (C) => (E(), q(s(l), {
          key: C.value,
          label: C.value,
          value: C.value,
          disabled: C.disabled
        }, null, 8, ["label", "value", "disabled"]))), 128))
      ]),
      _: 1
    }, 8, ["model-value", "disabled", "clearable", "clear-icon", "size", "effect", "placeholder", "filterable"]));
  }
});
var Eo = /* @__PURE__ */ de(m1, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-select/src/time-select.vue"]]);
Eo.install = (e) => {
  e.component(Eo.name, Eo);
};
const g1 = Eo, y1 = g1, b1 = F({
  name: "ElTimeline",
  setup(e, { slots: t }) {
    const n = se("timeline");
    return tt("timeline", t), () => fe("ul", { class: [n.b()] }, [ne(t, "default")]);
  }
}), C1 = he({
  timestamp: {
    type: String,
    default: ""
  },
  hideTimestamp: {
    type: Boolean,
    default: !1
  },
  center: {
    type: Boolean,
    default: !1
  },
  placement: {
    type: String,
    values: ["top", "bottom"],
    default: "bottom"
  },
  type: {
    type: String,
    values: ["primary", "success", "warning", "danger", "info"],
    default: ""
  },
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: ["normal", "large"],
    default: "normal"
  },
  icon: {
    type: ft
  },
  hollow: {
    type: Boolean,
    default: !1
  }
}), w1 = F({
  name: "ElTimelineItem"
}), k1 = /* @__PURE__ */ F({
  ...w1,
  props: C1,
  setup(e) {
    const t = se("timeline-item");
    return (n, l) => (E(), _("li", {
      class: $([s(t).b(), { [s(t).e("center")]: n.center }])
    }, [
      H("div", {
        class: $(s(t).e("tail"))
      }, null, 2),
      n.$slots.dot ? W("v-if", !0) : (E(), _("div", {
        key: 0,
        class: $([
          s(t).e("node"),
          s(t).em("node", n.size || ""),
          s(t).em("node", n.type || ""),
          s(t).is("hollow", n.hollow)
        ]),
        style: ye({
          backgroundColor: n.color
        })
      }, [
        n.icon ? (E(), q(s(Se), {
          key: 0,
          class: $(s(t).e("icon"))
        }, {
          default: K(() => [
            (E(), q(Ge(n.icon)))
          ]),
          _: 1
        }, 8, ["class"])) : W("v-if", !0)
      ], 6)),
      n.$slots.dot ? (E(), _("div", {
        key: 1,
        class: $(s(t).e("dot"))
      }, [
        ne(n.$slots, "dot")
      ], 2)) : W("v-if", !0),
      H("div", {
        class: $(s(t).e("wrapper"))
      }, [
        !n.hideTimestamp && n.placement === "top" ? (E(), _("div", {
          key: 0,
          class: $([s(t).e("timestamp"), s(t).is("top")])
        }, ce(n.timestamp), 3)) : W("v-if", !0),
        H("div", {
          class: $(s(t).e("content"))
        }, [
          ne(n.$slots, "default")
        ], 2),
        !n.hideTimestamp && n.placement === "bottom" ? (E(), _("div", {
          key: 1,
          class: $([s(t).e("timestamp"), s(t).is("bottom")])
        }, ce(n.timestamp), 3)) : W("v-if", !0)
      ], 2)
    ], 2));
  }
});
var Dc = /* @__PURE__ */ de(k1, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/timeline/src/timeline-item.vue"]]);
const S1 = xe(b1, {
  TimelineItem: Dc
}), E1 = Rt(Dc), xc = he({
  nowrap: Boolean
});
var Fc = /* @__PURE__ */ ((e) => (e.top = "top", e.bottom = "bottom", e.left = "left", e.right = "right", e))(Fc || {});
const $1 = Object.values(Fc), Ka = he({
  width: {
    type: Number,
    default: 10
  },
  height: {
    type: Number,
    default: 10
  },
  style: {
    type: j(Object),
    default: null
  }
}), T1 = he({
  side: {
    type: j(String),
    values: $1,
    required: !0
  }
}), N1 = ["absolute", "fixed"], I1 = [
  "top-start",
  "top-end",
  "top",
  "bottom-start",
  "bottom-end",
  "bottom",
  "left-start",
  "left-end",
  "left",
  "right-start",
  "right-end",
  "right"
], Wa = he({
  ariaLabel: String,
  arrowPadding: {
    type: j(Number),
    default: 5
  },
  effect: {
    type: String,
    default: ""
  },
  contentClass: String,
  placement: {
    type: j(String),
    values: I1,
    default: "bottom"
  },
  reference: {
    type: j(Object),
    default: null
  },
  offset: {
    type: Number,
    default: 8
  },
  strategy: {
    type: j(String),
    values: N1,
    default: "absolute"
  },
  showArrow: {
    type: Boolean,
    default: !1
  }
}), ja = he({
  delayDuration: {
    type: Number,
    default: 300
  },
  defaultOpen: Boolean,
  open: {
    type: Boolean,
    default: void 0
  },
  onOpenChange: {
    type: j(Function)
  },
  "onUpdate:open": {
    type: j(Function)
  }
}), tl = {
  type: j(Function)
}, Ua = he({
  onBlur: tl,
  onClick: tl,
  onFocus: tl,
  onMouseDown: tl,
  onMouseEnter: tl,
  onMouseLeave: tl
}), M1 = he({
  ...ja,
  ...Ka,
  ...Ua,
  ...Wa,
  alwaysOn: Boolean,
  fullTransition: Boolean,
  transitionProps: {
    type: j(Object),
    default: null
  },
  teleported: Boolean,
  to: {
    type: j(String),
    default: "body"
  }
}), ts = Symbol("tooltipV2"), Hc = Symbol("tooltipV2Content"), ps = "tooltip_v2.open", R1 = F({
  name: "ElTooltipV2Root"
}), O1 = /* @__PURE__ */ F({
  ...R1,
  props: ja,
  setup(e, { expose: t }) {
    const n = e, l = N(n.defaultOpen), o = N(null), a = k({
      get: () => Qd(n.open) ? l.value : n.open,
      set: (g) => {
        var w;
        l.value = g, (w = n["onUpdate:open"]) == null || w.call(n, g);
      }
    }), r = k(() => Pe(n.delayDuration) && n.delayDuration > 0), { start: i, stop: u } = Vl(() => {
      a.value = !0;
    }, k(() => n.delayDuration), {
      immediate: !1
    }), c = se("tooltip-v2"), p = pl(), d = () => {
      u(), a.value = !0;
    }, f = () => {
      s(r) ? i() : d();
    }, h = d, v = () => {
      u(), a.value = !1;
    };
    return ue(a, (g) => {
      var w;
      g && (document.dispatchEvent(new CustomEvent(ps)), h()), (w = n.onOpenChange) == null || w.call(n, g);
    }), We(() => {
      document.addEventListener(ps, v);
    }), Dt(() => {
      u(), document.removeEventListener(ps, v);
    }), tt(ts, {
      contentId: p,
      triggerRef: o,
      ns: c,
      onClose: v,
      onDelayOpen: f,
      onOpen: h
    }), t({
      onOpen: h,
      onClose: v
    }), (g, w) => ne(g.$slots, "default", { open: s(a) });
  }
});
var P1 = /* @__PURE__ */ de(O1, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/root.vue"]]);
const A1 = F({
  name: "ElTooltipV2Arrow"
}), _1 = /* @__PURE__ */ F({
  ...A1,
  props: {
    ...Ka,
    ...T1
  },
  setup(e) {
    const t = e, { ns: n } = Oe(ts), { arrowRef: l } = Oe(Hc), o = k(() => {
      const { style: a, width: r, height: i } = t, u = n.namespace.value;
      return {
        [`--${u}-tooltip-v2-arrow-width`]: `${r}px`,
        [`--${u}-tooltip-v2-arrow-height`]: `${i}px`,
        [`--${u}-tooltip-v2-arrow-border-width`]: `${r / 2}px`,
        [`--${u}-tooltip-v2-arrow-cover-width`]: r / 2 - 1,
        ...a || {}
      };
    });
    return (a, r) => (E(), _("span", {
      ref_key: "arrowRef",
      ref: l,
      style: ye(s(o)),
      class: $(s(n).e("arrow"))
    }, null, 6));
  }
});
var ni = /* @__PURE__ */ de(_1, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/arrow.vue"]]);
const L1 = he({
  style: {
    type: j([String, Object, Array]),
    default: () => ({})
  }
}), V1 = F({
  name: "ElVisuallyHidden"
}), B1 = /* @__PURE__ */ F({
  ...V1,
  props: L1,
  setup(e) {
    const t = e, n = k(() => [
      t.style,
      {
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal"
      }
    ]);
    return (l, o) => (E(), _("span", Be(l.$attrs, { style: s(n) }), [
      ne(l.$slots, "default")
    ], 16));
  }
});
var D1 = /* @__PURE__ */ de(B1, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/visual-hidden/src/visual-hidden.vue"]]);
const x1 = ["data-side"], F1 = F({
  name: "ElTooltipV2Content"
}), H1 = /* @__PURE__ */ F({
  ...F1,
  props: { ...Wa, ...xc },
  setup(e) {
    const t = e, { triggerRef: n, contentId: l } = Oe(ts), o = N(t.placement), a = N(t.strategy), r = N(null), { referenceRef: i, contentRef: u, middlewareData: c, x: p, y: d, update: f } = gh({
      placement: o,
      strategy: a,
      middleware: k(() => {
        const y = [lh(t.offset)];
        return t.showArrow && y.push(yh({
          arrowRef: r
        })), y;
      })
    }), h = Uo().nextZIndex(), v = se("tooltip-v2"), m = k(() => o.value.split("-")[0]), g = k(() => ({
      position: s(a),
      top: `${s(d) || 0}px`,
      left: `${s(p) || 0}px`,
      zIndex: h
    })), w = k(() => {
      if (!t.showArrow)
        return {};
      const { arrow: y } = s(c);
      return {
        [`--${v.namespace.value}-tooltip-v2-arrow-x`]: `${y == null ? void 0 : y.x}px` || "",
        [`--${v.namespace.value}-tooltip-v2-arrow-y`]: `${y == null ? void 0 : y.y}px` || ""
      };
    }), C = k(() => [
      v.e("content"),
      v.is("dark", t.effect === "dark"),
      v.is(s(a)),
      t.contentClass
    ]);
    return ue(r, () => f()), ue(() => t.placement, (y) => o.value = y), We(() => {
      ue(() => t.reference || n.value, (y) => {
        i.value = y || void 0;
      }, {
        immediate: !0
      });
    }), tt(Hc, { arrowRef: r }), (y, b) => (E(), _("div", {
      ref_key: "contentRef",
      ref: u,
      style: ye(s(g)),
      "data-tooltip-v2-root": ""
    }, [
      y.nowrap ? W("v-if", !0) : (E(), _("div", {
        key: 0,
        "data-side": s(m),
        class: $(s(C))
      }, [
        ne(y.$slots, "default", {
          contentStyle: s(g),
          contentClass: s(C)
        }),
        x(s(D1), {
          id: s(l),
          role: "tooltip"
        }, {
          default: K(() => [
            y.ariaLabel ? (E(), _(Re, { key: 0 }, [
              st(ce(y.ariaLabel), 1)
            ], 64)) : ne(y.$slots, "default", { key: 1 })
          ]),
          _: 3
        }, 8, ["id"]),
        ne(y.$slots, "arrow", {
          style: ye(s(w)),
          side: s(m)
        })
      ], 10, x1))
    ], 4));
  }
});
var li = /* @__PURE__ */ de(H1, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/content.vue"]]);
const z1 = he({
  setRef: {
    type: j(Function),
    required: !0
  },
  onlyChild: Boolean
});
var K1 = F({
  props: z1,
  setup(e, {
    slots: t
  }) {
    const n = N(), l = aa(n, (o) => {
      o ? e.setRef(o.nextElementSibling) : e.setRef(null);
    });
    return () => {
      var o;
      const [a] = ((o = t.default) == null ? void 0 : o.call(t)) || [], r = e.onlyChild ? ef(a.children) : a.children;
      return x(Re, {
        ref: l
      }, [r]);
    };
  }
});
const W1 = F({
  name: "ElTooltipV2Trigger"
}), j1 = /* @__PURE__ */ F({
  ...W1,
  props: {
    ...xc,
    ...Ua
  },
  setup(e) {
    const t = e, { onClose: n, onOpen: l, onDelayOpen: o, triggerRef: a, contentId: r } = Oe(ts);
    let i = !1;
    const u = (C) => {
      a.value = C;
    }, c = () => {
      i = !1;
    }, p = $t(t.onMouseEnter, o), d = $t(t.onMouseLeave, n), f = $t(t.onMouseDown, () => {
      n(), i = !0, document.addEventListener("mouseup", c, { once: !0 });
    }), h = $t(t.onFocus, () => {
      i || l();
    }), v = $t(t.onBlur, n), m = $t(t.onClick, (C) => {
      C.detail === 0 && n();
    }), g = {
      blur: v,
      click: m,
      focus: h,
      mousedown: f,
      mouseenter: p,
      mouseleave: d
    }, w = (C, y, b) => {
      C && Object.entries(y).forEach(([S, T]) => {
        C[b](S, T);
      });
    };
    return ue(a, (C, y) => {
      w(C, g, "addEventListener"), w(y, g, "removeEventListener"), C && C.setAttribute("aria-describedby", r.value);
    }), Dt(() => {
      w(a.value, g, "removeEventListener"), document.removeEventListener("mouseup", c);
    }), (C, y) => C.nowrap ? (E(), q(s(K1), {
      key: 0,
      "set-ref": u,
      "only-child": ""
    }, {
      default: K(() => [
        ne(C.$slots, "default")
      ]),
      _: 3
    })) : (E(), _("button", Be({
      key: 1,
      ref_key: "triggerRef",
      ref: a
    }, C.$attrs), [
      ne(C.$slots, "default")
    ], 16));
  }
});
var U1 = /* @__PURE__ */ de(j1, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/trigger.vue"]]);
const q1 = F({
  name: "ElTooltipV2"
}), G1 = /* @__PURE__ */ F({
  ...q1,
  props: M1,
  setup(e) {
    const n = Ut(e), l = ct($n(n, Object.keys(Ka))), o = ct($n(n, Object.keys(Wa))), a = ct($n(n, Object.keys(ja))), r = ct($n(n, Object.keys(Ua)));
    return (i, u) => (E(), q(P1, Zt(da(a)), {
      default: K(({ open: c }) => [
        x(U1, Be(r, { nowrap: "" }), {
          default: K(() => [
            ne(i.$slots, "trigger")
          ]),
          _: 3
        }, 16),
        (E(), q(Go, {
          to: i.to,
          disabled: !i.teleported
        }, [
          i.fullTransition ? (E(), q(jt, Zt(Be({ key: 0 }, i.transitionProps)), {
            default: K(() => [
              i.alwaysOn || c ? (E(), q(li, Zt(Be({ key: 0 }, o)), {
                arrow: K(({ style: p, side: d }) => [
                  i.showArrow ? (E(), q(ni, Be({ key: 0 }, l, {
                    style: p,
                    side: d
                  }), null, 16, ["style", "side"])) : W("v-if", !0)
                ]),
                default: K(() => [
                  ne(i.$slots, "default")
                ]),
                _: 3
              }, 16)) : W("v-if", !0)
            ]),
            _: 2
          }, 1040)) : (E(), _(Re, { key: 1 }, [
            i.alwaysOn || c ? (E(), q(li, Zt(Be({ key: 0 }, o)), {
              arrow: K(({ style: p, side: d }) => [
                i.showArrow ? (E(), q(ni, Be({ key: 0 }, l, {
                  style: p,
                  side: d
                }), null, 16, ["style", "side"])) : W("v-if", !0)
              ]),
              default: K(() => [
                ne(i.$slots, "default")
              ]),
              _: 3
            }, 16)) : W("v-if", !0)
          ], 64))
        ], 8, ["to", "disabled"]))
      ]),
      _: 3
    }, 16));
  }
});
var Y1 = /* @__PURE__ */ de(G1, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/tooltip.vue"]]);
const X1 = xe(Y1), zc = "left-check-change", Kc = "right-check-change", ll = he({
  data: {
    type: j(Array),
    default: () => []
  },
  titles: {
    type: j(Array),
    default: () => []
  },
  buttonTexts: {
    type: j(Array),
    default: () => []
  },
  filterPlaceholder: String,
  filterMethod: {
    type: j(Function)
  },
  leftDefaultChecked: {
    type: j(Array),
    default: () => []
  },
  rightDefaultChecked: {
    type: j(Array),
    default: () => []
  },
  renderContent: {
    type: j(Function)
  },
  modelValue: {
    type: j(Array),
    default: () => []
  },
  format: {
    type: j(Object),
    default: () => ({})
  },
  filterable: Boolean,
  props: {
    type: j(Object),
    default: () => Et({
      label: "label",
      key: "key",
      disabled: "disabled"
    })
  },
  targetOrder: {
    type: String,
    values: ["original", "push", "unshift"],
    default: "original"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), Us = (e, t) => [e, t].every(Je) || Je(e) && un(t), Z1 = {
  [vt]: (e, t, n) => [e, n].every(Je) && ["left", "right"].includes(t),
  [et]: (e) => Je(e),
  [zc]: Us,
  [Kc]: Us
}, qs = "checked-change", J1 = he({
  data: ll.data,
  optionRender: {
    type: j(Function)
  },
  placeholder: String,
  title: String,
  filterable: Boolean,
  format: ll.format,
  filterMethod: ll.filterMethod,
  defaultChecked: ll.leftDefaultChecked,
  props: ll.props
}), Q1 = {
  [qs]: Us
}, eo = (e) => {
  const t = {
    label: "label",
    key: "key",
    disabled: "disabled"
  };
  return k(() => ({
    ...t,
    ...e.props
  }));
}, e$ = (e, t, n) => {
  const l = eo(e), o = k(() => e.data.filter((p) => mt(e.filterMethod) ? e.filterMethod(t.query, p) : String(p[l.value.label] || p[l.value.key]).toLowerCase().includes(t.query.toLowerCase()))), a = k(() => o.value.filter((p) => !p[l.value.disabled])), r = k(() => {
    const p = t.checked.length, d = e.data.length, { noChecked: f, hasChecked: h } = e.format;
    return f && h ? p > 0 ? h.replace(/\${checked}/g, p.toString()).replace(/\${total}/g, d.toString()) : f.replace(/\${total}/g, d.toString()) : `${p}/${d}`;
  }), i = k(() => {
    const p = t.checked.length;
    return p > 0 && p < a.value.length;
  }), u = () => {
    const p = a.value.map((d) => d[l.value.key]);
    t.allChecked = p.length > 0 && p.every((d) => t.checked.includes(d));
  }, c = (p) => {
    t.checked = p ? a.value.map((d) => d[l.value.key]) : [];
  };
  return ue(() => t.checked, (p, d) => {
    if (u(), t.checkChangeByUser) {
      const f = p.concat(d).filter((h) => !p.includes(h) || !d.includes(h));
      n(qs, p, f);
    } else
      n(qs, p), t.checkChangeByUser = !0;
  }), ue(a, () => {
    u();
  }), ue(() => e.data, () => {
    const p = [], d = o.value.map((f) => f[l.value.key]);
    t.checked.forEach((f) => {
      d.includes(f) && p.push(f);
    }), t.checkChangeByUser = !1, t.checked = p;
  }), ue(() => e.defaultChecked, (p, d) => {
    if (d && p.length === d.length && p.every((v) => d.includes(v)))
      return;
    const f = [], h = a.value.map((v) => v[l.value.key]);
    p.forEach((v) => {
      h.includes(v) && f.push(v);
    }), t.checkChangeByUser = !1, t.checked = f;
  }, {
    immediate: !0
  }), {
    filteredData: o,
    checkableData: a,
    checkedSummary: r,
    isIndeterminate: i,
    updateAllChecked: u,
    handleAllCheckedChange: c
  };
}, t$ = (e, t) => ({
  onSourceCheckedChange: (o, a) => {
    e.leftChecked = o, a && t(zc, o, a);
  },
  onTargetCheckedChange: (o, a) => {
    e.rightChecked = o, a && t(Kc, o, a);
  }
}), n$ = (e) => {
  const t = eo(e), n = k(() => e.data.reduce((a, r) => (a[r[t.value.key]] = r) && a, {})), l = k(() => e.data.filter((a) => !e.modelValue.includes(a[t.value.key]))), o = k(() => e.targetOrder === "original" ? e.data.filter((a) => e.modelValue.includes(a[t.value.key])) : e.modelValue.reduce((a, r) => {
    const i = n.value[r];
    return i && a.push(i), a;
  }, []));
  return {
    sourceData: l,
    targetData: o
  };
}, l$ = (e, t, n) => {
  const l = eo(e), o = (i, u, c) => {
    n(et, i), n(vt, i, u, c);
  };
  return {
    addToLeft: () => {
      const i = e.modelValue.slice();
      t.rightChecked.forEach((u) => {
        const c = i.indexOf(u);
        c > -1 && i.splice(c, 1);
      }), o(i, "left", t.rightChecked);
    },
    addToRight: () => {
      let i = e.modelValue.slice();
      const u = e.data.filter((c) => {
        const p = c[l.value.key];
        return t.leftChecked.includes(p) && !e.modelValue.includes(p);
      }).map((c) => c[l.value.key]);
      i = e.targetOrder === "unshift" ? u.concat(i) : i.concat(u), e.targetOrder === "original" && (i = e.data.filter((c) => i.includes(c[l.value.key])).map((c) => c[l.value.key])), o(i, "right", t.leftChecked);
    }
  };
}, o$ = F({
  name: "ElTransferPanel"
}), s$ = /* @__PURE__ */ F({
  ...o$,
  props: J1,
  emits: Q1,
  setup(e, { expose: t, emit: n }) {
    const l = e, o = kn(), a = ({ option: y }) => y, { t: r } = ot(), i = se("transfer"), u = ct({
      checked: [],
      allChecked: !1,
      query: "",
      checkChangeByUser: !0
    }), c = eo(l), {
      filteredData: p,
      checkedSummary: d,
      isIndeterminate: f,
      handleAllCheckedChange: h
    } = e$(l, u, n), v = k(() => !an(u.query) && an(p.value)), m = k(() => !an(o.default()[0].children)), { checked: g, allChecked: w, query: C } = Ut(u);
    return t({
      query: C
    }), (y, b) => (E(), _("div", {
      class: $(s(i).b("panel"))
    }, [
      H("p", {
        class: $(s(i).be("panel", "header"))
      }, [
        x(s(Yt), {
          modelValue: s(w),
          "onUpdate:modelValue": b[0] || (b[0] = (S) => Nn(w) ? w.value = S : null),
          indeterminate: s(f),
          "validate-event": !1,
          onChange: s(h)
        }, {
          default: K(() => [
            st(ce(y.title) + " ", 1),
            H("span", null, ce(s(d)), 1)
          ]),
          _: 1
        }, 8, ["modelValue", "indeterminate", "onChange"])
      ], 2),
      H("div", {
        class: $([s(i).be("panel", "body"), s(i).is("with-footer", s(m))])
      }, [
        y.filterable ? (E(), q(s(Jn), {
          key: 0,
          modelValue: s(C),
          "onUpdate:modelValue": b[1] || (b[1] = (S) => Nn(C) ? C.value = S : null),
          class: $(s(i).be("panel", "filter")),
          size: "default",
          placeholder: y.placeholder,
          "prefix-icon": s(tf),
          clearable: "",
          "validate-event": !1
        }, null, 8, ["modelValue", "class", "placeholder", "prefix-icon"])) : W("v-if", !0),
        qe(x(s(Bi), {
          modelValue: s(g),
          "onUpdate:modelValue": b[2] || (b[2] = (S) => Nn(g) ? g.value = S : null),
          "validate-event": !1,
          class: $([s(i).is("filterable", y.filterable), s(i).be("panel", "list")])
        }, {
          default: K(() => [
            (E(!0), _(Re, null, Xe(s(p), (S) => (E(), q(s(Yt), {
              key: S[s(c).key],
              class: $(s(i).be("panel", "item")),
              label: S[s(c).key],
              disabled: S[s(c).disabled],
              "validate-event": !1
            }, {
              default: K(() => {
                var T;
                return [
                  x(a, {
                    option: (T = y.optionRender) == null ? void 0 : T.call(y, S)
                  }, null, 8, ["option"])
                ];
              }),
              _: 2
            }, 1032, ["class", "label", "disabled"]))), 128))
          ]),
          _: 1
        }, 8, ["modelValue", "class"]), [
          [at, !s(v) && !s(an)(y.data)]
        ]),
        qe(H("p", {
          class: $(s(i).be("panel", "empty"))
        }, ce(s(v) ? s(r)("el.transfer.noMatch") : s(r)("el.transfer.noData")), 3), [
          [at, s(v) || s(an)(y.data)]
        ])
      ], 2),
      s(m) ? (E(), _("p", {
        key: 0,
        class: $(s(i).be("panel", "footer"))
      }, [
        ne(y.$slots, "default")
      ], 2)) : W("v-if", !0)
    ], 2));
  }
});
var oi = /* @__PURE__ */ de(s$, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/transfer/src/transfer-panel.vue"]]);
const a$ = { key: 0 }, r$ = { key: 0 }, i$ = F({
  name: "ElTransfer"
}), u$ = /* @__PURE__ */ F({
  ...i$,
  props: ll,
  emits: Z1,
  setup(e, { expose: t, emit: n }) {
    const l = e, o = kn(), { t: a } = ot(), r = se("transfer"), { formItem: i } = kl(), u = ct({
      leftChecked: [],
      rightChecked: []
    }), c = eo(l), { sourceData: p, targetData: d } = n$(l), { onSourceCheckedChange: f, onTargetCheckedChange: h } = t$(u, n), { addToLeft: v, addToRight: m } = l$(l, u, n), g = N(), w = N(), C = (I) => {
      switch (I) {
        case "left":
          g.value.query = "";
          break;
        case "right":
          w.value.query = "";
          break;
      }
    }, y = k(() => l.buttonTexts.length === 2), b = k(() => l.titles[0] || a("el.transfer.titles.0")), S = k(() => l.titles[1] || a("el.transfer.titles.1")), T = k(() => l.filterPlaceholder || a("el.transfer.filterPlaceholder"));
    ue(() => l.modelValue, () => {
      var I;
      l.validateEvent && ((I = i == null ? void 0 : i.validate) == null || I.call(i, "change").catch((R) => pt(R)));
    });
    const O = k(() => (I) => l.renderContent ? l.renderContent(fe, I) : o.default ? o.default({ option: I }) : fe("span", I[c.value.label] || I[c.value.key]));
    return t({
      clearQuery: C,
      leftPanel: g,
      rightPanel: w
    }), (I, R) => (E(), _("div", {
      class: $(s(r).b())
    }, [
      x(oi, {
        ref_key: "leftPanel",
        ref: g,
        data: s(p),
        "option-render": s(O),
        placeholder: s(T),
        title: s(b),
        filterable: I.filterable,
        format: I.format,
        "filter-method": I.filterMethod,
        "default-checked": I.leftDefaultChecked,
        props: l.props,
        onCheckedChange: s(f)
      }, {
        default: K(() => [
          ne(I.$slots, "left-footer")
        ]),
        _: 3
      }, 8, ["data", "option-render", "placeholder", "title", "filterable", "format", "filter-method", "default-checked", "props", "onCheckedChange"]),
      H("div", {
        class: $(s(r).e("buttons"))
      }, [
        x(s(Kt), {
          type: "primary",
          class: $([s(r).e("button"), s(r).is("with-texts", s(y))]),
          disabled: s(an)(u.rightChecked),
          onClick: s(v)
        }, {
          default: K(() => [
            x(s(Se), null, {
              default: K(() => [
                x(s(zo))
              ]),
              _: 1
            }),
            s(qn)(I.buttonTexts[0]) ? W("v-if", !0) : (E(), _("span", a$, ce(I.buttonTexts[0]), 1))
          ]),
          _: 1
        }, 8, ["class", "disabled", "onClick"]),
        x(s(Kt), {
          type: "primary",
          class: $([s(r).e("button"), s(r).is("with-texts", s(y))]),
          disabled: s(an)(u.leftChecked),
          onClick: s(m)
        }, {
          default: K(() => [
            s(qn)(I.buttonTexts[1]) ? W("v-if", !0) : (E(), _("span", r$, ce(I.buttonTexts[1]), 1)),
            x(s(Se), null, {
              default: K(() => [
                x(s(wn))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["class", "disabled", "onClick"])
      ], 2),
      x(oi, {
        ref_key: "rightPanel",
        ref: w,
        data: s(d),
        "option-render": s(O),
        placeholder: s(T),
        filterable: I.filterable,
        format: I.format,
        "filter-method": I.filterMethod,
        title: s(S),
        "default-checked": I.rightDefaultChecked,
        props: l.props,
        onCheckedChange: s(h)
      }, {
        default: K(() => [
          ne(I.$slots, "right-footer")
        ]),
        _: 3
      }, 8, ["data", "option-render", "placeholder", "filterable", "format", "filter-method", "title", "default-checked", "props", "onCheckedChange"])
    ], 2));
  }
});
var c$ = /* @__PURE__ */ de(u$, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/transfer/src/transfer.vue"]]);
const d$ = xe(c$), fl = "$treeNodeId", si = function(e, t) {
  !t || t[fl] || Object.defineProperty(t, fl, {
    value: e.id,
    enumerable: !1,
    configurable: !1,
    writable: !1
  });
}, qa = function(e, t) {
  return e ? t[e] : t[fl];
}, Gs = (e, t, n) => {
  const l = e.value.currentNode;
  n();
  const o = e.value.currentNode;
  l !== o && t("current-change", o ? o.data : null, o);
}, Ys = (e) => {
  let t = !0, n = !0, l = !0;
  for (let o = 0, a = e.length; o < a; o++) {
    const r = e[o];
    (r.checked !== !0 || r.indeterminate) && (t = !1, r.disabled || (l = !1)), (r.checked !== !1 || r.indeterminate) && (n = !1);
  }
  return { all: t, none: n, allWithoutDisable: l, half: !t && !n };
}, $o = function(e) {
  if (e.childNodes.length === 0 || e.loading)
    return;
  const { all: t, none: n, half: l } = Ys(e.childNodes);
  t ? (e.checked = !0, e.indeterminate = !1) : l ? (e.checked = !1, e.indeterminate = !0) : n && (e.checked = !1, e.indeterminate = !1);
  const o = e.parent;
  !o || o.level === 0 || e.store.checkStrictly || $o(o);
}, ao = function(e, t) {
  const n = e.store.props, l = e.data || {}, o = n[t];
  if (typeof o == "function")
    return o(l, e);
  if (typeof o == "string")
    return l[o];
  if (typeof o > "u") {
    const a = l[t];
    return a === void 0 ? "" : a;
  }
};
let f$ = 0;
class Un {
  constructor(t) {
    this.id = f$++, this.text = null, this.checked = !1, this.indeterminate = !1, this.data = null, this.expanded = !1, this.parent = null, this.visible = !0, this.isCurrent = !1, this.canFocus = !1;
    for (const n in t)
      Bt(t, n) && (this[n] = t[n]);
    this.level = 0, this.loaded = !1, this.childNodes = [], this.loading = !1, this.parent && (this.level = this.parent.level + 1);
  }
  initialize() {
    const t = this.store;
    if (!t)
      throw new Error("[Node]store is required!");
    t.registerNode(this);
    const n = t.props;
    if (n && typeof n.isLeaf < "u") {
      const a = ao(this, "isLeaf");
      typeof a == "boolean" && (this.isLeafByUser = a);
    }
    if (t.lazy !== !0 && this.data ? (this.setData(this.data), t.defaultExpandAll && (this.expanded = !0, this.canFocus = !0)) : this.level > 0 && t.lazy && t.defaultExpandAll && this.expand(), Array.isArray(this.data) || si(this, this.data), !this.data)
      return;
    const l = t.defaultExpandedKeys, o = t.key;
    o && l && l.includes(this.key) && this.expand(null, t.autoExpandParent), o && t.currentNodeKey !== void 0 && this.key === t.currentNodeKey && (t.currentNode = this, t.currentNode.isCurrent = !0), t.lazy && t._initDefaultCheckedNode(this), this.updateLeafState(), this.parent && (this.level === 1 || this.parent.expanded === !0) && (this.canFocus = !0);
  }
  setData(t) {
    Array.isArray(t) || si(this, t), this.data = t, this.childNodes = [];
    let n;
    this.level === 0 && Array.isArray(this.data) ? n = this.data : n = ao(this, "children") || [];
    for (let l = 0, o = n.length; l < o; l++)
      this.insertChild({ data: n[l] });
  }
  get label() {
    return ao(this, "label");
  }
  get key() {
    const t = this.store.key;
    return this.data ? this.data[t] : null;
  }
  get disabled() {
    return ao(this, "disabled");
  }
  get nextSibling() {
    const t = this.parent;
    if (t) {
      const n = t.childNodes.indexOf(this);
      if (n > -1)
        return t.childNodes[n + 1];
    }
    return null;
  }
  get previousSibling() {
    const t = this.parent;
    if (t) {
      const n = t.childNodes.indexOf(this);
      if (n > -1)
        return n > 0 ? t.childNodes[n - 1] : null;
    }
    return null;
  }
  contains(t, n = !0) {
    return (this.childNodes || []).some((l) => l === t || n && l.contains(t));
  }
  remove() {
    const t = this.parent;
    t && t.removeChild(this);
  }
  insertChild(t, n, l) {
    if (!t)
      throw new Error("InsertChild error: child is required.");
    if (!(t instanceof Un)) {
      if (!l) {
        const o = this.getChildren(!0);
        o.includes(t.data) || (typeof n > "u" || n < 0 ? o.push(t.data) : o.splice(n, 0, t.data));
      }
      Object.assign(t, {
        parent: this,
        store: this.store
      }), t = ct(new Un(t)), t instanceof Un && t.initialize();
    }
    t.level = this.level + 1, typeof n > "u" || n < 0 ? this.childNodes.push(t) : this.childNodes.splice(n, 0, t), this.updateLeafState();
  }
  insertBefore(t, n) {
    let l;
    n && (l = this.childNodes.indexOf(n)), this.insertChild(t, l);
  }
  insertAfter(t, n) {
    let l;
    n && (l = this.childNodes.indexOf(n), l !== -1 && (l += 1)), this.insertChild(t, l);
  }
  removeChild(t) {
    const n = this.getChildren() || [], l = n.indexOf(t.data);
    l > -1 && n.splice(l, 1);
    const o = this.childNodes.indexOf(t);
    o > -1 && (this.store && this.store.deregisterNode(t), t.parent = null, this.childNodes.splice(o, 1)), this.updateLeafState();
  }
  removeChildByData(t) {
    let n = null;
    for (let l = 0; l < this.childNodes.length; l++)
      if (this.childNodes[l].data === t) {
        n = this.childNodes[l];
        break;
      }
    n && this.removeChild(n);
  }
  expand(t, n) {
    const l = () => {
      if (n) {
        let o = this.parent;
        for (; o.level > 0; )
          o.expanded = !0, o = o.parent;
      }
      this.expanded = !0, t && t(), this.childNodes.forEach((o) => {
        o.canFocus = !0;
      });
    };
    this.shouldLoadData() ? this.loadData((o) => {
      Array.isArray(o) && (this.checked ? this.setChecked(!0, !0) : this.store.checkStrictly || $o(this), l());
    }) : l();
  }
  doCreateChildren(t, n = {}) {
    t.forEach((l) => {
      this.insertChild(Object.assign({ data: l }, n), void 0, !0);
    });
  }
  collapse() {
    this.expanded = !1, this.childNodes.forEach((t) => {
      t.canFocus = !1;
    });
  }
  shouldLoadData() {
    return this.store.lazy === !0 && this.store.load && !this.loaded;
  }
  updateLeafState() {
    if (this.store.lazy === !0 && this.loaded !== !0 && typeof this.isLeafByUser < "u") {
      this.isLeaf = this.isLeafByUser;
      return;
    }
    const t = this.childNodes;
    if (!this.store.lazy || this.store.lazy === !0 && this.loaded === !0) {
      this.isLeaf = !t || t.length === 0;
      return;
    }
    this.isLeaf = !1;
  }
  setChecked(t, n, l, o) {
    if (this.indeterminate = t === "half", this.checked = t === !0, this.store.checkStrictly)
      return;
    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
      const { all: r, allWithoutDisable: i } = Ys(this.childNodes);
      !this.isLeaf && !r && i && (this.checked = !1, t = !1);
      const u = () => {
        if (n) {
          const c = this.childNodes;
          for (let f = 0, h = c.length; f < h; f++) {
            const v = c[f];
            o = o || t !== !1;
            const m = v.disabled ? v.checked : o;
            v.setChecked(m, n, !0, o);
          }
          const { half: p, all: d } = Ys(c);
          d || (this.checked = d, this.indeterminate = p);
        }
      };
      if (this.shouldLoadData()) {
        this.loadData(() => {
          u(), $o(this);
        }, {
          checked: t !== !1
        });
        return;
      } else
        u();
    }
    const a = this.parent;
    !a || a.level === 0 || l || $o(a);
  }
  getChildren(t = !1) {
    if (this.level === 0)
      return this.data;
    const n = this.data;
    if (!n)
      return null;
    const l = this.store.props;
    let o = "children";
    return l && (o = l.children || "children"), n[o] === void 0 && (n[o] = null), t && !n[o] && (n[o] = []), n[o];
  }
  updateChildren() {
    const t = this.getChildren() || [], n = this.childNodes.map((a) => a.data), l = {}, o = [];
    t.forEach((a, r) => {
      const i = a[fl];
      !!i && n.findIndex((c) => c[fl] === i) >= 0 ? l[i] = { index: r, data: a } : o.push({ index: r, data: a });
    }), this.store.lazy || n.forEach((a) => {
      l[a[fl]] || this.removeChildByData(a);
    }), o.forEach(({ index: a, data: r }) => {
      this.insertChild({ data: r }, a);
    }), this.updateLeafState();
  }
  loadData(t, n = {}) {
    if (this.store.lazy === !0 && this.store.load && !this.loaded && (!this.loading || Object.keys(n).length)) {
      this.loading = !0;
      const l = (o) => {
        this.childNodes = [], this.doCreateChildren(o, n), this.loaded = !0, this.loading = !1, this.updateLeafState(), t && t.call(this, o);
      };
      this.store.load(this, l);
    } else
      t && t.call(this);
  }
}
class p$ {
  constructor(t) {
    this.currentNode = null, this.currentNodeKey = null;
    for (const n in t)
      Bt(t, n) && (this[n] = t[n]);
    this.nodesMap = {};
  }
  initialize() {
    if (this.root = new Un({
      data: this.data,
      store: this
    }), this.root.initialize(), this.lazy && this.load) {
      const t = this.load;
      t(this.root, (n) => {
        this.root.doCreateChildren(n), this._initDefaultCheckedNodes();
      });
    } else
      this._initDefaultCheckedNodes();
  }
  filter(t) {
    const n = this.filterNodeMethod, l = this.lazy, o = function(a) {
      const r = a.root ? a.root.childNodes : a.childNodes;
      if (r.forEach((i) => {
        i.visible = n.call(i, t, i.data, i), o(i);
      }), !a.visible && r.length) {
        let i = !0;
        i = !r.some((u) => u.visible), a.root ? a.root.visible = i === !1 : a.visible = i === !1;
      }
      !t || a.visible && !a.isLeaf && !l && a.expand();
    };
    o(this);
  }
  setData(t) {
    t !== this.root.data ? (this.root.setData(t), this._initDefaultCheckedNodes()) : this.root.updateChildren();
  }
  getNode(t) {
    if (t instanceof Un)
      return t;
    const n = Ct(t) ? qa(this.key, t) : t;
    return this.nodesMap[n] || null;
  }
  insertBefore(t, n) {
    const l = this.getNode(n);
    l.parent.insertBefore({ data: t }, l);
  }
  insertAfter(t, n) {
    const l = this.getNode(n);
    l.parent.insertAfter({ data: t }, l);
  }
  remove(t) {
    const n = this.getNode(t);
    n && n.parent && (n === this.currentNode && (this.currentNode = null), n.parent.removeChild(n));
  }
  append(t, n) {
    const l = n ? this.getNode(n) : this.root;
    l && l.insertChild({ data: t });
  }
  _initDefaultCheckedNodes() {
    const t = this.defaultCheckedKeys || [], n = this.nodesMap;
    t.forEach((l) => {
      const o = n[l];
      o && o.setChecked(!0, !this.checkStrictly);
    });
  }
  _initDefaultCheckedNode(t) {
    (this.defaultCheckedKeys || []).includes(t.key) && t.setChecked(!0, !this.checkStrictly);
  }
  setDefaultCheckedKey(t) {
    t !== this.defaultCheckedKeys && (this.defaultCheckedKeys = t, this._initDefaultCheckedNodes());
  }
  registerNode(t) {
    const n = this.key;
    !t || !t.data || (n ? t.key !== void 0 && (this.nodesMap[t.key] = t) : this.nodesMap[t.id] = t);
  }
  deregisterNode(t) {
    !this.key || !t || !t.data || (t.childNodes.forEach((l) => {
      this.deregisterNode(l);
    }), delete this.nodesMap[t.key]);
  }
  getCheckedNodes(t = !1, n = !1) {
    const l = [], o = function(a) {
      (a.root ? a.root.childNodes : a.childNodes).forEach((i) => {
        (i.checked || n && i.indeterminate) && (!t || t && i.isLeaf) && l.push(i.data), o(i);
      });
    };
    return o(this), l;
  }
  getCheckedKeys(t = !1) {
    return this.getCheckedNodes(t).map((n) => (n || {})[this.key]);
  }
  getHalfCheckedNodes() {
    const t = [], n = function(l) {
      (l.root ? l.root.childNodes : l.childNodes).forEach((a) => {
        a.indeterminate && t.push(a.data), n(a);
      });
    };
    return n(this), t;
  }
  getHalfCheckedKeys() {
    return this.getHalfCheckedNodes().map((t) => (t || {})[this.key]);
  }
  _getAllNodes() {
    const t = [], n = this.nodesMap;
    for (const l in n)
      Bt(n, l) && t.push(n[l]);
    return t;
  }
  updateChildren(t, n) {
    const l = this.nodesMap[t];
    if (!l)
      return;
    const o = l.childNodes;
    for (let a = o.length - 1; a >= 0; a--) {
      const r = o[a];
      this.remove(r.data);
    }
    for (let a = 0, r = n.length; a < r; a++) {
      const i = n[a];
      this.append(i, l.data);
    }
  }
  _setCheckedKeys(t, n = !1, l) {
    const o = this._getAllNodes().sort((i, u) => u.level - i.level), a = /* @__PURE__ */ Object.create(null), r = Object.keys(l);
    o.forEach((i) => i.setChecked(!1, !1));
    for (let i = 0, u = o.length; i < u; i++) {
      const c = o[i], p = c.data[t].toString();
      if (!r.includes(p)) {
        c.checked && !a[p] && c.setChecked(!1, !1);
        continue;
      }
      let f = c.parent;
      for (; f && f.level > 0; )
        a[f.data[t]] = !0, f = f.parent;
      if (c.isLeaf || this.checkStrictly) {
        c.setChecked(!0, !1);
        continue;
      }
      if (c.setChecked(!0, !0), n) {
        c.setChecked(!1, !1);
        const h = function(v) {
          v.childNodes.forEach((g) => {
            g.isLeaf || g.setChecked(!1, !1), h(g);
          });
        };
        h(c);
      }
    }
  }
  setCheckedNodes(t, n = !1) {
    const l = this.key, o = {};
    t.forEach((a) => {
      o[(a || {})[l]] = !0;
    }), this._setCheckedKeys(l, n, o);
  }
  setCheckedKeys(t, n = !1) {
    this.defaultCheckedKeys = t;
    const l = this.key, o = {};
    t.forEach((a) => {
      o[a] = !0;
    }), this._setCheckedKeys(l, n, o);
  }
  setDefaultExpandedKeys(t) {
    t = t || [], this.defaultExpandedKeys = t, t.forEach((n) => {
      const l = this.getNode(n);
      l && l.expand(null, this.autoExpandParent);
    });
  }
  setChecked(t, n, l) {
    const o = this.getNode(t);
    o && o.setChecked(!!n, l);
  }
  getCurrentNode() {
    return this.currentNode;
  }
  setCurrentNode(t) {
    const n = this.currentNode;
    n && (n.isCurrent = !1), this.currentNode = t, this.currentNode.isCurrent = !0;
  }
  setUserCurrentNode(t, n = !0) {
    const l = t[this.key], o = this.nodesMap[l];
    this.setCurrentNode(o), n && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0);
  }
  setCurrentNodeKey(t, n = !0) {
    if (t == null) {
      this.currentNode && (this.currentNode.isCurrent = !1), this.currentNode = null;
      return;
    }
    const l = this.getNode(t);
    l && (this.setCurrentNode(l), n && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0));
  }
}
const h$ = F({
  name: "ElTreeNodeContent",
  props: {
    node: {
      type: Object,
      required: !0
    },
    renderContent: Function
  },
  setup(e) {
    const t = se("tree"), n = Oe("NodeInstance"), l = Oe("RootTree");
    return () => {
      const o = e.node, { data: a, store: r } = o;
      return e.renderContent ? e.renderContent(fe, { _self: n, node: o, data: a, store: r }) : l.ctx.slots.default ? l.ctx.slots.default({ node: o, data: a }) : fe("span", { class: t.be("node", "label") }, [o.label]);
    };
  }
});
var v$ = /* @__PURE__ */ de(h$, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node-content.vue"]]);
function Wc(e) {
  const t = Oe("TreeNodeMap", null), n = {
    treeNodeExpand: (l) => {
      e.node !== l && e.node.collapse();
    },
    children: []
  };
  return t && t.children.push(n), tt("TreeNodeMap", n), {
    broadcastExpanded: (l) => {
      if (!!e.accordion)
        for (const o of n.children)
          o.treeNodeExpand(l);
    }
  };
}
const jc = Symbol("dragEvents");
function m$({ props: e, ctx: t, el$: n, dropIndicator$: l, store: o }) {
  const a = se("tree"), r = N({
    showDropIndicator: !1,
    draggingNode: null,
    dropNode: null,
    allowDrop: !0,
    dropType: null
  });
  return tt(jc, {
    treeNodeDragStart: ({ event: p, treeNode: d }) => {
      if (typeof e.allowDrag == "function" && !e.allowDrag(d.node))
        return p.preventDefault(), !1;
      p.dataTransfer.effectAllowed = "move";
      try {
        p.dataTransfer.setData("text/plain", "");
      } catch {
      }
      r.value.draggingNode = d, t.emit("node-drag-start", d.node, p);
    },
    treeNodeDragOver: ({ event: p, treeNode: d }) => {
      const f = d, h = r.value.dropNode;
      h && h !== f && zt(h.$el, a.is("drop-inner"));
      const v = r.value.draggingNode;
      if (!v || !f)
        return;
      let m = !0, g = !0, w = !0, C = !0;
      typeof e.allowDrop == "function" && (m = e.allowDrop(v.node, f.node, "prev"), C = g = e.allowDrop(v.node, f.node, "inner"), w = e.allowDrop(v.node, f.node, "next")), p.dataTransfer.dropEffect = g || m || w ? "move" : "none", (m || g || w) && h !== f && (h && t.emit("node-drag-leave", v.node, h.node, p), t.emit("node-drag-enter", v.node, f.node, p)), (m || g || w) && (r.value.dropNode = f), f.node.nextSibling === v.node && (w = !1), f.node.previousSibling === v.node && (m = !1), f.node.contains(v.node, !1) && (g = !1), (v.node === f.node || v.node.contains(f.node)) && (m = !1, g = !1, w = !1);
      const y = f.$el.getBoundingClientRect(), b = n.value.getBoundingClientRect();
      let S;
      const T = m ? g ? 0.25 : w ? 0.45 : 1 : -1, O = w ? g ? 0.75 : m ? 0.55 : 0 : 1;
      let I = -9999;
      const R = p.clientY - y.top;
      R < y.height * T ? S = "before" : R > y.height * O ? S = "after" : g ? S = "inner" : S = "none";
      const B = f.$el.querySelector(`.${a.be("node", "expand-icon")}`).getBoundingClientRect(), D = l.value;
      S === "before" ? I = B.top - b.top : S === "after" && (I = B.bottom - b.top), D.style.top = `${I}px`, D.style.left = `${B.right - b.left}px`, S === "inner" ? yn(f.$el, a.is("drop-inner")) : zt(f.$el, a.is("drop-inner")), r.value.showDropIndicator = S === "before" || S === "after", r.value.allowDrop = r.value.showDropIndicator || C, r.value.dropType = S, t.emit("node-drag-over", v.node, f.node, p);
    },
    treeNodeDragEnd: (p) => {
      const { draggingNode: d, dropType: f, dropNode: h } = r.value;
      if (p.preventDefault(), p.dataTransfer.dropEffect = "move", d && h) {
        const v = { data: d.node.data };
        f !== "none" && d.node.remove(), f === "before" ? h.node.parent.insertBefore(v, h.node) : f === "after" ? h.node.parent.insertAfter(v, h.node) : f === "inner" && h.node.insertChild(v), f !== "none" && o.value.registerNode(v), zt(h.$el, a.is("drop-inner")), t.emit("node-drag-end", d.node, h.node, f, p), f !== "none" && t.emit("node-drop", d.node, h.node, f, p);
      }
      d && !h && t.emit("node-drag-end", d.node, null, f, p), r.value.showDropIndicator = !1, r.value.draggingNode = null, r.value.dropNode = null, r.value.allowDrop = !0;
    }
  }), {
    dragState: r
  };
}
const g$ = F({
  name: "ElTreeNode",
  components: {
    ElCollapseTransition: Si,
    ElCheckbox: Yt,
    NodeContent: v$,
    ElIcon: Se,
    Loading: wl
  },
  props: {
    node: {
      type: Un,
      default: () => ({})
    },
    props: {
      type: Object,
      default: () => ({})
    },
    accordion: Boolean,
    renderContent: Function,
    renderAfterExpand: Boolean,
    showCheckbox: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["node-expand"],
  setup(e, t) {
    const n = se("tree"), { broadcastExpanded: l } = Wc(e), o = Oe("RootTree"), a = N(!1), r = N(!1), i = N(null), u = N(null), c = N(null), p = Oe(jc), d = je();
    tt("NodeInstance", d), o || pt("Tree", "Can not find node's tree."), e.node.expanded && (a.value = !0, r.value = !0);
    const f = o.props.children || "children";
    ue(() => {
      const R = e.node.data[f];
      return R && [...R];
    }, () => {
      e.node.updateChildren();
    }), ue(() => e.node.indeterminate, (R) => {
      m(e.node.checked, R);
    }), ue(() => e.node.checked, (R) => {
      m(R, e.node.indeterminate);
    }), ue(() => e.node.expanded, (R) => {
      Ne(() => a.value = R), R && (r.value = !0);
    });
    const h = (R) => qa(o.props.nodeKey, R.data), v = (R) => {
      const B = e.props.class;
      if (!B)
        return {};
      let D;
      if (mt(B)) {
        const { data: A } = R;
        D = B(A, R);
      } else
        D = B;
      return Ue(D) ? { [D]: !0 } : D;
    }, m = (R, B) => {
      (i.value !== R || u.value !== B) && o.ctx.emit("check-change", e.node.data, R, B), i.value = R, u.value = B;
    }, g = (R) => {
      Gs(o.store, o.ctx.emit, () => o.store.value.setCurrentNode(e.node)), o.currentNode.value = e.node, o.props.expandOnClickNode && C(), o.props.checkOnClickNode && !e.node.disabled && y(null, {
        target: { checked: !e.node.checked }
      }), o.ctx.emit("node-click", e.node.data, e.node, d, R);
    }, w = (R) => {
      o.instance.vnode.props.onNodeContextmenu && (R.stopPropagation(), R.preventDefault()), o.ctx.emit("node-contextmenu", R, e.node.data, e.node, d);
    }, C = () => {
      e.node.isLeaf || (a.value ? (o.ctx.emit("node-collapse", e.node.data, e.node, d), e.node.collapse()) : (e.node.expand(), t.emit("node-expand", e.node.data, e.node, d)));
    }, y = (R, B) => {
      e.node.setChecked(B.target.checked, !o.props.checkStrictly), Ne(() => {
        const D = o.store.value;
        o.ctx.emit("check", e.node.data, {
          checkedNodes: D.getCheckedNodes(),
          checkedKeys: D.getCheckedKeys(),
          halfCheckedNodes: D.getHalfCheckedNodes(),
          halfCheckedKeys: D.getHalfCheckedKeys()
        });
      });
    };
    return {
      ns: n,
      node$: c,
      tree: o,
      expanded: a,
      childNodeRendered: r,
      oldChecked: i,
      oldIndeterminate: u,
      getNodeKey: h,
      getNodeClass: v,
      handleSelectChange: m,
      handleClick: g,
      handleContextMenu: w,
      handleExpandIconClick: C,
      handleCheckChange: y,
      handleChildNodeExpand: (R, B, D) => {
        l(B), o.ctx.emit("node-expand", R, B, D);
      },
      handleDragStart: (R) => {
        !o.props.draggable || p.treeNodeDragStart({ event: R, treeNode: e });
      },
      handleDragOver: (R) => {
        R.preventDefault(), o.props.draggable && p.treeNodeDragOver({
          event: R,
          treeNode: { $el: c.value, node: e.node }
        });
      },
      handleDrop: (R) => {
        R.preventDefault();
      },
      handleDragEnd: (R) => {
        !o.props.draggable || p.treeNodeDragEnd(R);
      },
      CaretRight: Ii
    };
  }
}), y$ = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"], b$ = ["aria-expanded"];
function C$(e, t, n, l, o, a) {
  const r = $e("el-icon"), i = $e("el-checkbox"), u = $e("loading"), c = $e("node-content"), p = $e("el-tree-node"), d = $e("el-collapse-transition");
  return qe((E(), _("div", {
    ref: "node$",
    class: $([
      e.ns.b("node"),
      e.ns.is("expanded", e.expanded),
      e.ns.is("current", e.node.isCurrent),
      e.ns.is("hidden", !e.node.visible),
      e.ns.is("focusable", !e.node.disabled),
      e.ns.is("checked", !e.node.disabled && e.node.checked),
      e.getNodeClass(e.node)
    ]),
    role: "treeitem",
    tabindex: "-1",
    "aria-expanded": e.expanded,
    "aria-disabled": e.node.disabled,
    "aria-checked": e.node.checked,
    draggable: e.tree.props.draggable,
    "data-key": e.getNodeKey(e.node),
    onClick: t[1] || (t[1] = Ae((...f) => e.handleClick && e.handleClick(...f), ["stop"])),
    onContextmenu: t[2] || (t[2] = (...f) => e.handleContextMenu && e.handleContextMenu(...f)),
    onDragstart: t[3] || (t[3] = Ae((...f) => e.handleDragStart && e.handleDragStart(...f), ["stop"])),
    onDragover: t[4] || (t[4] = Ae((...f) => e.handleDragOver && e.handleDragOver(...f), ["stop"])),
    onDragend: t[5] || (t[5] = Ae((...f) => e.handleDragEnd && e.handleDragEnd(...f), ["stop"])),
    onDrop: t[6] || (t[6] = Ae((...f) => e.handleDrop && e.handleDrop(...f), ["stop"]))
  }, [
    H("div", {
      class: $(e.ns.be("node", "content")),
      style: ye({ paddingLeft: (e.node.level - 1) * e.tree.props.indent + "px" })
    }, [
      e.tree.props.icon || e.CaretRight ? (E(), q(r, {
        key: 0,
        class: $([
          e.ns.be("node", "expand-icon"),
          e.ns.is("leaf", e.node.isLeaf),
          {
            expanded: !e.node.isLeaf && e.expanded
          }
        ]),
        onClick: Ae(e.handleExpandIconClick, ["stop"])
      }, {
        default: K(() => [
          (E(), q(Ge(e.tree.props.icon || e.CaretRight)))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : W("v-if", !0),
      e.showCheckbox ? (E(), q(i, {
        key: 1,
        "model-value": e.node.checked,
        indeterminate: e.node.indeterminate,
        disabled: !!e.node.disabled,
        onClick: t[0] || (t[0] = Ae(() => {
        }, ["stop"])),
        onChange: e.handleCheckChange
      }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : W("v-if", !0),
      e.node.loading ? (E(), q(r, {
        key: 2,
        class: $([e.ns.be("node", "loading-icon"), e.ns.is("loading")])
      }, {
        default: K(() => [
          x(u)
        ]),
        _: 1
      }, 8, ["class"])) : W("v-if", !0),
      x(c, {
        node: e.node,
        "render-content": e.renderContent
      }, null, 8, ["node", "render-content"])
    ], 6),
    x(d, null, {
      default: K(() => [
        !e.renderAfterExpand || e.childNodeRendered ? qe((E(), _("div", {
          key: 0,
          class: $(e.ns.be("node", "children")),
          role: "group",
          "aria-expanded": e.expanded
        }, [
          (E(!0), _(Re, null, Xe(e.node.childNodes, (f) => (E(), q(p, {
            key: e.getNodeKey(f),
            "render-content": e.renderContent,
            "render-after-expand": e.renderAfterExpand,
            "show-checkbox": e.showCheckbox,
            node: f,
            accordion: e.accordion,
            props: e.props,
            onNodeExpand: e.handleChildNodeExpand
          }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]))), 128))
        ], 10, b$)), [
          [at, e.expanded]
        ]) : W("v-if", !0)
      ]),
      _: 1
    })
  ], 42, y$)), [
    [at, e.node.visible]
  ]);
}
var w$ = /* @__PURE__ */ de(g$, [["render", C$], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node.vue"]]);
function k$({ el$: e }, t) {
  const n = se("tree"), l = ht([]), o = ht([]);
  We(() => {
    r();
  }), fa(() => {
    l.value = Array.from(e.value.querySelectorAll("[role=treeitem]")), o.value = Array.from(e.value.querySelectorAll("input[type=checkbox]"));
  }), ue(o, (i) => {
    i.forEach((u) => {
      u.setAttribute("tabindex", "-1");
    });
  }), Nt(e, "keydown", (i) => {
    const u = i.target;
    if (!u.className.includes(n.b("node")))
      return;
    const c = i.code;
    l.value = Array.from(e.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`));
    const p = l.value.indexOf(u);
    let d;
    if ([Ce.up, Ce.down].includes(c)) {
      if (i.preventDefault(), c === Ce.up) {
        d = p === -1 ? 0 : p !== 0 ? p - 1 : l.value.length - 1;
        const h = d;
        for (; !t.value.getNode(l.value[d].dataset.key).canFocus; ) {
          if (d--, d === h) {
            d = -1;
            break;
          }
          d < 0 && (d = l.value.length - 1);
        }
      } else {
        d = p === -1 ? 0 : p < l.value.length - 1 ? p + 1 : 0;
        const h = d;
        for (; !t.value.getNode(l.value[d].dataset.key).canFocus; ) {
          if (d++, d === h) {
            d = -1;
            break;
          }
          d >= l.value.length && (d = 0);
        }
      }
      d !== -1 && l.value[d].focus();
    }
    [Ce.left, Ce.right].includes(c) && (i.preventDefault(), u.click());
    const f = u.querySelector('[type="checkbox"]');
    [Ce.enter, Ce.space].includes(c) && f && (i.preventDefault(), f.click());
  });
  const r = () => {
    var i;
    l.value = Array.from(e.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`)), o.value = Array.from(e.value.querySelectorAll("input[type=checkbox]"));
    const u = e.value.querySelectorAll(`.${n.is("checked")}[role=treeitem]`);
    if (u.length) {
      u[0].setAttribute("tabindex", "0");
      return;
    }
    (i = l.value[0]) == null || i.setAttribute("tabindex", "0");
  };
}
const S$ = F({
  name: "ElTree",
  components: { ElTreeNode: w$ },
  props: {
    data: {
      type: Array,
      default: () => []
    },
    emptyText: {
      type: String
    },
    renderAfterExpand: {
      type: Boolean,
      default: !0
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: !0
    },
    checkOnClickNode: Boolean,
    checkDescendants: {
      type: Boolean,
      default: !1
    },
    autoExpandParent: {
      type: Boolean,
      default: !0
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    currentNodeKey: [String, Number],
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      default: !1
    },
    draggable: {
      type: Boolean,
      default: !1
    },
    allowDrag: Function,
    allowDrop: Function,
    props: {
      type: Object,
      default: () => ({
        children: "children",
        label: "label",
        disabled: "disabled"
      })
    },
    lazy: {
      type: Boolean,
      default: !1
    },
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: {
      type: Number,
      default: 18
    },
    icon: {
      type: ft
    }
  },
  emits: [
    "check-change",
    "current-change",
    "node-click",
    "node-contextmenu",
    "node-collapse",
    "node-expand",
    "check",
    "node-drag-start",
    "node-drag-end",
    "node-drop",
    "node-drag-leave",
    "node-drag-enter",
    "node-drag-over"
  ],
  setup(e, t) {
    const { t: n } = ot(), l = se("tree"), o = N(new p$({
      key: e.nodeKey,
      data: e.data,
      lazy: e.lazy,
      props: e.props,
      load: e.load,
      currentNodeKey: e.currentNodeKey,
      checkStrictly: e.checkStrictly,
      checkDescendants: e.checkDescendants,
      defaultCheckedKeys: e.defaultCheckedKeys,
      defaultExpandedKeys: e.defaultExpandedKeys,
      autoExpandParent: e.autoExpandParent,
      defaultExpandAll: e.defaultExpandAll,
      filterNodeMethod: e.filterNodeMethod
    }));
    o.value.initialize();
    const a = N(o.value.root), r = N(null), i = N(null), u = N(null), { broadcastExpanded: c } = Wc(e), { dragState: p } = m$({
      props: e,
      ctx: t,
      el$: i,
      dropIndicator$: u,
      store: o
    });
    k$({ el$: i }, o);
    const d = k(() => {
      const { childNodes: M } = a.value;
      return !M || M.length === 0 || M.every(({ visible: P }) => !P);
    });
    ue(() => e.currentNodeKey, (M) => {
      o.value.setCurrentNodeKey(M);
    }), ue(() => e.defaultCheckedKeys, (M) => {
      o.value.setDefaultCheckedKey(M);
    }), ue(() => e.defaultExpandedKeys, (M) => {
      o.value.setDefaultExpandedKeys(M);
    }), ue(() => e.data, (M) => {
      o.value.setData(M);
    }, { deep: !0 }), ue(() => e.checkStrictly, (M) => {
      o.value.checkStrictly = M;
    });
    const f = (M) => {
      if (!e.filterNodeMethod)
        throw new Error("[Tree] filterNodeMethod is required when filter");
      o.value.filter(M);
    }, h = (M) => qa(e.nodeKey, M.data), v = (M) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in getNodePath");
      const P = o.value.getNode(M);
      if (!P)
        return [];
      const L = [P.data];
      let U = P.parent;
      for (; U && U !== a.value; )
        L.push(U.data), U = U.parent;
      return L.reverse();
    }, m = (M, P) => o.value.getCheckedNodes(M, P), g = (M) => o.value.getCheckedKeys(M), w = () => {
      const M = o.value.getCurrentNode();
      return M ? M.data : null;
    }, C = () => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in getCurrentKey");
      const M = w();
      return M ? M[e.nodeKey] : null;
    }, y = (M, P) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedNodes");
      o.value.setCheckedNodes(M, P);
    }, b = (M, P) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedKeys");
      o.value.setCheckedKeys(M, P);
    }, S = (M, P, L) => {
      o.value.setChecked(M, P, L);
    }, T = () => o.value.getHalfCheckedNodes(), O = () => o.value.getHalfCheckedKeys(), I = (M, P = !0) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentNode");
      Gs(o, t.emit, () => o.value.setUserCurrentNode(M, P));
    }, R = (M, P = !0) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentKey");
      Gs(o, t.emit, () => o.value.setCurrentNodeKey(M, P));
    }, B = (M) => o.value.getNode(M), D = (M) => {
      o.value.remove(M);
    }, A = (M, P) => {
      o.value.append(M, P);
    }, z = (M, P) => {
      o.value.insertBefore(M, P);
    }, Z = (M, P) => {
      o.value.insertAfter(M, P);
    }, J = (M, P, L) => {
      c(P), t.emit("node-expand", M, P, L);
    }, V = (M, P) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in updateKeyChild");
      o.value.updateChildren(M, P);
    };
    return tt("RootTree", {
      ctx: t,
      props: e,
      store: o,
      root: a,
      currentNode: r,
      instance: je()
    }), tt(ra, void 0), {
      ns: l,
      store: o,
      root: a,
      currentNode: r,
      dragState: p,
      el$: i,
      dropIndicator$: u,
      isEmpty: d,
      filter: f,
      getNodeKey: h,
      getNodePath: v,
      getCheckedNodes: m,
      getCheckedKeys: g,
      getCurrentNode: w,
      getCurrentKey: C,
      setCheckedNodes: y,
      setCheckedKeys: b,
      setChecked: S,
      getHalfCheckedNodes: T,
      getHalfCheckedKeys: O,
      setCurrentNode: I,
      setCurrentKey: R,
      t: n,
      getNode: B,
      remove: D,
      append: A,
      insertBefore: z,
      insertAfter: Z,
      handleNodeExpand: J,
      updateKeyChildren: V
    };
  }
});
function E$(e, t, n, l, o, a) {
  var r;
  const i = $e("el-tree-node");
  return E(), _("div", {
    ref: "el$",
    class: $([
      e.ns.b(),
      e.ns.is("dragging", !!e.dragState.draggingNode),
      e.ns.is("drop-not-allow", !e.dragState.allowDrop),
      e.ns.is("drop-inner", e.dragState.dropType === "inner"),
      { [e.ns.m("highlight-current")]: e.highlightCurrent }
    ]),
    role: "tree"
  }, [
    (E(!0), _(Re, null, Xe(e.root.childNodes, (u) => (E(), q(i, {
      key: e.getNodeKey(u),
      node: u,
      props: e.props,
      accordion: e.accordion,
      "render-after-expand": e.renderAfterExpand,
      "show-checkbox": e.showCheckbox,
      "render-content": e.renderContent,
      onNodeExpand: e.handleNodeExpand
    }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]))), 128)),
    e.isEmpty ? (E(), _("div", {
      key: 0,
      class: $(e.ns.e("empty-block"))
    }, [
      H("span", {
        class: $(e.ns.e("empty-text"))
      }, ce((r = e.emptyText) != null ? r : e.t("el.tree.emptyText")), 3)
    ], 2)) : W("v-if", !0),
    qe(H("div", {
      ref: "dropIndicator$",
      class: $(e.ns.e("drop-indicator"))
    }, null, 2), [
      [at, e.dragState.showDropIndicator]
    ])
  ], 2);
}
var To = /* @__PURE__ */ de(S$, [["render", E$], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree.vue"]]);
To.install = (e) => {
  e.component(To.name, To);
};
const Fo = To, $$ = Fo, T$ = (e, { attrs: t }, {
  tree: n,
  key: l
}) => {
  const o = se("tree-select"), a = {
    ...$n(Ut(e), Object.keys(Gn.props)),
    ...t,
    valueKey: l,
    popperClass: k(() => {
      const r = [o.e("popper")];
      return e.popperClass && r.push(e.popperClass), r.join(" ");
    }),
    filterMethod: (r = "") => {
      e.filterMethod && e.filterMethod(r), Ne(() => {
        var i;
        (i = n.value) == null || i.filter(r);
      });
    },
    onVisibleChange: (r) => {
      var i;
      (i = t.onVisibleChange) == null || i.call(t, r), e.filterable && r && a.filterMethod();
    }
  };
  return a;
}, N$ = F({
  extends: Ro,
  setup(e, t) {
    const n = Ro.setup(e, t);
    delete n.selectOptionClick;
    const l = je().proxy;
    return Ne(() => {
      n.select.cachedOptions.get(l.value) || n.select.onOptionCreate(l);
    }), n;
  },
  methods: {
    selectOptionClick() {
      this.$el.parentElement.click();
    }
  }
});
function Xs(e) {
  return e || e === 0;
}
function Ga(e) {
  return Array.isArray(e) && e.length;
}
function hs(e) {
  return Array.isArray(e) ? e : Xs(e) ? [e] : [];
}
function No(e, t, n, l, o) {
  for (let a = 0; a < e.length; a++) {
    const r = e[a];
    if (t(r, a, e, o))
      return l ? l(r, a, e, o) : r;
    {
      const i = n(r);
      if (Ga(i)) {
        const u = No(i, t, n, l, r);
        if (u)
          return u;
      }
    }
  }
}
function Uc(e, t, n, l) {
  for (let o = 0; o < e.length; o++) {
    const a = e[o];
    t(a, o, e, l);
    const r = n(a);
    Ga(r) && Uc(r, t, n, a);
  }
}
const I$ = (e, { attrs: t, slots: n, emit: l }, {
  select: o,
  tree: a,
  key: r
}) => {
  ue(() => e.modelValue, () => {
    e.showCheckbox && Ne(() => {
      const d = a.value;
      d && !bn(d.getCheckedKeys(), hs(e.modelValue)) && d.setCheckedKeys(hs(e.modelValue));
    });
  }, {
    immediate: !0,
    deep: !0
  });
  const i = k(() => ({
    value: r.value,
    label: "label",
    children: "children",
    disabled: "disabled",
    isLeaf: "isLeaf",
    ...e.props
  })), u = (d, f) => {
    var h;
    const v = i.value[d];
    return mt(v) ? v(f, (h = a.value) == null ? void 0 : h.getNode(u("value", f))) : f[v];
  }, c = hs(e.modelValue).map((d) => No(e.data || [], (f) => u("value", f) === d, (f) => u("children", f), (f, h, v, m) => m && u("value", m))).filter((d) => Xs(d)), p = k(() => {
    if (!e.renderAfterExpand && !e.lazy)
      return [];
    const d = [];
    return Uc(e.data.concat(e.cacheData), (f) => {
      const h = u("value", f);
      d.push({
        value: h,
        currentLabel: u("label", f),
        isDisabled: u("disabled", f)
      });
    }, (f) => u("children", f)), d;
  });
  return {
    ...$n(Ut(e), Object.keys(Fo.props)),
    ...t,
    nodeKey: r,
    expandOnClickNode: k(() => !e.checkStrictly && e.expandOnClickNode),
    defaultExpandedKeys: k(() => e.defaultExpandedKeys ? e.defaultExpandedKeys.concat(c) : c),
    renderContent: (d, { node: f, data: h, store: v }) => d(N$, {
      value: u("value", h),
      label: u("label", h),
      disabled: u("disabled", h)
    }, e.renderContent ? () => e.renderContent(d, { node: f, data: h, store: v }) : n.default ? () => n.default({ node: f, data: h, store: v }) : void 0),
    filterNodeMethod: (d, f, h) => {
      var v;
      return e.filterNodeMethod ? e.filterNodeMethod(d, f, h) : d ? (v = u("label", f)) == null ? void 0 : v.includes(d) : !0;
    },
    onNodeClick: (d, f, h) => {
      var v, m, g;
      if ((v = t.onNodeClick) == null || v.call(t, d, f, h), !(e.showCheckbox && e.checkOnClickNode))
        if (!e.showCheckbox && (e.checkStrictly || f.isLeaf)) {
          if (!u("disabled", d)) {
            const w = (m = o.value) == null ? void 0 : m.options.get(u("value", d));
            (g = o.value) == null || g.handleOptionSelect(w, !0);
          }
        } else
          e.expandOnClickNode && h.proxy.handleExpandIconClick();
    },
    onCheck: (d, f) => {
      var h;
      (h = t.onCheck) == null || h.call(t, d, f);
      const v = u("value", d);
      if (e.checkStrictly)
        l(et, e.multiple ? f.checkedKeys : f.checkedKeys.includes(v) ? v : void 0);
      else if (e.multiple)
        l(et, a.value.getCheckedKeys(!0));
      else {
        const m = No([d], (C) => !Ga(u("children", C)) && !u("disabled", C), (C) => u("children", C)), g = m ? u("value", m) : void 0, w = Xs(e.modelValue) && !!No([d], (C) => u("value", C) === e.modelValue, (C) => u("children", C));
        l(et, g === e.modelValue || w ? void 0 : g);
      }
    },
    cacheOptions: p
  };
};
var M$ = F({
  props: {
    data: {
      type: Array,
      default: () => []
    }
  },
  setup(e) {
    const t = Oe(nf);
    return ue(() => e.data, () => {
      var n;
      e.data.forEach((o) => {
        t.cachedOptions.has(o.value) || t.cachedOptions.set(o.value, o);
      });
      const l = ((n = t.selectWrapper) == null ? void 0 : n.querySelectorAll("input")) || [];
      Array.from(l).includes(document.activeElement) || t.setSelected();
    }, { flush: "post", immediate: !0 }), () => {
    };
  }
});
const R$ = F({
  name: "ElTreeSelect",
  inheritAttrs: !1,
  props: {
    ...Gn.props,
    ...Fo.props,
    cacheData: {
      type: Array,
      default: () => []
    }
  },
  setup(e, t) {
    const { slots: n, expose: l } = t, o = N(), a = N(), r = k(() => e.nodeKey || e.valueKey || "value"), i = T$(e, t, { select: o, tree: a, key: r }), { cacheOptions: u, ...c } = I$(e, t, {
      select: o,
      tree: a,
      key: r
    }), p = ct({});
    return l(p), We(() => {
      Object.assign(p, {
        ...$n(a.value, [
          "filter",
          "updateKeyChildren",
          "getCheckedNodes",
          "setCheckedNodes",
          "getCheckedKeys",
          "setCheckedKeys",
          "setChecked",
          "getHalfCheckedNodes",
          "getHalfCheckedKeys",
          "getCurrentKey",
          "getCurrentNode",
          "setCurrentKey",
          "setCurrentNode",
          "getNode",
          "remove",
          "append",
          "insertBefore",
          "insertAfter"
        ]),
        ...$n(o.value, ["focus", "blur"])
      });
    }), () => fe(Gn, ct({
      ...i,
      ref: (d) => o.value = d
    }), {
      ...n,
      default: () => [
        fe(M$, { data: u.value }),
        fe(Fo, ct({
          ...c,
          ref: (d) => a.value = d
        }))
      ]
    });
  }
});
var Io = /* @__PURE__ */ de(R$, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-select/src/tree-select.vue"]]);
Io.install = (e) => {
  e.component(Io.name, Io);
};
const O$ = Io, P$ = O$, Ya = Symbol(), A$ = {
  key: -1,
  level: -1,
  data: {}
};
var Ml = /* @__PURE__ */ ((e) => (e.KEY = "id", e.LABEL = "label", e.CHILDREN = "children", e.DISABLED = "disabled", e))(Ml || {}), Zs = /* @__PURE__ */ ((e) => (e.ADD = "add", e.DELETE = "delete", e))(Zs || {});
const qc = {
  type: Number,
  default: 26
}, _$ = he({
  data: {
    type: j(Array),
    default: () => Et([])
  },
  emptyText: {
    type: String
  },
  height: {
    type: Number,
    default: 200
  },
  props: {
    type: j(Object),
    default: () => Et({
      children: "children",
      label: "label",
      disabled: "disabled",
      value: "id"
    })
  },
  highlightCurrent: {
    type: Boolean,
    default: !1
  },
  showCheckbox: {
    type: Boolean,
    default: !1
  },
  defaultCheckedKeys: {
    type: j(Array),
    default: () => Et([])
  },
  checkStrictly: {
    type: Boolean,
    default: !1
  },
  defaultExpandedKeys: {
    type: j(Array),
    default: () => Et([])
  },
  indent: {
    type: Number,
    default: 16
  },
  itemSize: qc,
  icon: {
    type: ft
  },
  expandOnClickNode: {
    type: Boolean,
    default: !0
  },
  checkOnClickNode: {
    type: Boolean,
    default: !1
  },
  currentNodeKey: {
    type: j([String, Number])
  },
  accordion: {
    type: Boolean,
    default: !1
  },
  filterMethod: {
    type: j(Function)
  },
  perfMode: {
    type: Boolean,
    default: !0
  }
}), L$ = he({
  node: {
    type: j(Object),
    default: () => Et(A$)
  },
  expanded: {
    type: Boolean,
    default: !1
  },
  checked: {
    type: Boolean,
    default: !1
  },
  indeterminate: {
    type: Boolean,
    default: !1
  },
  showCheckbox: {
    type: Boolean,
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  current: {
    type: Boolean,
    default: !1
  },
  hiddenExpandIcon: {
    type: Boolean,
    default: !1
  },
  itemSize: qc
}), V$ = he({
  node: {
    type: j(Object),
    required: !0
  }
}), Gc = "node-click", Yc = "node-expand", Xc = "node-collapse", Zc = "current-change", Jc = "check", Qc = "check-change", ed = "node-contextmenu", B$ = {
  [Gc]: (e, t, n) => e && t && n,
  [Yc]: (e, t) => e && t,
  [Xc]: (e, t) => e && t,
  [Zc]: (e, t) => e && t,
  [Jc]: (e, t) => e && t,
  [Qc]: (e, t) => e && typeof t == "boolean",
  [ed]: (e, t, n) => e && t && n
}, D$ = {
  click: (e, t) => !!(e && t),
  toggle: (e) => !!e,
  check: (e, t) => e && typeof t == "boolean"
};
function x$(e, t) {
  const n = N(/* @__PURE__ */ new Set()), l = N(/* @__PURE__ */ new Set()), { emit: o } = je();
  ue([() => t.value, () => e.defaultCheckedKeys], () => Ne(() => {
    C(e.defaultCheckedKeys);
  }), {
    immediate: !0
  });
  const a = () => {
    if (!t.value || !e.showCheckbox || e.checkStrictly)
      return;
    const { levelTreeNodeMap: y, maxLevel: b } = t.value, S = n.value, T = /* @__PURE__ */ new Set();
    for (let O = b - 1; O >= 1; --O) {
      const I = y.get(O);
      !I || I.forEach((R) => {
        const B = R.children;
        if (B) {
          let D = !0, A = !1;
          for (const z of B) {
            const Z = z.key;
            if (S.has(Z))
              A = !0;
            else if (T.has(Z)) {
              D = !1, A = !0;
              break;
            } else
              D = !1;
          }
          D ? S.add(R.key) : A ? (T.add(R.key), S.delete(R.key)) : (S.delete(R.key), T.delete(R.key));
        }
      });
    }
    l.value = T;
  }, r = (y) => n.value.has(y.key), i = (y) => l.value.has(y.key), u = (y, b, S = !0) => {
    const T = n.value, O = (I, R) => {
      T[R ? Zs.ADD : Zs.DELETE](I.key);
      const B = I.children;
      !e.checkStrictly && B && B.forEach((D) => {
        D.disabled || O(D, R);
      });
    };
    O(y, b), a(), S && c(y, b);
  }, c = (y, b) => {
    const { checkedNodes: S, checkedKeys: T } = v(), { halfCheckedNodes: O, halfCheckedKeys: I } = m();
    o(Jc, y.data, {
      checkedKeys: T,
      checkedNodes: S,
      halfCheckedKeys: I,
      halfCheckedNodes: O
    }), o(Qc, y.data, b);
  };
  function p(y = !1) {
    return v(y).checkedKeys;
  }
  function d(y = !1) {
    return v(y).checkedNodes;
  }
  function f() {
    return m().halfCheckedKeys;
  }
  function h() {
    return m().halfCheckedNodes;
  }
  function v(y = !1) {
    const b = [], S = [];
    if ((t == null ? void 0 : t.value) && e.showCheckbox) {
      const { treeNodeMap: T } = t.value;
      n.value.forEach((O) => {
        const I = T.get(O);
        I && (!y || y && I.isLeaf) && (S.push(O), b.push(I.data));
      });
    }
    return {
      checkedKeys: S,
      checkedNodes: b
    };
  }
  function m() {
    const y = [], b = [];
    if ((t == null ? void 0 : t.value) && e.showCheckbox) {
      const { treeNodeMap: S } = t.value;
      l.value.forEach((T) => {
        const O = S.get(T);
        O && (b.push(T), y.push(O.data));
      });
    }
    return {
      halfCheckedNodes: y,
      halfCheckedKeys: b
    };
  }
  function g(y) {
    n.value.clear(), l.value.clear(), C(y);
  }
  function w(y, b) {
    if ((t == null ? void 0 : t.value) && e.showCheckbox) {
      const S = t.value.treeNodeMap.get(y);
      S && u(S, b, !1);
    }
  }
  function C(y) {
    if (t != null && t.value) {
      const { treeNodeMap: b } = t.value;
      if (e.showCheckbox && b && y)
        for (const S of y) {
          const T = b.get(S);
          T && !r(T) && u(T, !0, !1);
        }
    }
  }
  return {
    updateCheckedKeys: a,
    toggleCheckbox: u,
    isChecked: r,
    isIndeterminate: i,
    getCheckedKeys: p,
    getCheckedNodes: d,
    getHalfCheckedKeys: f,
    getHalfCheckedNodes: h,
    setChecked: w,
    setCheckedKeys: g
  };
}
function F$(e, t) {
  const n = N(/* @__PURE__ */ new Set([])), l = N(/* @__PURE__ */ new Set([])), o = k(() => mt(e.filterMethod));
  function a(i) {
    var u;
    if (!o.value)
      return;
    const c = /* @__PURE__ */ new Set(), p = l.value, d = n.value, f = [], h = ((u = t.value) == null ? void 0 : u.treeNodes) || [], v = e.filterMethod;
    d.clear();
    function m(g) {
      g.forEach((w) => {
        f.push(w), v != null && v(i, w.data) ? f.forEach((y) => {
          c.add(y.key);
        }) : w.isLeaf && d.add(w.key);
        const C = w.children;
        if (C && m(C), !w.isLeaf) {
          if (!c.has(w.key))
            d.add(w.key);
          else if (C) {
            let y = !0;
            for (const b of C)
              if (!d.has(b.key)) {
                y = !1;
                break;
              }
            y ? p.add(w.key) : p.delete(w.key);
          }
        }
        f.pop();
      });
    }
    return m(h), c;
  }
  function r(i) {
    return l.value.has(i.key);
  }
  return {
    hiddenExpandIconKeySet: l,
    hiddenNodeKeySet: n,
    doFilter: a,
    isForceHiddenExpandIcon: r
  };
}
function H$(e, t) {
  const n = N(new Set(e.defaultExpandedKeys)), l = N(), o = ht();
  ue(() => e.currentNodeKey, (G) => {
    l.value = G;
  }, {
    immediate: !0
  }), ue(() => e.data, (G) => {
    te(G);
  }, {
    immediate: !0
  });
  const {
    isIndeterminate: a,
    isChecked: r,
    toggleCheckbox: i,
    getCheckedKeys: u,
    getCheckedNodes: c,
    getHalfCheckedKeys: p,
    getHalfCheckedNodes: d,
    setChecked: f,
    setCheckedKeys: h
  } = x$(e, o), { doFilter: v, hiddenNodeKeySet: m, isForceHiddenExpandIcon: g } = F$(e, o), w = k(() => {
    var G;
    return ((G = e.props) == null ? void 0 : G.value) || Ml.KEY;
  }), C = k(() => {
    var G;
    return ((G = e.props) == null ? void 0 : G.children) || Ml.CHILDREN;
  }), y = k(() => {
    var G;
    return ((G = e.props) == null ? void 0 : G.disabled) || Ml.DISABLED;
  }), b = k(() => {
    var G;
    return ((G = e.props) == null ? void 0 : G.label) || Ml.LABEL;
  }), S = k(() => {
    const G = n.value, Q = m.value, ie = [], Ee = o.value && o.value.treeNodes || [];
    function De() {
      const Ve = [];
      for (let Fe = Ee.length - 1; Fe >= 0; --Fe)
        Ve.push(Ee[Fe]);
      for (; Ve.length; ) {
        const Fe = Ve.pop();
        if (!!Fe && (Q.has(Fe.key) || ie.push(Fe), G.has(Fe.key))) {
          const ze = Fe.children;
          if (ze) {
            const it = ze.length;
            for (let be = it - 1; be >= 0; --be)
              Ve.push(ze[be]);
          }
        }
      }
    }
    return De(), ie;
  }), T = k(() => S.value.length > 0);
  function O(G) {
    const Q = /* @__PURE__ */ new Map(), ie = /* @__PURE__ */ new Map();
    let Ee = 1;
    function De(Fe, ze = 1, it = void 0) {
      var be;
      const Te = [];
      for (const we of Fe) {
        const _e = B(we), Ie = {
          level: ze,
          key: _e,
          data: we
        };
        Ie.label = A(we), Ie.parent = it;
        const Le = R(we);
        Ie.disabled = D(we), Ie.isLeaf = !Le || Le.length === 0, Le && Le.length && (Ie.children = De(Le, ze + 1, Ie)), Te.push(Ie), Q.set(_e, Ie), ie.has(ze) || ie.set(ze, []), (be = ie.get(ze)) == null || be.push(Ie);
      }
      return ze > Ee && (Ee = ze), Te;
    }
    const Ve = De(G);
    return {
      treeNodeMap: Q,
      levelTreeNodeMap: ie,
      maxLevel: Ee,
      treeNodes: Ve
    };
  }
  function I(G) {
    const Q = v(G);
    Q && (n.value = Q);
  }
  function R(G) {
    return G[C.value];
  }
  function B(G) {
    return G ? G[w.value] : "";
  }
  function D(G) {
    return G[y.value];
  }
  function A(G) {
    return G[b.value];
  }
  function z(G) {
    n.value.has(G.key) ? L(G) : P(G);
  }
  function Z(G) {
    n.value = new Set(G);
  }
  function J(G, Q) {
    t(Gc, G.data, G, Q), V(G), e.expandOnClickNode && z(G), e.showCheckbox && e.checkOnClickNode && !G.disabled && i(G, !r(G), !0);
  }
  function V(G) {
    le(G) || (l.value = G.key, t(Zc, G.data, G));
  }
  function M(G, Q) {
    i(G, Q);
  }
  function P(G) {
    const Q = n.value;
    if (o.value && e.accordion) {
      const { treeNodeMap: ie } = o.value;
      Q.forEach((Ee) => {
        const De = ie.get(Ee);
        G && G.level === (De == null ? void 0 : De.level) && Q.delete(Ee);
      });
    }
    Q.add(G.key), t(Yc, G.data, G);
  }
  function L(G) {
    n.value.delete(G.key), t(Xc, G.data, G);
  }
  function U(G) {
    return n.value.has(G.key);
  }
  function oe(G) {
    return !!G.disabled;
  }
  function le(G) {
    const Q = l.value;
    return !!Q && Q === G.key;
  }
  function ee() {
    var G, Q;
    if (!!l.value)
      return (Q = (G = o.value) == null ? void 0 : G.treeNodeMap.get(l.value)) == null ? void 0 : Q.data;
  }
  function pe() {
    return l.value;
  }
  function ge(G) {
    l.value = G;
  }
  function te(G) {
    Ne(() => o.value = O(G));
  }
  function ve(G) {
    var Q;
    const ie = Ct(G) ? B(G) : G;
    return (Q = o.value) == null ? void 0 : Q.treeNodeMap.get(ie);
  }
  return {
    tree: o,
    flattenTree: S,
    isNotEmpty: T,
    getKey: B,
    getChildren: R,
    toggleExpand: z,
    toggleCheckbox: i,
    isExpanded: U,
    isChecked: r,
    isIndeterminate: a,
    isDisabled: oe,
    isCurrent: le,
    isForceHiddenExpandIcon: g,
    handleNodeClick: J,
    handleNodeCheck: M,
    getCurrentNode: ee,
    getCurrentKey: pe,
    setCurrentKey: ge,
    getCheckedKeys: u,
    getCheckedNodes: c,
    getHalfCheckedKeys: p,
    getHalfCheckedNodes: d,
    setChecked: f,
    setCheckedKeys: h,
    filter: I,
    setData: te,
    getNode: ve,
    expandNode: P,
    collapseNode: L,
    setExpandedKeys: Z
  };
}
var z$ = F({
  name: "ElTreeNodeContent",
  props: V$,
  setup(e) {
    const t = Oe(Ya), n = se("tree");
    return () => {
      const l = e.node, { data: o } = l;
      return t != null && t.ctx.slots.default ? t.ctx.slots.default({ node: l, data: o }) : fe("span", { class: n.be("node", "label") }, [l == null ? void 0 : l.label]);
    };
  }
});
const K$ = ["aria-expanded", "aria-disabled", "aria-checked", "data-key", "onClick"], W$ = F({
  name: "ElTreeNode"
}), j$ = /* @__PURE__ */ F({
  ...W$,
  props: L$,
  emits: D$,
  setup(e, { emit: t }) {
    const n = e, l = Oe(Ya), o = se("tree"), a = k(() => {
      var d;
      return (d = l == null ? void 0 : l.props.indent) != null ? d : 16;
    }), r = k(() => {
      var d;
      return (d = l == null ? void 0 : l.props.icon) != null ? d : Ii;
    }), i = (d) => {
      t("click", n.node, d);
    }, u = () => {
      t("toggle", n.node);
    }, c = (d) => {
      t("check", n.node, d);
    }, p = (d) => {
      var f, h, v, m;
      (v = (h = (f = l == null ? void 0 : l.instance) == null ? void 0 : f.vnode) == null ? void 0 : h.props) != null && v.onNodeContextmenu && (d.stopPropagation(), d.preventDefault()), l == null || l.ctx.emit(ed, d, (m = n.node) == null ? void 0 : m.data, n.node);
    };
    return (d, f) => {
      var h, v, m;
      return E(), _("div", {
        ref: "node$",
        class: $([
          s(o).b("node"),
          s(o).is("expanded", d.expanded),
          s(o).is("current", d.current),
          s(o).is("focusable", !d.disabled),
          s(o).is("checked", !d.disabled && d.checked)
        ]),
        role: "treeitem",
        tabindex: "-1",
        "aria-expanded": d.expanded,
        "aria-disabled": d.disabled,
        "aria-checked": d.checked,
        "data-key": (h = d.node) == null ? void 0 : h.key,
        onClick: Ae(i, ["stop"]),
        onContextmenu: p
      }, [
        H("div", {
          class: $(s(o).be("node", "content")),
          style: ye({
            paddingLeft: `${(d.node.level - 1) * s(a)}px`,
            height: d.itemSize + "px"
          })
        }, [
          s(r) ? (E(), q(s(Se), {
            key: 0,
            class: $([
              s(o).is("leaf", !!((v = d.node) != null && v.isLeaf)),
              s(o).is("hidden", d.hiddenExpandIcon),
              {
                expanded: !((m = d.node) != null && m.isLeaf) && d.expanded
              },
              s(o).be("node", "expand-icon")
            ]),
            onClick: Ae(u, ["stop"])
          }, {
            default: K(() => [
              (E(), q(Ge(s(r))))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : W("v-if", !0),
          d.showCheckbox ? (E(), q(s(Yt), {
            key: 1,
            "model-value": d.checked,
            indeterminate: d.indeterminate,
            disabled: d.disabled,
            onChange: c,
            onClick: f[0] || (f[0] = Ae(() => {
            }, ["stop"]))
          }, null, 8, ["model-value", "indeterminate", "disabled"])) : W("v-if", !0),
          x(s(z$), { node: d.node }, null, 8, ["node"])
        ], 6)
      ], 42, K$);
    };
  }
});
var U$ = /* @__PURE__ */ de(j$, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree-node.vue"]]);
const q$ = F({
  name: "ElTreeV2"
}), G$ = /* @__PURE__ */ F({
  ...q$,
  props: _$,
  emits: B$,
  setup(e, { expose: t, emit: n }) {
    const l = e, o = kn(), a = k(() => l.itemSize);
    tt(Ya, {
      ctx: {
        emit: n,
        slots: o
      },
      props: l,
      instance: je()
    }), tt(ra, void 0);
    const { t: r } = ot(), i = se("tree"), {
      flattenTree: u,
      isNotEmpty: c,
      toggleExpand: p,
      isExpanded: d,
      isIndeterminate: f,
      isChecked: h,
      isDisabled: v,
      isCurrent: m,
      isForceHiddenExpandIcon: g,
      handleNodeClick: w,
      handleNodeCheck: C,
      toggleCheckbox: y,
      getCurrentNode: b,
      getCurrentKey: S,
      setCurrentKey: T,
      getCheckedKeys: O,
      getCheckedNodes: I,
      getHalfCheckedKeys: R,
      getHalfCheckedNodes: B,
      setChecked: D,
      setCheckedKeys: A,
      filter: z,
      setData: Z,
      getNode: J,
      expandNode: V,
      collapseNode: M,
      setExpandedKeys: P
    } = H$(l, n);
    return t({
      toggleCheckbox: y,
      getCurrentNode: b,
      getCurrentKey: S,
      setCurrentKey: T,
      getCheckedKeys: O,
      getCheckedNodes: I,
      getHalfCheckedKeys: R,
      getHalfCheckedNodes: B,
      setChecked: D,
      setCheckedKeys: A,
      filter: z,
      setData: Z,
      getNode: J,
      expandNode: V,
      collapseNode: M,
      setExpandedKeys: P
    }), (L, U) => {
      var oe;
      return E(), _("div", {
        class: $([s(i).b(), { [s(i).m("highlight-current")]: L.highlightCurrent }]),
        role: "tree"
      }, [
        s(c) ? (E(), q(s(uc), {
          key: 0,
          "class-name": s(i).b("virtual-list"),
          data: s(u),
          total: s(u).length,
          height: L.height,
          "item-size": s(a),
          "perf-mode": L.perfMode
        }, {
          default: K(({ data: le, index: ee, style: pe }) => [
            (E(), q(U$, {
              key: le[ee].key,
              style: ye(pe),
              node: le[ee],
              expanded: s(d)(le[ee]),
              "show-checkbox": L.showCheckbox,
              checked: s(h)(le[ee]),
              indeterminate: s(f)(le[ee]),
              "item-size": s(a),
              disabled: s(v)(le[ee]),
              current: s(m)(le[ee]),
              "hidden-expand-icon": s(g)(le[ee]),
              onClick: s(w),
              onToggle: s(p),
              onCheck: s(C)
            }, null, 8, ["style", "node", "expanded", "show-checkbox", "checked", "indeterminate", "item-size", "disabled", "current", "hidden-expand-icon", "onClick", "onToggle", "onCheck"]))
          ]),
          _: 1
        }, 8, ["class-name", "data", "total", "height", "item-size", "perf-mode"])) : (E(), _("div", {
          key: 1,
          class: $(s(i).e("empty-block"))
        }, [
          H("span", {
            class: $(s(i).e("empty-text"))
          }, ce((oe = L.emptyText) != null ? oe : s(r)("el.tree.emptyText")), 3)
        ], 2))
      ], 2);
    };
  }
});
var Y$ = /* @__PURE__ */ de(G$, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree.vue"]]);
const X$ = xe(Y$), td = Symbol("uploadContextKey"), Z$ = "ElUpload";
class J$ extends Error {
  constructor(t, n, l, o) {
    super(t), this.name = "UploadAjaxError", this.status = n, this.method = l, this.url = o;
  }
}
function ai(e, t, n) {
  let l;
  return n.response ? l = `${n.response.error || n.response}` : n.responseText ? l = `${n.responseText}` : l = `fail to ${t.method} ${e} ${n.status}`, new J$(l, n.status, t.method, e);
}
function Q$(e) {
  const t = e.responseText || e.response;
  if (!t)
    return t;
  try {
    return JSON.parse(t);
  } catch {
    return t;
  }
}
const eT = (e) => {
  typeof XMLHttpRequest > "u" && wt(Z$, "XMLHttpRequest is undefined");
  const t = new XMLHttpRequest(), n = e.action;
  t.upload && t.upload.addEventListener("progress", (a) => {
    const r = a;
    r.percent = a.total > 0 ? a.loaded / a.total * 100 : 0, e.onProgress(r);
  });
  const l = new FormData();
  if (e.data)
    for (const [a, r] of Object.entries(e.data))
      Array.isArray(r) ? l.append(a, ...r) : l.append(a, r);
  l.append(e.filename, e.file, e.file.name), t.addEventListener("error", () => {
    e.onError(ai(n, e, t));
  }), t.addEventListener("load", () => {
    if (t.status < 200 || t.status >= 300)
      return e.onError(ai(n, e, t));
    e.onSuccess(Q$(t));
  }), t.open(e.method, n, !0), e.withCredentials && "withCredentials" in t && (t.withCredentials = !0);
  const o = e.headers || {};
  if (o instanceof Headers)
    o.forEach((a, r) => t.setRequestHeader(r, a));
  else
    for (const [a, r] of Object.entries(o))
      un(r) || t.setRequestHeader(a, String(r));
  return t.send(l), t;
}, nd = ["text", "picture", "picture-card"];
let tT = 1;
const Js = () => Date.now() + tT++, ld = he({
  action: {
    type: String,
    default: "#"
  },
  headers: {
    type: j(Object)
  },
  method: {
    type: String,
    default: "post"
  },
  data: {
    type: Object,
    default: () => Et({})
  },
  multiple: {
    type: Boolean,
    default: !1
  },
  name: {
    type: String,
    default: "file"
  },
  drag: {
    type: Boolean,
    default: !1
  },
  withCredentials: Boolean,
  showFileList: {
    type: Boolean,
    default: !0
  },
  accept: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    default: "select"
  },
  fileList: {
    type: j(Array),
    default: () => Et([])
  },
  autoUpload: {
    type: Boolean,
    default: !0
  },
  listType: {
    type: String,
    values: nd,
    default: "text"
  },
  httpRequest: {
    type: j(Function),
    default: eT
  },
  disabled: Boolean,
  limit: Number
}), nT = he({
  ...ld,
  beforeUpload: {
    type: j(Function),
    default: bt
  },
  beforeRemove: {
    type: j(Function)
  },
  onRemove: {
    type: j(Function),
    default: bt
  },
  onChange: {
    type: j(Function),
    default: bt
  },
  onPreview: {
    type: j(Function),
    default: bt
  },
  onSuccess: {
    type: j(Function),
    default: bt
  },
  onProgress: {
    type: j(Function),
    default: bt
  },
  onError: {
    type: j(Function),
    default: bt
  },
  onExceed: {
    type: j(Function),
    default: bt
  }
}), lT = he({
  files: {
    type: j(Array),
    default: () => Et([])
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  handlePreview: {
    type: j(Function),
    default: bt
  },
  listType: {
    type: String,
    values: nd,
    default: "text"
  }
}), oT = {
  remove: (e) => !!e
}, sT = ["onKeydown"], aT = ["src"], rT = ["onClick"], iT = ["onClick"], uT = ["onClick"], cT = F({
  name: "ElUploadList"
}), dT = /* @__PURE__ */ F({
  ...cT,
  props: lT,
  emits: oT,
  setup(e, { emit: t }) {
    const { t: n } = ot(), l = se("upload"), o = se("icon"), a = se("list"), r = Pn(), i = N(!1), u = (c) => {
      t("remove", c);
    };
    return (c, p) => (E(), q(Nf, {
      tag: "ul",
      class: $([
        s(l).b("list"),
        s(l).bm("list", c.listType),
        s(l).is("disabled", s(r))
      ]),
      name: s(a).b()
    }, {
      default: K(() => [
        (E(!0), _(Re, null, Xe(c.files, (d) => (E(), _("li", {
          key: d.uid || d.name,
          class: $([
            s(l).be("list", "item"),
            s(l).is(d.status),
            { focusing: i.value }
          ]),
          tabindex: "0",
          onKeydown: ut((f) => !s(r) && u(d), ["delete"]),
          onFocus: p[0] || (p[0] = (f) => i.value = !0),
          onBlur: p[1] || (p[1] = (f) => i.value = !1),
          onClick: p[2] || (p[2] = (f) => i.value = !1)
        }, [
          ne(c.$slots, "default", { file: d }, () => [
            c.listType === "picture" || d.status !== "uploading" && c.listType === "picture-card" ? (E(), _("img", {
              key: 0,
              class: $(s(l).be("list", "item-thumbnail")),
              src: d.url,
              alt: ""
            }, null, 10, aT)) : W("v-if", !0),
            d.status === "uploading" || c.listType !== "picture-card" ? (E(), _("div", {
              key: 1,
              class: $(s(l).be("list", "item-info"))
            }, [
              H("a", {
                class: $(s(l).be("list", "item-name")),
                onClick: Ae((f) => c.handlePreview(d), ["prevent"])
              }, [
                x(s(Se), {
                  class: $(s(o).m("document"))
                }, {
                  default: K(() => [
                    x(s(lf))
                  ]),
                  _: 1
                }, 8, ["class"]),
                H("span", {
                  class: $(s(l).be("list", "item-file-name"))
                }, ce(d.name), 3)
              ], 10, rT),
              d.status === "uploading" ? (E(), q(s(ec), {
                key: 0,
                type: c.listType === "picture-card" ? "circle" : "line",
                "stroke-width": c.listType === "picture-card" ? 6 : 2,
                percentage: Number(d.percentage),
                style: ye(c.listType === "picture-card" ? "" : "margin-top: 0.5rem")
              }, null, 8, ["type", "stroke-width", "percentage", "style"])) : W("v-if", !0)
            ], 2)) : W("v-if", !0),
            H("label", {
              class: $(s(l).be("list", "item-status-label"))
            }, [
              c.listType === "text" ? (E(), q(s(Se), {
                key: 0,
                class: $([s(o).m("upload-success"), s(o).m("circle-check")])
              }, {
                default: K(() => [
                  x(s($i))
                ]),
                _: 1
              }, 8, ["class"])) : ["picture-card", "picture"].includes(c.listType) ? (E(), q(s(Se), {
                key: 1,
                class: $([s(o).m("upload-success"), s(o).m("check")])
              }, {
                default: K(() => [
                  x(s(Xl))
                ]),
                _: 1
              }, 8, ["class"])) : W("v-if", !0)
            ], 2),
            s(r) ? W("v-if", !0) : (E(), q(s(Se), {
              key: 2,
              class: $(s(o).m("close")),
              onClick: (f) => u(d)
            }, {
              default: K(() => [
                x(s(Sl))
              ]),
              _: 2
            }, 1032, ["class", "onClick"])),
            W(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
            W(" This is a bug which needs to be fixed "),
            W(" TODO: Fix the incorrect navigation interaction "),
            s(r) ? W("v-if", !0) : (E(), _("i", {
              key: 3,
              class: $(s(o).m("close-tip"))
            }, ce(s(n)("el.upload.deleteTip")), 3)),
            c.listType === "picture-card" ? (E(), _("span", {
              key: 4,
              class: $(s(l).be("list", "item-actions"))
            }, [
              H("span", {
                class: $(s(l).be("list", "item-preview")),
                onClick: (f) => c.handlePreview(d)
              }, [
                x(s(Se), {
                  class: $(s(o).m("zoom-in"))
                }, {
                  default: K(() => [
                    x(s(ki))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, iT),
              s(r) ? W("v-if", !0) : (E(), _("span", {
                key: 0,
                class: $(s(l).be("list", "item-delete")),
                onClick: (f) => u(d)
              }, [
                x(s(Se), {
                  class: $(s(o).m("delete"))
                }, {
                  default: K(() => [
                    x(s(of))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, uT))
            ], 2)) : W("v-if", !0)
          ])
        ], 42, sT))), 128)),
        ne(c.$slots, "append")
      ]),
      _: 3
    }, 8, ["class", "name"]));
  }
});
var ri = /* @__PURE__ */ de(dT, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-list.vue"]]);
const fT = he({
  disabled: {
    type: Boolean,
    default: !1
  }
}), pT = {
  file: (e) => Je(e)
}, hT = ["onDrop", "onDragover"], od = "ElUploadDrag", vT = F({
  name: od
}), mT = /* @__PURE__ */ F({
  ...vT,
  props: fT,
  emits: pT,
  setup(e, { emit: t }) {
    const n = Oe(td);
    n || wt(od, "usage: <el-upload><el-upload-dragger /></el-upload>");
    const l = se("upload"), o = N(!1), a = Pn(), r = (u) => {
      if (a.value)
        return;
      o.value = !1, u.stopPropagation();
      const c = Array.from(u.dataTransfer.files), p = n.accept.value;
      if (!p) {
        t("file", c);
        return;
      }
      const d = c.filter((f) => {
        const { type: h, name: v } = f, m = v.includes(".") ? `.${v.split(".").pop()}` : "", g = h.replace(/\/.*$/, "");
        return p.split(",").map((w) => w.trim()).filter((w) => w).some((w) => w.startsWith(".") ? m === w : /\/\*$/.test(w) ? g === w.replace(/\/\*$/, "") : /^[^/]+\/[^/]+$/.test(w) ? h === w : !1);
      });
      t("file", d);
    }, i = () => {
      a.value || (o.value = !0);
    };
    return (u, c) => (E(), _("div", {
      class: $([s(l).b("dragger"), s(l).is("dragover", o.value)]),
      onDrop: Ae(r, ["prevent"]),
      onDragover: Ae(i, ["prevent"]),
      onDragleave: c[0] || (c[0] = Ae((p) => o.value = !1, ["prevent"]))
    }, [
      ne(u.$slots, "default")
    ], 42, hT));
  }
});
var gT = /* @__PURE__ */ de(mT, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-dragger.vue"]]);
const yT = he({
  ...ld,
  beforeUpload: {
    type: j(Function),
    default: bt
  },
  onRemove: {
    type: j(Function),
    default: bt
  },
  onStart: {
    type: j(Function),
    default: bt
  },
  onSuccess: {
    type: j(Function),
    default: bt
  },
  onProgress: {
    type: j(Function),
    default: bt
  },
  onError: {
    type: j(Function),
    default: bt
  },
  onExceed: {
    type: j(Function),
    default: bt
  }
}), bT = ["onKeydown"], CT = ["name", "multiple", "accept"], wT = F({
  name: "ElUploadContent",
  inheritAttrs: !1
}), kT = /* @__PURE__ */ F({
  ...wT,
  props: yT,
  setup(e, { expose: t }) {
    const n = e, l = se("upload"), o = Pn(), a = ht({}), r = ht(), i = (v) => {
      if (v.length === 0)
        return;
      const { autoUpload: m, limit: g, fileList: w, multiple: C, onStart: y, onExceed: b } = n;
      if (g && w.length + v.length > g) {
        b(v, w);
        return;
      }
      C || (v = v.slice(0, 1));
      for (const S of v) {
        const T = S;
        T.uid = Js(), y(T), m && u(T);
      }
    }, u = async (v) => {
      if (r.value.value = "", !n.beforeUpload)
        return c(v);
      let m, g = {};
      try {
        const C = n.beforeUpload(v);
        g = Ct(n.data) ? va(n.data) : n.data, m = await C;
      } catch {
        m = !1;
      }
      if (m === !1) {
        n.onRemove(v);
        return;
      }
      let w = v;
      m instanceof Blob && (m instanceof File ? w = m : w = new File([m], v.name, {
        type: v.type
      })), c(Object.assign(w, {
        uid: v.uid
      }), g);
    }, c = (v, m) => {
      const {
        headers: g,
        data: w,
        method: C,
        withCredentials: y,
        name: b,
        action: S,
        onProgress: T,
        onSuccess: O,
        onError: I,
        httpRequest: R
      } = n, { uid: B } = v, D = {
        headers: g || {},
        withCredentials: y,
        file: v,
        data: m != null ? m : w,
        method: C,
        filename: b,
        action: S,
        onProgress: (z) => {
          T(z, v);
        },
        onSuccess: (z) => {
          O(z, v), delete a.value[B];
        },
        onError: (z) => {
          I(z, v), delete a.value[B];
        }
      }, A = R(D);
      a.value[B] = A, A instanceof Promise && A.then(D.onSuccess, D.onError);
    }, p = (v) => {
      const m = v.target.files;
      !m || i(Array.from(m));
    }, d = () => {
      o.value || (r.value.value = "", r.value.click());
    }, f = () => {
      d();
    };
    return t({
      abort: (v) => {
        sf(a.value).filter(v ? ([g]) => String(v.uid) === g : () => !0).forEach(([g, w]) => {
          w instanceof XMLHttpRequest && w.abort(), delete a.value[g];
        });
      },
      upload: u
    }), (v, m) => (E(), _("div", {
      class: $([s(l).b(), s(l).m(v.listType), s(l).is("drag", v.drag)]),
      tabindex: "0",
      onClick: d,
      onKeydown: ut(Ae(f, ["self"]), ["enter", "space"])
    }, [
      v.drag ? (E(), q(gT, {
        key: 0,
        disabled: s(o),
        onFile: i
      }, {
        default: K(() => [
          ne(v.$slots, "default")
        ]),
        _: 3
      }, 8, ["disabled"])) : ne(v.$slots, "default", { key: 1 }),
      H("input", {
        ref_key: "inputRef",
        ref: r,
        class: $(s(l).e("input")),
        name: v.name,
        multiple: v.multiple,
        accept: v.accept,
        type: "file",
        onChange: p,
        onClick: m[0] || (m[0] = Ae(() => {
        }, ["stop"]))
      }, null, 42, CT)
    ], 42, bT));
  }
});
var ii = /* @__PURE__ */ de(kT, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-content.vue"]]);
const ui = "ElUpload", ST = (e) => {
  var t;
  (t = e.url) != null && t.startsWith("blob:") && URL.revokeObjectURL(e.url);
}, ET = (e, t) => {
  const n = af(e, "fileList", void 0, { passive: !0 }), l = (f) => n.value.find((h) => h.uid === f.uid);
  function o(f) {
    var h;
    (h = t.value) == null || h.abort(f);
  }
  function a(f = ["ready", "uploading", "success", "fail"]) {
    n.value = n.value.filter((h) => !f.includes(h.status));
  }
  const r = (f, h) => {
    const v = l(h);
    !v || (console.error(f), v.status = "fail", n.value.splice(n.value.indexOf(v), 1), e.onError(f, v, n.value), e.onChange(v, n.value));
  }, i = (f, h) => {
    const v = l(h);
    !v || (e.onProgress(f, v, n.value), v.status = "uploading", v.percentage = Math.round(f.percent));
  }, u = (f, h) => {
    const v = l(h);
    !v || (v.status = "success", v.response = f, e.onSuccess(f, v, n.value), e.onChange(v, n.value));
  }, c = (f) => {
    un(f.uid) && (f.uid = Js());
    const h = {
      name: f.name,
      percentage: 0,
      status: "ready",
      size: f.size,
      raw: f,
      uid: f.uid
    };
    if (e.listType === "picture-card" || e.listType === "picture")
      try {
        h.url = URL.createObjectURL(f);
      } catch (v) {
        pt(ui, v.message), e.onError(v, h, n.value);
      }
    n.value = [...n.value, h], e.onChange(h, n.value);
  }, p = async (f) => {
    const h = f instanceof File ? l(f) : f;
    h || wt(ui, "file to be removed not found");
    const v = (m) => {
      o(m);
      const g = n.value;
      g.splice(g.indexOf(m), 1), e.onRemove(m, g), ST(m);
    };
    e.beforeRemove ? await e.beforeRemove(h, n.value) !== !1 && v(h) : v(h);
  };
  function d() {
    n.value.filter(({ status: f }) => f === "ready").forEach(({ raw: f }) => {
      var h;
      return f && ((h = t.value) == null ? void 0 : h.upload(f));
    });
  }
  return ue(() => e.listType, (f) => {
    f !== "picture-card" && f !== "picture" || (n.value = n.value.map((h) => {
      const { raw: v, url: m } = h;
      if (!m && v)
        try {
          h.url = URL.createObjectURL(v);
        } catch (g) {
          e.onError(g, h, n.value);
        }
      return h;
    }));
  }), ue(n, (f) => {
    for (const h of f)
      h.uid || (h.uid = Js()), h.status || (h.status = "success");
  }, { immediate: !0, deep: !0 }), {
    uploadFiles: n,
    abort: o,
    clearFiles: a,
    handleError: r,
    handleProgress: i,
    handleStart: c,
    handleSuccess: u,
    handleRemove: p,
    submit: d
  };
}, $T = F({
  name: "ElUpload"
}), TT = /* @__PURE__ */ F({
  ...$T,
  props: nT,
  setup(e, { expose: t }) {
    const n = e, l = kn(), o = Pn(), a = ht(), {
      abort: r,
      submit: i,
      clearFiles: u,
      uploadFiles: c,
      handleStart: p,
      handleError: d,
      handleRemove: f,
      handleSuccess: h,
      handleProgress: v
    } = ET(n, a), m = k(() => n.listType === "picture-card"), g = k(() => ({
      ...n,
      fileList: c.value,
      onStart: p,
      onProgress: v,
      onSuccess: h,
      onError: d,
      onRemove: f
    }));
    return Dt(() => {
      c.value.forEach(({ url: w }) => {
        w != null && w.startsWith("blob:") && URL.revokeObjectURL(w);
      });
    }), tt(td, {
      accept: tn(n, "accept")
    }), t({
      abort: r,
      submit: i,
      clearFiles: u,
      handleStart: p,
      handleRemove: f
    }), (w, C) => (E(), _("div", null, [
      s(m) && w.showFileList ? (E(), q(ri, {
        key: 0,
        disabled: s(o),
        "list-type": w.listType,
        files: s(c),
        "handle-preview": w.onPreview,
        onRemove: s(f)
      }, Yn({
        append: K(() => [
          x(ii, Be({
            ref_key: "uploadRef",
            ref: a
          }, s(g)), {
            default: K(() => [
              s(l).trigger ? ne(w.$slots, "trigger", { key: 0 }) : W("v-if", !0),
              !s(l).trigger && s(l).default ? ne(w.$slots, "default", { key: 1 }) : W("v-if", !0)
            ]),
            _: 3
          }, 16)
        ]),
        _: 2
      }, [
        w.$slots.file ? {
          name: "default",
          fn: K(({ file: y }) => [
            ne(w.$slots, "file", { file: y })
          ])
        } : void 0
      ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : W("v-if", !0),
      !s(m) || s(m) && !w.showFileList ? (E(), q(ii, Be({
        key: 1,
        ref_key: "uploadRef",
        ref: a
      }, s(g)), {
        default: K(() => [
          s(l).trigger ? ne(w.$slots, "trigger", { key: 0 }) : W("v-if", !0),
          !s(l).trigger && s(l).default ? ne(w.$slots, "default", { key: 1 }) : W("v-if", !0)
        ]),
        _: 3
      }, 16)) : W("v-if", !0),
      w.$slots.trigger ? ne(w.$slots, "default", { key: 2 }) : W("v-if", !0),
      ne(w.$slots, "tip"),
      !s(m) && w.showFileList ? (E(), q(ri, {
        key: 3,
        disabled: s(o),
        "list-type": w.listType,
        files: s(c),
        "handle-preview": w.onPreview,
        onRemove: s(f)
      }, Yn({ _: 2 }, [
        w.$slots.file ? {
          name: "default",
          fn: K(({ file: y }) => [
            ne(w.$slots, "file", { file: y })
          ])
        } : void 0
      ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : W("v-if", !0)
    ]));
  }
});
var NT = /* @__PURE__ */ de(TT, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload.vue"]]);
const IT = xe(NT);
var MT = [
  Mh,
  Vh,
  jh,
  r1,
  Jh,
  sv,
  vu,
  yv,
  bv,
  Kt,
  Li,
  Qv,
  np,
  pm,
  hm,
  zm,
  Pm,
  Gm,
  Yt,
  lp,
  Bi,
  cp,
  rf,
  uf,
  cf,
  Sg,
  wh,
  Lg,
  Vg,
  Bg,
  Dg,
  xg,
  tp,
  Yg,
  Xg,
  df,
  Bu,
  cy,
  tb,
  nb,
  lb,
  Uu,
  ff,
  pf,
  Se,
  Yb,
  qu,
  Jn,
  Ni,
  n0,
  k0,
  S0,
  E0,
  $0,
  P0,
  bC,
  $C,
  _C,
  hf,
  ec,
  Di,
  op,
  sp,
  ZC,
  nw,
  fp,
  Zn,
  Gn,
  Ro,
  vf,
  qw,
  tk,
  nk,
  Pk,
  Bk,
  bc,
  Gk,
  lS,
  oS,
  vS,
  kE,
  SE,
  a1,
  mf,
  gf,
  Mo,
  f1,
  Av,
  y1,
  S1,
  E1,
  Wt,
  X1,
  d$,
  $$,
  P$,
  X$,
  IT
];
const Xt = "ElInfiniteScroll", RT = 50, OT = 200, PT = 0, AT = {
  delay: {
    type: Number,
    default: OT
  },
  distance: {
    type: Number,
    default: PT
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  immediate: {
    type: Boolean,
    default: !0
  }
}, Xa = (e, t) => Object.entries(AT).reduce((n, [l, o]) => {
  var a, r;
  const { type: i, default: u } = o, c = e.getAttribute(`infinite-scroll-${l}`);
  let p = (r = (a = t[c]) != null ? a : c) != null ? r : u;
  return p = p === "false" ? !1 : p, p = i(p), n[l] = Number.isNaN(p) ? u : p, n;
}, {}), sd = (e) => {
  const { observer: t } = e[Xt];
  t && (t.disconnect(), delete e[Xt].observer);
}, _T = (e, t) => {
  const { container: n, containerEl: l, instance: o, observer: a, lastScrollTop: r } = e[Xt], { disabled: i, distance: u } = Xa(e, o), { clientHeight: c, scrollHeight: p, scrollTop: d } = l, f = d - r;
  if (e[Xt].lastScrollTop = d, a || i || f < 0)
    return;
  let h = !1;
  if (n === e)
    h = p - (c + d) <= u;
  else {
    const { clientTop: v, scrollHeight: m } = e, g = gp(e, l);
    h = d + c >= g + v + m - u;
  }
  h && t.call(o);
};
function vs(e, t) {
  const { containerEl: n, instance: l } = e[Xt], { disabled: o } = Xa(e, l);
  o || n.clientHeight === 0 || (n.scrollHeight <= n.clientHeight ? t.call(l) : sd(e));
}
const LT = {
  async mounted(e, t) {
    const { instance: n, value: l } = t;
    mt(l) || wt(Xt, "'v-infinite-scroll' binding value must be a function"), await Ne();
    const { delay: o, immediate: a } = Xa(e, n), r = oa(e, !0), i = r === window ? document.documentElement : r, u = Wn(_T.bind(null, e, l), o);
    if (!!r) {
      if (e[Xt] = {
        instance: n,
        container: r,
        containerEl: i,
        delay: o,
        cb: l,
        onScroll: u,
        lastScrollTop: i.scrollTop
      }, a) {
        const c = new MutationObserver(Wn(vs.bind(null, e, l), RT));
        e[Xt].observer = c, c.observe(e, { childList: !0, subtree: !0 }), vs(e, l);
      }
      r.addEventListener("scroll", u);
    }
  },
  unmounted(e) {
    const { container: t, onScroll: n } = e[Xt];
    t == null || t.removeEventListener("scroll", n), sd(e);
  },
  async updated(e) {
    if (!e[Xt])
      await Ne();
    else {
      const { containerEl: t, cb: n, observer: l } = e[Xt];
      t.clientHeight && l && vs(e, n);
    }
  }
}, Qs = LT;
Qs.install = (e) => {
  e.directive("InfiniteScroll", Qs);
};
const VT = Qs;
function BT(e) {
  let t;
  const n = N(!1), l = ct({
    ...e,
    originalPosition: "",
    originalOverflow: "",
    visible: !1
  });
  function o(f) {
    l.text = f;
  }
  function a() {
    const f = l.parent, h = d.ns;
    if (!f.vLoadingAddClassList) {
      let v = f.getAttribute("loading-number");
      v = Number.parseInt(v) - 1, v ? f.setAttribute("loading-number", v.toString()) : (zt(f, h.bm("parent", "relative")), f.removeAttribute("loading-number")), zt(f, h.bm("parent", "hidden"));
    }
    r(), p.unmount();
  }
  function r() {
    var f, h;
    (h = (f = d.$el) == null ? void 0 : f.parentNode) == null || h.removeChild(d.$el);
  }
  function i() {
    var f;
    e.beforeClose && !e.beforeClose() || (n.value = !0, clearTimeout(t), t = window.setTimeout(u, 400), l.visible = !1, (f = e.closed) == null || f.call(e));
  }
  function u() {
    if (!n.value)
      return;
    const f = l.parent;
    n.value = !1, f.vLoadingAddClassList = void 0, a();
  }
  const c = F({
    name: "ElLoading",
    setup(f, { expose: h }) {
      const { ns: v } = qo("loading"), m = Uo();
      return h({
        ns: v,
        zIndex: m
      }), () => {
        const g = l.spinner || l.svg, w = fe("svg", {
          class: "circular",
          viewBox: l.svgViewBox ? l.svgViewBox : "0 0 50 50",
          ...g ? { innerHTML: g } : {}
        }, [
          fe("circle", {
            class: "path",
            cx: "25",
            cy: "25",
            r: "20",
            fill: "none"
          })
        ]), C = l.text ? fe("p", { class: v.b("text") }, [l.text]) : void 0;
        return fe(jt, {
          name: v.b("fade"),
          onAfterLeave: u
        }, {
          default: K(() => [
            qe(x("div", {
              style: {
                backgroundColor: l.background || ""
              },
              class: [
                v.b("mask"),
                l.customClass,
                l.fullscreen ? "is-fullscreen" : ""
              ]
            }, [
              fe("div", {
                class: v.b("spinner")
              }, [w, C])
            ]), [[at, l.visible]])
          ])
        });
      };
    }
  }), p = If(c), d = p.mount(document.createElement("div"));
  return {
    ...Ut(l),
    setText: o,
    removeElLoadingChild: r,
    close: i,
    handleAfterLeave: u,
    vm: d,
    get $el() {
      return d.$el;
    }
  };
}
let ro;
const ea = function(e = {}) {
  if (!rt)
    return;
  const t = DT(e);
  if (t.fullscreen && ro)
    return ro;
  const n = BT({
    ...t,
    closed: () => {
      var o;
      (o = t.closed) == null || o.call(t), t.fullscreen && (ro = void 0);
    }
  });
  xT(t, t.parent, n), ci(t, t.parent, n), t.parent.vLoadingAddClassList = () => ci(t, t.parent, n);
  let l = t.parent.getAttribute("loading-number");
  return l ? l = `${Number.parseInt(l) + 1}` : l = "1", t.parent.setAttribute("loading-number", l), t.parent.appendChild(n.$el), Ne(() => n.visible.value = t.visible), t.fullscreen && (ro = n), n;
}, DT = (e) => {
  var t, n, l, o;
  let a;
  return Ue(e.target) ? a = (t = document.querySelector(e.target)) != null ? t : document.body : a = e.target || document.body, {
    parent: a === document.body || e.body ? document.body : a,
    background: e.background || "",
    svg: e.svg || "",
    svgViewBox: e.svgViewBox || "",
    spinner: e.spinner || !1,
    text: e.text || "",
    fullscreen: a === document.body && ((n = e.fullscreen) != null ? n : !0),
    lock: (l = e.lock) != null ? l : !1,
    customClass: e.customClass || "",
    visible: (o = e.visible) != null ? o : !0,
    target: a
  };
}, xT = async (e, t, n) => {
  const { nextZIndex: l } = n.vm.zIndex, o = {};
  if (e.fullscreen)
    n.originalPosition.value = Vn(document.body, "position"), n.originalOverflow.value = Vn(document.body, "overflow"), o.zIndex = l();
  else if (e.parent === document.body) {
    n.originalPosition.value = Vn(document.body, "position"), await Ne();
    for (const a of ["top", "left"]) {
      const r = a === "top" ? "scrollTop" : "scrollLeft";
      o[a] = `${e.target.getBoundingClientRect()[a] + document.body[r] + document.documentElement[r] - Number.parseInt(Vn(document.body, `margin-${a}`), 10)}px`;
    }
    for (const a of ["height", "width"])
      o[a] = `${e.target.getBoundingClientRect()[a]}px`;
  } else
    n.originalPosition.value = Vn(t, "position");
  for (const [a, r] of Object.entries(o))
    n.$el.style[a] = r;
}, ci = (e, t, n) => {
  const l = n.vm.ns;
  ["absolute", "fixed", "sticky"].includes(n.originalPosition.value) ? zt(t, l.bm("parent", "relative")) : yn(t, l.bm("parent", "relative")), e.fullscreen && e.lock ? yn(t, l.bm("parent", "hidden")) : zt(t, l.bm("parent", "hidden"));
}, ta = Symbol("ElLoading"), di = (e, t) => {
  var n, l, o, a;
  const r = t.instance, i = (f) => Ct(t.value) ? t.value[f] : void 0, u = (f) => {
    const h = Ue(f) && (r == null ? void 0 : r[f]) || f;
    return h && N(h);
  }, c = (f) => u(i(f) || e.getAttribute(`element-loading-${yf(f)}`)), p = (n = i("fullscreen")) != null ? n : t.modifiers.fullscreen, d = {
    text: c("text"),
    svg: c("svg"),
    svgViewBox: c("svgViewBox"),
    spinner: c("spinner"),
    background: c("background"),
    customClass: c("customClass"),
    fullscreen: p,
    target: (l = i("target")) != null ? l : p ? void 0 : e,
    body: (o = i("body")) != null ? o : t.modifiers.body,
    lock: (a = i("lock")) != null ? a : t.modifiers.lock
  };
  e[ta] = {
    options: d,
    instance: ea(d)
  };
}, FT = (e, t) => {
  for (const n of Object.keys(t))
    Nn(t[n]) && (t[n].value = e[n]);
}, fi = {
  mounted(e, t) {
    t.value && di(e, t);
  },
  updated(e, t) {
    const n = e[ta];
    t.oldValue !== t.value && (t.value && !t.oldValue ? di(e, t) : t.value && t.oldValue ? Ct(t.value) && FT(t.value, n.options) : n == null || n.instance.close());
  },
  unmounted(e) {
    var t;
    (t = e[ta]) == null || t.instance.close();
  }
}, HT = {
  install(e) {
    e.directive("loading", fi), e.config.globalProperties.$loading = ea;
  },
  directive: fi,
  service: ea
}, ad = ["success", "info", "warning", "error"], _t = Et({
  customClass: "",
  center: !1,
  dangerouslyUseHTMLString: !1,
  duration: 3e3,
  icon: void 0,
  id: "",
  message: "",
  onClose: void 0,
  showClose: !1,
  type: "info",
  offset: 16,
  zIndex: 0,
  grouping: !1,
  repeatNum: 1,
  appendTo: rt ? document.body : void 0
}), zT = he({
  customClass: {
    type: String,
    default: _t.customClass
  },
  center: {
    type: Boolean,
    default: _t.center
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: _t.dangerouslyUseHTMLString
  },
  duration: {
    type: Number,
    default: _t.duration
  },
  icon: {
    type: ft,
    default: _t.icon
  },
  id: {
    type: String,
    default: _t.id
  },
  message: {
    type: j([
      String,
      Object,
      Function
    ]),
    default: _t.message
  },
  onClose: {
    type: j(Function),
    required: !1
  },
  showClose: {
    type: Boolean,
    default: _t.showClose
  },
  type: {
    type: String,
    values: ad,
    default: _t.type
  },
  offset: {
    type: Number,
    default: _t.offset
  },
  zIndex: {
    type: Number,
    default: _t.zIndex
  },
  grouping: {
    type: Boolean,
    default: _t.grouping
  },
  repeatNum: {
    type: Number,
    default: _t.repeatNum
  }
}), KT = {
  destroy: () => !0
}, Jt = Mf([]), WT = (e) => {
  const t = Jt.findIndex((o) => o.id === e), n = Jt[t];
  let l;
  return t > 0 && (l = Jt[t - 1]), { current: n, prev: l };
}, jT = (e) => {
  const { prev: t } = WT(e);
  return t ? t.vm.exposed.bottom.value : 0;
}, UT = (e, t) => Jt.findIndex((l) => l.id === e) > 0 ? 20 : t, qT = ["id"], GT = ["innerHTML"], YT = F({
  name: "ElMessage"
}), XT = /* @__PURE__ */ F({
  ...YT,
  props: zT,
  emits: KT,
  setup(e, { expose: t }) {
    const n = e, { Close: l } = sa, { ns: o, zIndex: a } = qo("message"), { currentZIndex: r, nextZIndex: i } = a, u = N(), c = N(!1), p = N(0);
    let d;
    const f = k(() => n.type ? n.type === "error" ? "danger" : n.type : "info"), h = k(() => {
      const O = n.type;
      return { [o.bm("icon", O)]: O && In[O] };
    }), v = k(() => n.icon || In[n.type] || ""), m = k(() => jT(n.id)), g = k(() => UT(n.id, n.offset) + m.value), w = k(() => p.value + g.value), C = k(() => ({
      top: `${g.value}px`,
      zIndex: r.value
    }));
    function y() {
      n.duration !== 0 && ({ stop: d } = Vl(() => {
        S();
      }, n.duration));
    }
    function b() {
      d == null || d();
    }
    function S() {
      c.value = !1;
    }
    function T({ code: O }) {
      O === Ce.esc && S();
    }
    return We(() => {
      y(), i(), c.value = !0;
    }), ue(() => n.repeatNum, () => {
      b(), y();
    }), Nt(document, "keydown", T), Mn(u, () => {
      p.value = u.value.getBoundingClientRect().height;
    }), t({
      visible: c,
      bottom: w,
      close: S
    }), (O, I) => (E(), q(jt, {
      name: s(o).b("fade"),
      onBeforeLeave: O.onClose,
      onAfterLeave: I[0] || (I[0] = (R) => O.$emit("destroy")),
      persisted: ""
    }, {
      default: K(() => [
        qe(H("div", {
          id: O.id,
          ref_key: "messageRef",
          ref: u,
          class: $([
            s(o).b(),
            { [s(o).m(O.type)]: O.type && !O.icon },
            s(o).is("center", O.center),
            s(o).is("closable", O.showClose),
            O.customClass
          ]),
          style: ye(s(C)),
          role: "alert",
          onMouseenter: b,
          onMouseleave: y
        }, [
          O.repeatNum > 1 ? (E(), q(s(vu), {
            key: 0,
            value: O.repeatNum,
            type: s(f),
            class: $(s(o).e("badge"))
          }, null, 8, ["value", "type", "class"])) : W("v-if", !0),
          s(v) ? (E(), q(s(Se), {
            key: 1,
            class: $([s(o).e("icon"), s(h)])
          }, {
            default: K(() => [
              (E(), q(Ge(s(v))))
            ]),
            _: 1
          }, 8, ["class"])) : W("v-if", !0),
          ne(O.$slots, "default", {}, () => [
            O.dangerouslyUseHTMLString ? (E(), _(Re, { key: 1 }, [
              W(" Caution here, message could've been compromised, never use user's input as message "),
              H("p", {
                class: $(s(o).e("content")),
                innerHTML: O.message
              }, null, 10, GT)
            ], 2112)) : (E(), _("p", {
              key: 0,
              class: $(s(o).e("content"))
            }, ce(O.message), 3))
          ]),
          O.showClose ? (E(), q(s(Se), {
            key: 2,
            class: $(s(o).e("closeBtn")),
            onClick: Ae(S, ["stop"])
          }, {
            default: K(() => [
              x(s(l))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : W("v-if", !0)
        ], 46, qT), [
          [at, c.value]
        ])
      ]),
      _: 3
    }, 8, ["name", "onBeforeLeave"]));
  }
});
var ZT = /* @__PURE__ */ de(XT, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]]);
let JT = 1;
const rd = (e) => {
  const t = !e || Ue(e) || Mt(e) || mt(e) ? { message: e } : e, n = {
    ..._t,
    ...t
  };
  if (!n.appendTo)
    n.appendTo = document.body;
  else if (Ue(n.appendTo)) {
    let l = document.querySelector(n.appendTo);
    hl(l) || (pt("ElMessage", "the appendTo option is not an HTMLElement. Falling back to document.body."), l = document.body), n.appendTo = l;
  }
  return n;
}, QT = (e) => {
  const t = Jt.indexOf(e);
  if (t === -1)
    return;
  Jt.splice(t, 1);
  const { handler: n } = e;
  n.close();
}, eN = ({ appendTo: e, ...t }, n) => {
  const l = `message_${JT++}`, o = t.onClose, a = document.createElement("div"), r = {
    ...t,
    id: l,
    onClose: () => {
      o == null || o(), QT(p);
    },
    onDestroy: () => {
      vl(null, a);
    }
  }, i = x(ZT, r, mt(r.message) || Mt(r.message) ? {
    default: mt(r.message) ? r.message : () => r.message
  } : null);
  i.appContext = n || bl._context, vl(i, a), e.appendChild(a.firstElementChild);
  const u = i.component, p = {
    id: l,
    vnode: i,
    vm: u,
    handler: {
      close: () => {
        u.exposed.visible.value = !1;
      }
    },
    props: i.component.props
  };
  return p;
}, bl = (e = {}, t) => {
  if (!rt)
    return { close: () => {
    } };
  if (Pe(Ss.max) && Jt.length >= Ss.max)
    return { close: () => {
    } };
  const n = rd(e);
  if (n.grouping && Jt.length) {
    const o = Jt.find(({ vnode: a }) => {
      var r;
      return ((r = a.props) == null ? void 0 : r.message) === n.message;
    });
    if (o)
      return o.props.repeatNum += 1, o.props.type = n.type, o.handler;
  }
  const l = eN(n, t);
  return Jt.push(l), l.handler;
};
ad.forEach((e) => {
  bl[e] = (t = {}, n) => {
    const l = rd(t);
    return bl({ ...l, type: e }, n);
  };
});
function tN(e) {
  for (const t of Jt)
    (!e || e === t.props.type) && t.handler.close();
}
bl.closeAll = tN;
bl._context = null;
const nN = Mi(bl, "$message"), lN = F({
  name: "ElMessageBox",
  directives: {
    TrapFocus: Cv
  },
  components: {
    ElButton: Kt,
    ElFocusTrap: wi,
    ElInput: Jn,
    ElOverlay: Ci,
    ElIcon: Se,
    ...sa
  },
  inheritAttrs: !1,
  props: {
    buttonSize: {
      type: String,
      validator: ia
    },
    modal: {
      type: Boolean,
      default: !0
    },
    lockScroll: {
      type: Boolean,
      default: !0
    },
    showClose: {
      type: Boolean,
      default: !0
    },
    closeOnClickModal: {
      type: Boolean,
      default: !0
    },
    closeOnPressEscape: {
      type: Boolean,
      default: !0
    },
    closeOnHashChange: {
      type: Boolean,
      default: !0
    },
    center: Boolean,
    draggable: Boolean,
    roundButton: {
      default: !1,
      type: Boolean
    },
    container: {
      type: String,
      default: "body"
    },
    boxType: {
      type: String,
      default: ""
    }
  },
  emits: ["vanish", "action"],
  setup(e, { emit: t }) {
    const {
      locale: n,
      zIndex: l,
      ns: o,
      size: a
    } = qo("message-box", k(() => e.buttonSize)), { t: r } = n, { nextZIndex: i } = l, u = N(!1), c = ct({
      autofocus: !0,
      beforeClose: null,
      callback: null,
      cancelButtonText: "",
      cancelButtonClass: "",
      confirmButtonText: "",
      confirmButtonClass: "",
      customClass: "",
      customStyle: {},
      dangerouslyUseHTMLString: !1,
      distinguishCancelAndClose: !1,
      icon: "",
      inputPattern: null,
      inputPlaceholder: "",
      inputType: "text",
      inputValue: null,
      inputValidator: null,
      inputErrorMessage: "",
      message: null,
      modalFade: !0,
      modalClass: "",
      showCancelButton: !1,
      showConfirmButton: !0,
      type: "",
      title: void 0,
      showInput: !1,
      action: "",
      confirmButtonLoading: !1,
      cancelButtonLoading: !1,
      confirmButtonDisabled: !1,
      editorErrorMessage: "",
      validateError: !1,
      zIndex: i()
    }), p = k(() => {
      const J = c.type;
      return { [o.bm("icon", J)]: J && In[J] };
    }), d = pl(), f = pl(), h = k(() => c.icon || In[c.type] || ""), v = k(() => !!c.message), m = N(), g = N(), w = N(), C = N(), y = N(), b = k(() => c.confirmButtonClass);
    ue(() => c.inputValue, async (J) => {
      await Ne(), e.boxType === "prompt" && J !== null && D();
    }, { immediate: !0 }), ue(() => u.value, (J) => {
      var V, M;
      J && (e.boxType !== "prompt" && (c.autofocus ? w.value = (M = (V = y.value) == null ? void 0 : V.$el) != null ? M : m.value : w.value = m.value), c.zIndex = i()), e.boxType === "prompt" && (J ? Ne().then(() => {
        var P;
        C.value && C.value.$el && (c.autofocus ? w.value = (P = A()) != null ? P : m.value : w.value = m.value);
      }) : (c.editorErrorMessage = "", c.validateError = !1));
    });
    const S = k(() => e.draggable);
    bf(m, g, S), We(async () => {
      await Ne(), e.closeOnHashChange && window.addEventListener("hashchange", T);
    }), Dt(() => {
      e.closeOnHashChange && window.removeEventListener("hashchange", T);
    });
    function T() {
      !u.value || (u.value = !1, Ne(() => {
        c.action && t("action", c.action);
      }));
    }
    const O = () => {
      e.closeOnClickModal && B(c.distinguishCancelAndClose ? "close" : "cancel");
    }, I = wf(O), R = (J) => {
      if (c.inputType !== "textarea")
        return J.preventDefault(), B("confirm");
    }, B = (J) => {
      var V;
      e.boxType === "prompt" && J === "confirm" && !D() || (c.action = J, c.beforeClose ? (V = c.beforeClose) == null || V.call(c, J, c, T) : T());
    }, D = () => {
      if (e.boxType === "prompt") {
        const J = c.inputPattern;
        if (J && !J.test(c.inputValue || ""))
          return c.editorErrorMessage = c.inputErrorMessage || r("el.messagebox.error"), c.validateError = !0, !1;
        const V = c.inputValidator;
        if (typeof V == "function") {
          const M = V(c.inputValue);
          if (M === !1)
            return c.editorErrorMessage = c.inputErrorMessage || r("el.messagebox.error"), c.validateError = !0, !1;
          if (typeof M == "string")
            return c.editorErrorMessage = M, c.validateError = !0, !1;
        }
      }
      return c.editorErrorMessage = "", c.validateError = !1, !0;
    }, A = () => {
      const J = C.value.$refs;
      return J.input || J.textarea;
    }, z = () => {
      B("close");
    }, Z = () => {
      e.closeOnPressEscape && z();
    };
    return e.lockScroll && Cf(u), Up(u), {
      ...Ut(c),
      ns: o,
      overlayEvent: I,
      visible: u,
      hasMessage: v,
      typeClass: p,
      contentId: d,
      inputId: f,
      btnSize: a,
      iconComponent: h,
      confirmButtonClasses: b,
      rootRef: m,
      focusStartRef: w,
      headerRef: g,
      inputRef: C,
      confirmRef: y,
      doClose: T,
      handleClose: z,
      onCloseRequested: Z,
      handleWrapperClick: O,
      handleInputEnter: R,
      handleAction: B,
      t: r
    };
  }
}), oN = ["aria-label", "aria-describedby"], sN = ["aria-label"], aN = ["id"];
function rN(e, t, n, l, o, a) {
  const r = $e("el-icon"), i = $e("close"), u = $e("el-input"), c = $e("el-button"), p = $e("el-focus-trap"), d = $e("el-overlay");
  return E(), q(jt, {
    name: "fade-in-linear",
    onAfterLeave: t[11] || (t[11] = (f) => e.$emit("vanish")),
    persisted: ""
  }, {
    default: K(() => [
      qe(x(d, {
        "z-index": e.zIndex,
        "overlay-class": [e.ns.is("message-box"), e.modalClass],
        mask: e.modal
      }, {
        default: K(() => [
          H("div", {
            role: "dialog",
            "aria-label": e.title,
            "aria-modal": "true",
            "aria-describedby": e.showInput ? void 0 : e.contentId,
            class: $(`${e.ns.namespace.value}-overlay-message-box`),
            onClick: t[8] || (t[8] = (...f) => e.overlayEvent.onClick && e.overlayEvent.onClick(...f)),
            onMousedown: t[9] || (t[9] = (...f) => e.overlayEvent.onMousedown && e.overlayEvent.onMousedown(...f)),
            onMouseup: t[10] || (t[10] = (...f) => e.overlayEvent.onMouseup && e.overlayEvent.onMouseup(...f))
          }, [
            x(p, {
              loop: "",
              trapped: e.visible,
              "focus-trap-el": e.rootRef,
              "focus-start-el": e.focusStartRef,
              onReleaseRequested: e.onCloseRequested
            }, {
              default: K(() => [
                H("div", {
                  ref: "rootRef",
                  class: $([
                    e.ns.b(),
                    e.customClass,
                    e.ns.is("draggable", e.draggable),
                    { [e.ns.m("center")]: e.center }
                  ]),
                  style: ye(e.customStyle),
                  tabindex: "-1",
                  onClick: t[7] || (t[7] = Ae(() => {
                  }, ["stop"]))
                }, [
                  e.title !== null && e.title !== void 0 ? (E(), _("div", {
                    key: 0,
                    ref: "headerRef",
                    class: $(e.ns.e("header"))
                  }, [
                    H("div", {
                      class: $(e.ns.e("title"))
                    }, [
                      e.iconComponent && e.center ? (E(), q(r, {
                        key: 0,
                        class: $([e.ns.e("status"), e.typeClass])
                      }, {
                        default: K(() => [
                          (E(), q(Ge(e.iconComponent)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : W("v-if", !0),
                      H("span", null, ce(e.title), 1)
                    ], 2),
                    e.showClose ? (E(), _("button", {
                      key: 0,
                      type: "button",
                      class: $(e.ns.e("headerbtn")),
                      "aria-label": e.t("el.messagebox.close"),
                      onClick: t[0] || (t[0] = (f) => e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel")),
                      onKeydown: t[1] || (t[1] = ut(Ae((f) => e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
                    }, [
                      x(r, {
                        class: $(e.ns.e("close"))
                      }, {
                        default: K(() => [
                          x(i)
                        ]),
                        _: 1
                      }, 8, ["class"])
                    ], 42, sN)) : W("v-if", !0)
                  ], 2)) : W("v-if", !0),
                  H("div", {
                    id: e.contentId,
                    class: $(e.ns.e("content"))
                  }, [
                    H("div", {
                      class: $(e.ns.e("container"))
                    }, [
                      e.iconComponent && !e.center && e.hasMessage ? (E(), q(r, {
                        key: 0,
                        class: $([e.ns.e("status"), e.typeClass])
                      }, {
                        default: K(() => [
                          (E(), q(Ge(e.iconComponent)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : W("v-if", !0),
                      e.hasMessage ? (E(), _("div", {
                        key: 1,
                        class: $(e.ns.e("message"))
                      }, [
                        ne(e.$slots, "default", {}, () => [
                          e.dangerouslyUseHTMLString ? (E(), q(Ge(e.showInput ? "label" : "p"), {
                            key: 1,
                            for: e.showInput ? e.inputId : void 0,
                            innerHTML: e.message
                          }, null, 8, ["for", "innerHTML"])) : (E(), q(Ge(e.showInput ? "label" : "p"), {
                            key: 0,
                            for: e.showInput ? e.inputId : void 0
                          }, {
                            default: K(() => [
                              st(ce(e.dangerouslyUseHTMLString ? "" : e.message), 1)
                            ]),
                            _: 1
                          }, 8, ["for"]))
                        ])
                      ], 2)) : W("v-if", !0)
                    ], 2),
                    qe(H("div", {
                      class: $(e.ns.e("input"))
                    }, [
                      x(u, {
                        id: e.inputId,
                        ref: "inputRef",
                        modelValue: e.inputValue,
                        "onUpdate:modelValue": t[2] || (t[2] = (f) => e.inputValue = f),
                        type: e.inputType,
                        placeholder: e.inputPlaceholder,
                        "aria-invalid": e.validateError,
                        class: $({ invalid: e.validateError }),
                        onKeydown: ut(e.handleInputEnter, ["enter"])
                      }, null, 8, ["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                      H("div", {
                        class: $(e.ns.e("errormsg")),
                        style: ye({
                          visibility: e.editorErrorMessage ? "visible" : "hidden"
                        })
                      }, ce(e.editorErrorMessage), 7)
                    ], 2), [
                      [at, e.showInput]
                    ])
                  ], 10, aN),
                  H("div", {
                    class: $(e.ns.e("btns"))
                  }, [
                    e.showCancelButton ? (E(), q(c, {
                      key: 0,
                      loading: e.cancelButtonLoading,
                      class: $([e.cancelButtonClass]),
                      round: e.roundButton,
                      size: e.btnSize,
                      onClick: t[3] || (t[3] = (f) => e.handleAction("cancel")),
                      onKeydown: t[4] || (t[4] = ut(Ae((f) => e.handleAction("cancel"), ["prevent"]), ["enter"]))
                    }, {
                      default: K(() => [
                        st(ce(e.cancelButtonText || e.t("el.messagebox.cancel")), 1)
                      ]),
                      _: 1
                    }, 8, ["loading", "class", "round", "size"])) : W("v-if", !0),
                    qe(x(c, {
                      ref: "confirmRef",
                      type: "primary",
                      loading: e.confirmButtonLoading,
                      class: $([e.confirmButtonClasses]),
                      round: e.roundButton,
                      disabled: e.confirmButtonDisabled,
                      size: e.btnSize,
                      onClick: t[5] || (t[5] = (f) => e.handleAction("confirm")),
                      onKeydown: t[6] || (t[6] = ut(Ae((f) => e.handleAction("confirm"), ["prevent"]), ["enter"]))
                    }, {
                      default: K(() => [
                        st(ce(e.confirmButtonText || e.t("el.messagebox.confirm")), 1)
                      ]),
                      _: 1
                    }, 8, ["loading", "class", "round", "disabled", "size"]), [
                      [at, e.showConfirmButton]
                    ])
                  ], 2)
                ], 6)
              ]),
              _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
          ], 42, oN)
        ]),
        _: 3
      }, 8, ["z-index", "overlay-class", "mask"]), [
        [at, e.visible]
      ])
    ]),
    _: 3
  });
}
var iN = /* @__PURE__ */ de(lN, [["render", rN], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/message-box/src/index.vue"]]);
const Gl = /* @__PURE__ */ new Map(), uN = (e) => {
  let t = document.body;
  return e.appendTo && (Ue(e.appendTo) && (t = document.querySelector(e.appendTo)), hl(e.appendTo) && (t = e.appendTo), hl(t) || (pt("ElMessageBox", "the appendTo option is not an HTMLElement. Falling back to document.body."), t = document.body)), t;
}, cN = (e, t, n = null) => {
  const l = x(iN, e, mt(e.message) || Mt(e.message) ? {
    default: mt(e.message) ? e.message : () => e.message
  } : null);
  return l.appContext = n, vl(l, t), uN(e).appendChild(t.firstElementChild), l.component;
}, dN = () => document.createElement("div"), fN = (e, t) => {
  const n = dN();
  e.onVanish = () => {
    vl(null, n), Gl.delete(o);
  }, e.onAction = (a) => {
    const r = Gl.get(o);
    let i;
    e.showInput ? i = { value: o.inputValue, action: a } : i = a, e.callback ? e.callback(i, l.proxy) : a === "cancel" || a === "close" ? e.distinguishCancelAndClose && a !== "cancel" ? r.reject("close") : r.reject("cancel") : r.resolve(i);
  };
  const l = cN(e, n, t), o = l.proxy;
  for (const a in e)
    Bt(e, a) && !Bt(o.$props, a) && (o[a] = e[a]);
  return o.visible = !0, o;
};
function El(e, t = null) {
  if (!rt)
    return Promise.reject();
  let n;
  return Ue(e) || Mt(e) ? e = {
    message: e
  } : n = e.callback, new Promise((l, o) => {
    const a = fN(e, t != null ? t : El._context);
    Gl.set(a, {
      options: e,
      callback: n,
      resolve: l,
      reject: o
    });
  });
}
const pN = ["alert", "confirm", "prompt"], hN = {
  alert: { closeOnPressEscape: !1, closeOnClickModal: !1 },
  confirm: { showCancelButton: !0 },
  prompt: { showCancelButton: !0, showInput: !0 }
};
pN.forEach((e) => {
  El[e] = vN(e);
});
function vN(e) {
  return (t, n, l, o) => {
    let a = "";
    return Ct(n) ? (l = n, a = "") : qn(n) ? a = "" : a = n, El(Object.assign({
      title: a,
      message: t,
      type: "",
      ...hN[e]
    }, l, {
      boxType: e
    }), o);
  };
}
El.close = () => {
  Gl.forEach((e, t) => {
    t.doClose();
  }), Gl.clear();
};
El._context = null;
const En = El;
En.install = (e) => {
  En._context = e._context, e.config.globalProperties.$msgbox = En, e.config.globalProperties.$messageBox = En, e.config.globalProperties.$alert = En.alert, e.config.globalProperties.$confirm = En.confirm, e.config.globalProperties.$prompt = En.prompt;
};
const mN = En, id = [
  "success",
  "info",
  "warning",
  "error"
], gN = he({
  customClass: {
    type: String,
    default: ""
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: !1
  },
  duration: {
    type: Number,
    default: 4500
  },
  icon: {
    type: ft
  },
  id: {
    type: String,
    default: ""
  },
  message: {
    type: j([String, Object]),
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  onClick: {
    type: j(Function),
    default: () => {
    }
  },
  onClose: {
    type: j(Function),
    required: !0
  },
  position: {
    type: String,
    values: ["top-right", "top-left", "bottom-right", "bottom-left"],
    default: "top-right"
  },
  showClose: {
    type: Boolean,
    default: !0
  },
  title: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: [...id, ""],
    default: ""
  },
  zIndex: {
    type: Number,
    default: 0
  }
}), yN = {
  destroy: () => !0
}, bN = ["id"], CN = ["textContent"], wN = { key: 0 }, kN = ["innerHTML"], SN = F({
  name: "ElNotification"
}), EN = /* @__PURE__ */ F({
  ...SN,
  props: gN,
  emits: yN,
  setup(e, { expose: t }) {
    const n = e, { ns: l, zIndex: o } = qo("notification"), { nextZIndex: a, currentZIndex: r } = o, { Close: i } = kf, u = N(!1);
    let c;
    const p = k(() => {
      const y = n.type;
      return y && In[n.type] ? l.m(y) : "";
    }), d = k(() => n.type && In[n.type] || n.icon), f = k(() => n.position.endsWith("right") ? "right" : "left"), h = k(() => n.position.startsWith("top") ? "top" : "bottom"), v = k(() => ({
      [h.value]: `${n.offset}px`,
      zIndex: r.value
    }));
    function m() {
      n.duration > 0 && ({ stop: c } = Vl(() => {
        u.value && w();
      }, n.duration));
    }
    function g() {
      c == null || c();
    }
    function w() {
      u.value = !1;
    }
    function C({ code: y }) {
      y === Ce.delete || y === Ce.backspace ? g() : y === Ce.esc ? u.value && w() : m();
    }
    return We(() => {
      m(), a(), u.value = !0;
    }), Nt(document, "keydown", C), t({
      visible: u,
      close: w
    }), (y, b) => (E(), q(jt, {
      name: s(l).b("fade"),
      onBeforeLeave: y.onClose,
      onAfterLeave: b[1] || (b[1] = (S) => y.$emit("destroy")),
      persisted: ""
    }, {
      default: K(() => [
        qe(H("div", {
          id: y.id,
          class: $([s(l).b(), y.customClass, s(f)]),
          style: ye(s(v)),
          role: "alert",
          onMouseenter: g,
          onMouseleave: m,
          onClick: b[0] || (b[0] = (...S) => y.onClick && y.onClick(...S))
        }, [
          s(d) ? (E(), q(s(Se), {
            key: 0,
            class: $([s(l).e("icon"), s(p)])
          }, {
            default: K(() => [
              (E(), q(Ge(s(d))))
            ]),
            _: 1
          }, 8, ["class"])) : W("v-if", !0),
          H("div", {
            class: $(s(l).e("group"))
          }, [
            H("h2", {
              class: $(s(l).e("title")),
              textContent: ce(y.title)
            }, null, 10, CN),
            qe(H("div", {
              class: $(s(l).e("content")),
              style: ye(y.title ? void 0 : { margin: 0 })
            }, [
              ne(y.$slots, "default", {}, () => [
                y.dangerouslyUseHTMLString ? (E(), _(Re, { key: 1 }, [
                  W(" Caution here, message could've been compromised, never use user's input as message "),
                  H("p", { innerHTML: y.message }, null, 8, kN)
                ], 2112)) : (E(), _("p", wN, ce(y.message), 1))
              ])
            ], 6), [
              [at, y.message]
            ]),
            y.showClose ? (E(), q(s(Se), {
              key: 0,
              class: $(s(l).e("closeBtn")),
              onClick: Ae(w, ["stop"])
            }, {
              default: K(() => [
                x(s(i))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : W("v-if", !0)
          ], 2)
        ], 46, bN), [
          [at, u.value]
        ])
      ]),
      _: 3
    }, 8, ["name", "onBeforeLeave"]));
  }
});
var $N = /* @__PURE__ */ de(EN, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/notification/src/notification.vue"]]);
const Ho = {
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  "bottom-right": []
}, na = 16;
let TN = 1;
const Cl = function(e = {}, t = null) {
  if (!rt)
    return { close: () => {
    } };
  (typeof e == "string" || Mt(e)) && (e = { message: e });
  const n = e.position || "top-right";
  let l = e.offset || 0;
  Ho[n].forEach(({ vm: p }) => {
    var d;
    l += (((d = p.el) == null ? void 0 : d.offsetHeight) || 0) + na;
  }), l += na;
  const o = `notification_${TN++}`, a = e.onClose, r = {
    ...e,
    offset: l,
    id: o,
    onClose: () => {
      NN(o, n, a);
    }
  };
  let i = document.body;
  hl(e.appendTo) ? i = e.appendTo : Ue(e.appendTo) && (i = document.querySelector(e.appendTo)), hl(i) || (pt("ElNotification", "the appendTo option is not an HTMLElement. Falling back to document.body."), i = document.body);
  const u = document.createElement("div"), c = x($N, r, Mt(r.message) ? {
    default: () => r.message
  } : null);
  return c.appContext = t != null ? t : Cl._context, c.props.onDestroy = () => {
    vl(null, u);
  }, vl(c, u), Ho[n].push({ vm: c }), i.appendChild(u.firstElementChild), {
    close: () => {
      c.component.exposed.visible.value = !1;
    }
  };
};
id.forEach((e) => {
  Cl[e] = (t = {}) => ((typeof t == "string" || Mt(t)) && (t = {
    message: t
  }), Cl({
    ...t,
    type: e
  }));
});
function NN(e, t, n) {
  const l = Ho[t], o = l.findIndex(({ vm: c }) => {
    var p;
    return ((p = c.component) == null ? void 0 : p.props.id) === e;
  });
  if (o === -1)
    return;
  const { vm: a } = l[o];
  if (!a)
    return;
  n == null || n(a);
  const r = a.el.offsetHeight, i = t.split("-")[0];
  l.splice(o, 1);
  const u = l.length;
  if (!(u < 1))
    for (let c = o; c < u; c++) {
      const { el: p, component: d } = l[c].vm, f = Number.parseInt(p.style[i], 10) - r - na;
      d.props.offset = f;
    }
}
function IN() {
  for (const e of Object.values(Ho))
    e.forEach(({ vm: t }) => {
      t.component.exposed.visible.value = !1;
    });
}
Cl.closeAll = IN;
Cl._context = null;
const MN = Mi(Cl, "$notify");
var RN = [
  VT,
  HT,
  nN,
  mN,
  MN,
  Qu
], ud = Sh([...MT, ...RN]);
const nI = ud.install, lI = ud.version;
export {
  aI as BAR_MAP,
  Sa as CASCADER_PANEL_INJECTION_KEY,
  rI as CHANGE_EVENT,
  iI as ClickOutside,
  QR as CommonPicker,
  Mu as CommonProps,
  eO as DEFAULT_FORMATS_DATE,
  tO as DEFAULT_FORMATS_DATEPICKER,
  nO as DEFAULT_FORMATS_TIME,
  Fy as DROPDOWN_COLLECTION_INJECTION_KEY,
  Hy as DROPDOWN_COLLECTION_ITEM_INJECTION_KEY,
  Qo as DROPDOWN_INJECTION_KEY,
  Tm as DefaultProps,
  kw as DynamicSizeGrid,
  mw as DynamicSizeList,
  uI as EVENT_CODE,
  cI as Effect,
  Mh as ElAffix,
  Vh as ElAlert,
  Vg as ElAside,
  r1 as ElAutoResizer,
  jh as ElAutocomplete,
  Jh as ElAvatar,
  sv as ElBacktop,
  vu as ElBadge,
  yv as ElBreadcrumb,
  bv as ElBreadcrumbItem,
  jR as ElButton,
  UR as ElButtonGroup,
  Qv as ElCalendar,
  kO as ElCard,
  pm as ElCarousel,
  hm as ElCarouselItem,
  zm as ElCascader,
  Pm as ElCascaderPanel,
  Gm as ElCheckTag,
  $O as ElCheckbox,
  TO as ElCheckboxButton,
  NO as ElCheckboxGroup,
  jO as ElCol,
  dI as ElCollapse,
  fI as ElCollapseItem,
  pI as ElCollapseTransition,
  Dy as ElCollection,
  xy as ElCollectionItem,
  Sg as ElColorPicker,
  wh as ElConfigProvider,
  Lg as ElContainer,
  Gk as ElCountdown,
  lO as ElDatePicker,
  Yg as ElDescriptions,
  Xg as ElDescriptionsItem,
  hI as ElDialog,
  Bu as ElDivider,
  cy as ElDrawer,
  tb as ElDropdown,
  nb as ElDropdownItem,
  lb as ElDropdownMenu,
  Uu as ElEmpty,
  Bg as ElFooter,
  vI as ElForm,
  mI as ElFormItem,
  Dg as ElHeader,
  gI as ElIcon,
  Yb as ElImage,
  qu as ElImageViewer,
  VT as ElInfiniteScroll,
  yI as ElInput,
  bI as ElInputNumber,
  n0 as ElLink,
  HT as ElLoading,
  fi as ElLoadingDirective,
  ea as ElLoadingService,
  xg as ElMain,
  k0 as ElMenu,
  S0 as ElMenuItem,
  E0 as ElMenuItemGroup,
  nN as ElMessage,
  mN as ElMessageBox,
  MN as ElNotification,
  CI as ElOption,
  wI as ElOptionGroup,
  kI as ElOverlay,
  P0 as ElPageHeader,
  bC as ElPagination,
  $C as ElPopconfirm,
  _C as ElPopover,
  Qu as ElPopoverDirective,
  SI as ElPopper,
  EI as ElPopperArrow,
  $I as ElPopperContent,
  TI as ElPopperTrigger,
  ec as ElProgress,
  _O as ElRadio,
  LO as ElRadioButton,
  VO as ElRadioGroup,
  ZC as ElRate,
  nw as ElResult,
  GO as ElRow,
  NI as ElScrollbar,
  II as ElSelect,
  qw as ElSelectV2,
  tk as ElSkeleton,
  nk as ElSkeletonItem,
  Pk as ElSlider,
  Bk as ElSpace,
  bc as ElStatistic,
  oS as ElStep,
  lS as ElSteps,
  $0 as ElSubMenu,
  vS as ElSwitch,
  MI as ElTabPane,
  kE as ElTable,
  SE as ElTableColumn,
  a1 as ElTableV2,
  RI as ElTabs,
  OI as ElTag,
  f1 as ElText,
  Av as ElTimePicker,
  y1 as ElTimeSelect,
  S1 as ElTimeline,
  E1 as ElTimelineItem,
  PI as ElTooltip,
  d$ as ElTransfer,
  $$ as ElTree,
  P$ as ElTreeSelect,
  X$ as ElTreeV2,
  IT as ElUpload,
  Vy as FIRST_KEYS,
  By as FIRST_LAST_KEYS,
  AI as FORWARD_REF_INJECTION_KEY,
  yw as FixedSizeGrid,
  uc as FixedSizeList,
  _I as GAP,
  LI as ID_INJECTION_KEY,
  VI as INPUT_EVENT,
  ur as INSTALLED_KEY,
  Ar as IconComponentMap,
  ol as IconMap,
  zu as LAST_KEYS,
  zc as LEFT_CHECK_CHANGE_EVENT,
  Nv as Mousewheel,
  BI as POPPER_CONTENT_INJECTION_KEY,
  DI as POPPER_INJECTION_KEY,
  Kc as RIGHT_CHECK_CHANGE_EVENT,
  oO as ROOT_PICKER_INJECTION_KEY,
  YO as RowAlign,
  XO as RowJustify,
  xI as SIZE_INJECTION_KEY,
  FI as TOOLTIP_INJECTION_KEY,
  l1 as TableV2,
  Ul as TableV2Alignment,
  Rc as TableV2FixedDir,
  ql as TableV2Placeholder,
  jl as TableV2SortOrder,
  sO as TimePickPanel,
  Cv as TrapFocus,
  HI as UPDATE_MODEL_EVENT,
  aO as WEEK_DAYS,
  $h as affixEmits,
  Eh as affixProps,
  Rh as alertEffects,
  Ph as alertEmits,
  Oh as alertProps,
  yh as arrowMiddleware,
  o1 as autoResizerProps,
  Dh as autocompleteEmits,
  Bh as autocompleteProps,
  qh as avatarEmits,
  Uh as avatarProps,
  ev as backtopEmits,
  Qh as backtopProps,
  av as badgeProps,
  vv as breadcrumbItemProps,
  mu as breadcrumbKey,
  dv as breadcrumbProps,
  zI as buildLocaleContext,
  rO as buildTimeList,
  KI as buildTranslator,
  qR as buttonEmits,
  GR as buttonGroupContextKey,
  YR as buttonNativeTypes,
  XR as buttonProps,
  ZR as buttonTypes,
  Yv as calendarEmits,
  Gv as calendarProps,
  SO as cardProps,
  Tu as carouselContextKey,
  tm as carouselEmits,
  im as carouselItemProps,
  em as carouselProps,
  _m as cascaderEmits,
  Am as cascaderProps,
  Wm as checkTagEmits,
  Km as checkTagProps,
  IO as checkboxEmits,
  MO as checkboxGroupContextKey,
  RO as checkboxGroupEmits,
  OO as checkboxGroupProps,
  PO as checkboxProps,
  UO as colProps,
  WI as collapseContextKey,
  jI as collapseEmits,
  UI as collapseItemProps,
  qI as collapseProps,
  Ou as colorPickerContextKey,
  ag as colorPickerEmits,
  sg as colorPickerProps,
  GI as componentSizeMap,
  YI as componentSizes,
  XI as configProviderContextKey,
  bh as configProviderProps,
  Kk as countdownEmits,
  zk as countdownProps,
  ZI as createModelToggleComposable,
  iO as dateEquals,
  uO as datePickTypes,
  CO as dayjs,
  ud as default,
  JI as defaultInitialZIndex,
  QI as defaultNamespace,
  jg as descriptionProps,
  eM as dialogEmits,
  tM as dialogInjectionKey,
  nM as dialogProps,
  Zg as dividerProps,
  ny as drawerEmits,
  ty as drawerProps,
  Hu as dropdownItemProps,
  Ly as dropdownMenuProps,
  yo as dropdownProps,
  Ju as elPaginationKey,
  lM as emitChangeFn,
  Rb as emptyProps,
  cO as extractDateFormat,
  dO as extractTimeFormat,
  oM as formContextKey,
  sM as formEmits,
  aM as formItemContextKey,
  rM as formItemProps,
  iM as formItemValidateStates,
  uM as formProps,
  fO as formatter,
  Js as genFileId,
  tI as getPositionDataWithUnit,
  cM as iconProps,
  Kb as imageEmits,
  zb as imageProps,
  Bb as imageViewerEmits,
  Vb as imageViewerProps,
  dM as inputEmits,
  fM as inputNumberEmits,
  pM as inputNumberProps,
  hM as inputProps,
  nI as install,
  Zb as linkEmits,
  Xb as linkProps,
  vM as localeContextKey,
  Sh as makeInstaller,
  pO as makeList,
  f0 as menuEmits,
  v0 as menuItemEmits,
  y0 as menuItemGroupProps,
  h0 as menuItemProps,
  d0 as menuProps,
  Ss as messageConfig,
  _t as messageDefaults,
  KT as messageEmits,
  zT as messageProps,
  ad as messageTypes,
  mM as namespaceContextKey,
  yN as notificationEmits,
  gN as notificationProps,
  id as notificationTypes,
  gM as overlayEmits,
  yM as overlayProps,
  N0 as pageHeaderEmits,
  T0 as pageHeaderProps,
  gC as paginationEmits,
  mC as paginationProps,
  hO as parseDate,
  wC as popconfirmEmits,
  CC as popconfirmProps,
  NC as popoverEmits,
  TC as popoverProps,
  bM as popperArrowProps,
  CM as popperContentEmits,
  wM as popperContentProps,
  kM as popperCoreConfigProps,
  SM as popperProps,
  EM as popperTriggerProps,
  LC as progressProps,
  $M as provideGlobalConfig,
  BO as radioButtonProps,
  DO as radioEmits,
  xO as radioGroupEmits,
  FO as radioGroupKey,
  HO as radioGroupProps,
  zO as radioProps,
  KO as radioPropsBase,
  vO as rangeArr,
  jC as rateEmits,
  WC as rateProps,
  TM as renderThumbStyle,
  JC as resultProps,
  NM as roleTypes,
  QO as rowContextKey,
  ZO as rowProps,
  IM as scrollbarContextKey,
  MM as scrollbarEmits,
  RM as scrollbarProps,
  OM as selectGroupKey,
  PM as selectKey,
  gc as selectV2InjectionKey,
  Yw as skeletonItemProps,
  Gw as skeletonProps,
  yc as sliderContextKey,
  ok as sliderEmits,
  lk as sliderProps,
  Lk as spaceProps,
  Dk as statisticProps,
  eS as stepProps,
  Xk as stepsEmits,
  Yk as stepsProps,
  c0 as subMenuProps,
  aS as switchEmits,
  sS as switchProps,
  AM as tabBarProps,
  _M as tabNavEmits,
  LM as tabNavProps,
  VM as tabPaneProps,
  _E as tableV2Props,
  zn as tableV2RowProps,
  BM as tabsEmits,
  DM as tabsProps,
  xM as tabsRootContextKey,
  FM as tagEmits,
  HM as tagProps,
  i1 as textProps,
  zM as thumbProps,
  mO as timePickerDefaultProps,
  gO as timeUnits,
  C1 as timelineItemProps,
  KM as tooltipEmits,
  Us as transferCheckedChangeFn,
  Z1 as transferEmits,
  ll as transferProps,
  WM as translate,
  ld as uploadBaseProps,
  yT as uploadContentProps,
  td as uploadContextKey,
  pT as uploadDraggerEmits,
  fT as uploadDraggerProps,
  oT as uploadListEmits,
  lT as uploadListProps,
  nd as uploadListTypes,
  nT as uploadProps,
  jM as useAttrs,
  Nm as useCascaderConfig,
  UM as useCursor,
  QN as useDelayedRender,
  qM as useDelayedToggle,
  GM as useDelayedToggleProps,
  YM as useDeprecated,
  XM as useDialog,
  ZM as useDisabled,
  JM as useDraggable,
  QM as useEscapeKeydown,
  gh as useFloating,
  eI as useFloatingProps,
  eR as useFocus,
  tR as useFormDisabled,
  nR as useFormItem,
  lR as useFormItemInputId,
  oR as useFormSize,
  sR as useForwardRef,
  aR as useForwardRefDirective,
  rR as useGetDerivedNamespace,
  iR as useGlobalComponentSettings,
  uR as useGlobalConfig,
  cR as useGlobalSize,
  dR as useId,
  fR as useIdInjection,
  pR as useLocale,
  hR as useLockscreen,
  GN as useModal,
  vR as useModelToggle,
  mR as useModelToggleEmits,
  gR as useModelToggleProps,
  yR as useNamespace,
  bR as useOrderedChildren,
  CR as usePopper,
  wR as usePopperArrowProps,
  kR as usePopperContainer,
  SR as usePopperContainerId,
  ER as usePopperContentEmits,
  $R as usePopperContentProps,
  TR as usePopperCoreConfigProps,
  NR as usePopperProps,
  IR as usePopperTriggerProps,
  YN as usePreventGlobal,
  MR as useProp,
  Up as useRestoreActive,
  RR as useSameTarget,
  OR as useSize,
  PR as useSizeProp,
  AR as useSizeProps,
  _k as useSpace,
  XN as useTeleport,
  qp as useThrottleRender,
  _R as useTimeout,
  LR as useTooltipContentProps,
  VR as useTooltipModelToggle,
  BR as useTooltipModelToggleEmits,
  DR as useTooltipModelToggleProps,
  xR as useTooltipProps,
  FR as useTooltipTriggerProps,
  JN as useTransitionFallthrough,
  ZN as useTransitionFallthroughEmits,
  HR as useZIndex,
  fi as vLoading,
  zR as vRepeatClick,
  yO as valueEquals,
  lI as version,
  jn as virtualizedGridProps,
  oc as virtualizedListProps,
  lc as virtualizedProps,
  rc as virtualizedScrollbarProps,
  KR as zIndexContextKey
};
